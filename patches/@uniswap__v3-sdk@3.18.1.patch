diff --git a/dist/v3-sdk.cjs.development.js b/dist/v3-sdk.cjs.development.js
index 47314a007e55794d9cff57bbcce676b2b3e109f1..038d7659fbe79b29308777a49b08377923c54cac 100644
--- a/dist/v3-sdk.cjs.development.js
+++ b/dist/v3-sdk.cjs.development.js
@@ -1,478 +1,609 @@
-'use strict';
+'use strict'
 
-Object.defineProperty(exports, '__esModule', { value: true });
+Object.defineProperty(exports, '__esModule', { value: true })
 
-function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
+function _interopDefault(ex) {
+  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex
+}
 
-var sdkCore = require('@uniswap/sdk-core');
-var JSBI = _interopDefault(require('jsbi'));
-var invariant = _interopDefault(require('tiny-invariant'));
-var abi = require('@ethersproject/abi');
-var address = require('@ethersproject/address');
-var solidity = require('@ethersproject/solidity');
-var IMulticall = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json'));
-var INonfungiblePositionManager = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'));
-var ISelfPermit = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json'));
-var IPeripheryPaymentsWithFee = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json'));
-var IQuoter = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json'));
-var IQuoterV2 = _interopDefault(require('@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json'));
-var IUniswapV3Staker = _interopDefault(require('@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json'));
-var ISwapRouter = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'));
+var sdkCore = require('@uniswap/sdk-core')
+var JSBI = _interopDefault(require('jsbi'))
+var invariant = _interopDefault(require('tiny-invariant'))
+var abi = require('@ethersproject/abi')
+var address = require('@ethersproject/address')
+var solidity = require('@ethersproject/solidity')
+var IMulticall = _interopDefault(
+  require('@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json'),
+)
+var INonfungiblePositionManager = _interopDefault(
+  require('@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'),
+)
+var ISelfPermit = _interopDefault(
+  require('@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json'),
+)
+var IPeripheryPaymentsWithFee = _interopDefault(
+  require('@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json'),
+)
+var IQuoter = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json'))
+var IQuoterV2 = _interopDefault(
+  require('@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json'),
+)
+var IUniswapV3Staker = _interopDefault(
+  require('@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json'),
+)
+var ISwapRouter = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'))
 
 function _regeneratorRuntime() {
   _regeneratorRuntime = function () {
-    return e;
-  };
+    return e
+  }
   var t,
     e = {},
     r = Object.prototype,
     n = r.hasOwnProperty,
-    o = Object.defineProperty || function (t, e, r) {
-      t[e] = r.value;
-    },
-    i = "function" == typeof Symbol ? Symbol : {},
-    a = i.iterator || "@@iterator",
-    c = i.asyncIterator || "@@asyncIterator",
-    u = i.toStringTag || "@@toStringTag";
+    o =
+      Object.defineProperty ||
+      function (t, e, r) {
+        t[e] = r.value
+      },
+    i = 'function' == typeof Symbol ? Symbol : {},
+    a = i.iterator || '@@iterator',
+    c = i.asyncIterator || '@@asyncIterator',
+    u = i.toStringTag || '@@toStringTag'
   function define(t, e, r) {
-    return Object.defineProperty(t, e, {
-      value: r,
-      enumerable: !0,
-      configurable: !0,
-      writable: !0
-    }), t[e];
+    return (
+      Object.defineProperty(t, e, {
+        value: r,
+        enumerable: !0,
+        configurable: !0,
+        writable: !0,
+      }),
+      t[e]
+    )
   }
   try {
-    define({}, "");
+    define({}, '')
   } catch (t) {
     define = function (t, e, r) {
-      return t[e] = r;
-    };
+      return (t[e] = r)
+    }
   }
   function wrap(t, e, r, n) {
     var i = e && e.prototype instanceof Generator ? e : Generator,
       a = Object.create(i.prototype),
-      c = new Context(n || []);
-    return o(a, "_invoke", {
-      value: makeInvokeMethod(t, r, c)
-    }), a;
+      c = new Context(n || [])
+    return (
+      o(a, '_invoke', {
+        value: makeInvokeMethod(t, r, c),
+      }),
+      a
+    )
   }
   function tryCatch(t, e, r) {
     try {
       return {
-        type: "normal",
-        arg: t.call(e, r)
-      };
+        type: 'normal',
+        arg: t.call(e, r),
+      }
     } catch (t) {
       return {
-        type: "throw",
-        arg: t
-      };
+        type: 'throw',
+        arg: t,
+      }
     }
   }
-  e.wrap = wrap;
-  var h = "suspendedStart",
-    l = "suspendedYield",
-    f = "executing",
-    s = "completed",
-    y = {};
+  e.wrap = wrap
+  var h = 'suspendedStart',
+    l = 'suspendedYield',
+    f = 'executing',
+    s = 'completed',
+    y = {}
   function Generator() {}
   function GeneratorFunction() {}
   function GeneratorFunctionPrototype() {}
-  var p = {};
+  var p = {}
   define(p, a, function () {
-    return this;
-  });
+    return this
+  })
   var d = Object.getPrototypeOf,
-    v = d && d(d(values([])));
-  v && v !== r && n.call(v, a) && (p = v);
-  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
+    v = d && d(d(values([])))
+  v && v !== r && n.call(v, a) && (p = v)
+  var g = (GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p))
   function defineIteratorMethods(t) {
-    ["next", "throw", "return"].forEach(function (e) {
+    ;['next', 'throw', 'return'].forEach(function (e) {
       define(t, e, function (t) {
-        return this._invoke(e, t);
-      });
-    });
+        return this._invoke(e, t)
+      })
+    })
   }
   function AsyncIterator(t, e) {
     function invoke(r, o, i, a) {
-      var c = tryCatch(t[r], t, o);
-      if ("throw" !== c.type) {
+      var c = tryCatch(t[r], t, o)
+      if ('throw' !== c.type) {
         var u = c.arg,
-          h = u.value;
-        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
-          invoke("next", t, i, a);
-        }, function (t) {
-          invoke("throw", t, i, a);
-        }) : e.resolve(h).then(function (t) {
-          u.value = t, i(u);
-        }, function (t) {
-          return invoke("throw", t, i, a);
-        });
+          h = u.value
+        return h && 'object' == typeof h && n.call(h, '__await')
+          ? e.resolve(h.__await).then(
+              function (t) {
+                invoke('next', t, i, a)
+              },
+              function (t) {
+                invoke('throw', t, i, a)
+              },
+            )
+          : e.resolve(h).then(
+              function (t) {
+                ;(u.value = t), i(u)
+              },
+              function (t) {
+                return invoke('throw', t, i, a)
+              },
+            )
       }
-      a(c.arg);
+      a(c.arg)
     }
-    var r;
-    o(this, "_invoke", {
+    var r
+    o(this, '_invoke', {
       value: function (t, n) {
         function callInvokeWithMethodAndArg() {
           return new e(function (e, r) {
-            invoke(t, n, e, r);
-          });
+            invoke(t, n, e, r)
+          })
         }
-        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
-      }
-    });
+        return (r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg())
+      },
+    })
   }
   function makeInvokeMethod(e, r, n) {
-    var o = h;
+    var o = h
     return function (i, a) {
-      if (o === f) throw new Error("Generator is already running");
+      if (o === f) throw new Error('Generator is already running')
       if (o === s) {
-        if ("throw" === i) throw a;
+        if ('throw' === i) throw a
         return {
           value: t,
-          done: !0
-        };
+          done: !0,
+        }
       }
-      for (n.method = i, n.arg = a;;) {
-        var c = n.delegate;
+      for (n.method = i, n.arg = a; ; ) {
+        var c = n.delegate
         if (c) {
-          var u = maybeInvokeDelegate(c, n);
+          var u = maybeInvokeDelegate(c, n)
           if (u) {
-            if (u === y) continue;
-            return u;
+            if (u === y) continue
+            return u
           }
         }
-        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
-          if (o === h) throw o = s, n.arg;
-          n.dispatchException(n.arg);
-        } else "return" === n.method && n.abrupt("return", n.arg);
-        o = f;
-        var p = tryCatch(e, r, n);
-        if ("normal" === p.type) {
-          if (o = n.done ? s : l, p.arg === y) continue;
+        if ('next' === n.method) n.sent = n._sent = n.arg
+        else if ('throw' === n.method) {
+          if (o === h) throw ((o = s), n.arg)
+          n.dispatchException(n.arg)
+        } else 'return' === n.method && n.abrupt('return', n.arg)
+        o = f
+        var p = tryCatch(e, r, n)
+        if ('normal' === p.type) {
+          if (((o = n.done ? s : l), p.arg === y)) continue
           return {
             value: p.arg,
-            done: n.done
-          };
+            done: n.done,
+          }
         }
-        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
+        'throw' === p.type && ((o = s), (n.method = 'throw'), (n.arg = p.arg))
       }
-    };
+    }
   }
   function maybeInvokeDelegate(e, r) {
     var n = r.method,
-      o = e.iterator[n];
-    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
-    var i = tryCatch(o, e.iterator, r.arg);
-    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
-    var a = i.arg;
-    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
+      o = e.iterator[n]
+    if (o === t)
+      return (
+        (r.delegate = null),
+        ('throw' === n &&
+          e.iterator.return &&
+          ((r.method = 'return'), (r.arg = t), maybeInvokeDelegate(e, r), 'throw' === r.method)) ||
+          ('return' !== n &&
+            ((r.method = 'throw'), (r.arg = new TypeError("The iterator does not provide a '" + n + "' method")))),
+        y
+      )
+    var i = tryCatch(o, e.iterator, r.arg)
+    if ('throw' === i.type) return (r.method = 'throw'), (r.arg = i.arg), (r.delegate = null), y
+    var a = i.arg
+    return a
+      ? a.done
+        ? ((r[e.resultName] = a.value),
+          (r.next = e.nextLoc),
+          'return' !== r.method && ((r.method = 'next'), (r.arg = t)),
+          (r.delegate = null),
+          y)
+        : a
+      : ((r.method = 'throw'), (r.arg = new TypeError('iterator result is not an object')), (r.delegate = null), y)
   }
   function pushTryEntry(t) {
     var e = {
-      tryLoc: t[0]
-    };
-    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
+      tryLoc: t[0],
+    }
+    1 in t && (e.catchLoc = t[1]), 2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])), this.tryEntries.push(e)
   }
   function resetTryEntry(t) {
-    var e = t.completion || {};
-    e.type = "normal", delete e.arg, t.completion = e;
+    var e = t.completion || {}
+    ;(e.type = 'normal'), delete e.arg, (t.completion = e)
   }
   function Context(t) {
-    this.tryEntries = [{
-      tryLoc: "root"
-    }], t.forEach(pushTryEntry, this), this.reset(!0);
+    ;(this.tryEntries = [
+      {
+        tryLoc: 'root',
+      },
+    ]),
+      t.forEach(pushTryEntry, this),
+      this.reset(!0)
   }
   function values(e) {
-    if (e || "" === e) {
-      var r = e[a];
-      if (r) return r.call(e);
-      if ("function" == typeof e.next) return e;
+    if (e || '' === e) {
+      var r = e[a]
+      if (r) return r.call(e)
+      if ('function' == typeof e.next) return e
       if (!isNaN(e.length)) {
         var o = -1,
           i = function next() {
-            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
-            return next.value = t, next.done = !0, next;
-          };
-        return i.next = i;
+            for (; ++o < e.length; ) if (n.call(e, o)) return (next.value = e[o]), (next.done = !1), next
+            return (next.value = t), (next.done = !0), next
+          }
+        return (i.next = i)
       }
     }
-    throw new TypeError(typeof e + " is not iterable");
-  }
-  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
-    value: GeneratorFunctionPrototype,
-    configurable: !0
-  }), o(GeneratorFunctionPrototype, "constructor", {
-    value: GeneratorFunction,
-    configurable: !0
-  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
-    var e = "function" == typeof t && t.constructor;
-    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
-  }, e.mark = function (t) {
-    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
-  }, e.awrap = function (t) {
-    return {
-      __await: t
-    };
-  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
-    return this;
-  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
-    void 0 === i && (i = Promise);
-    var a = new AsyncIterator(wrap(t, r, n, o), i);
-    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
-      return t.done ? t.value : a.next();
-    });
-  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
-    return this;
-  }), define(g, "toString", function () {
-    return "[object Generator]";
-  }), e.keys = function (t) {
-    var e = Object(t),
-      r = [];
-    for (var n in e) r.push(n);
-    return r.reverse(), function next() {
-      for (; r.length;) {
-        var t = r.pop();
-        if (t in e) return next.value = t, next.done = !1, next;
-      }
-      return next.done = !0, next;
-    };
-  }, e.values = values, Context.prototype = {
-    constructor: Context,
-    reset: function (e) {
-      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
-    },
-    stop: function () {
-      this.done = !0;
-      var t = this.tryEntries[0].completion;
-      if ("throw" === t.type) throw t.arg;
-      return this.rval;
-    },
-    dispatchException: function (e) {
-      if (this.done) throw e;
-      var r = this;
-      function handle(n, o) {
-        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
+    throw new TypeError(typeof e + ' is not iterable')
+  }
+  return (
+    (GeneratorFunction.prototype = GeneratorFunctionPrototype),
+    o(g, 'constructor', {
+      value: GeneratorFunctionPrototype,
+      configurable: !0,
+    }),
+    o(GeneratorFunctionPrototype, 'constructor', {
+      value: GeneratorFunction,
+      configurable: !0,
+    }),
+    (GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, 'GeneratorFunction')),
+    (e.isGeneratorFunction = function (t) {
+      var e = 'function' == typeof t && t.constructor
+      return !!e && (e === GeneratorFunction || 'GeneratorFunction' === (e.displayName || e.name))
+    }),
+    (e.mark = function (t) {
+      return (
+        Object.setPrototypeOf
+          ? Object.setPrototypeOf(t, GeneratorFunctionPrototype)
+          : ((t.__proto__ = GeneratorFunctionPrototype), define(t, u, 'GeneratorFunction')),
+        (t.prototype = Object.create(g)),
+        t
+      )
+    }),
+    (e.awrap = function (t) {
+      return {
+        __await: t,
       }
-      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
-        var i = this.tryEntries[o],
-          a = i.completion;
-        if ("root" === i.tryLoc) return handle("end");
-        if (i.tryLoc <= this.prev) {
-          var c = n.call(i, "catchLoc"),
-            u = n.call(i, "finallyLoc");
-          if (c && u) {
-            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
-            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
-          } else if (c) {
-            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
-          } else {
-            if (!u) throw new Error("try statement without catch or finally");
-            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
+    }),
+    defineIteratorMethods(AsyncIterator.prototype),
+    define(AsyncIterator.prototype, c, function () {
+      return this
+    }),
+    (e.AsyncIterator = AsyncIterator),
+    (e.async = function (t, r, n, o, i) {
+      void 0 === i && (i = Promise)
+      var a = new AsyncIterator(wrap(t, r, n, o), i)
+      return e.isGeneratorFunction(r)
+        ? a
+        : a.next().then(function (t) {
+            return t.done ? t.value : a.next()
+          })
+    }),
+    defineIteratorMethods(g),
+    define(g, u, 'Generator'),
+    define(g, a, function () {
+      return this
+    }),
+    define(g, 'toString', function () {
+      return '[object Generator]'
+    }),
+    (e.keys = function (t) {
+      var e = Object(t),
+        r = []
+      for (var n in e) r.push(n)
+      return (
+        r.reverse(),
+        function next() {
+          for (; r.length; ) {
+            var t = r.pop()
+            if (t in e) return (next.value = t), (next.done = !1), next
           }
+          return (next.done = !0), next
         }
-      }
-    },
-    abrupt: function (t, e) {
-      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
-        var o = this.tryEntries[r];
-        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
-          var i = o;
-          break;
+      )
+    }),
+    (e.values = values),
+    (Context.prototype = {
+      constructor: Context,
+      reset: function (e) {
+        if (
+          ((this.prev = 0),
+          (this.next = 0),
+          (this.sent = this._sent = t),
+          (this.done = !1),
+          (this.delegate = null),
+          (this.method = 'next'),
+          (this.arg = t),
+          this.tryEntries.forEach(resetTryEntry),
+          !e)
+        )
+          for (var r in this) 't' === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t)
+      },
+      stop: function () {
+        this.done = !0
+        var t = this.tryEntries[0].completion
+        if ('throw' === t.type) throw t.arg
+        return this.rval
+      },
+      dispatchException: function (e) {
+        if (this.done) throw e
+        var r = this
+        function handle(n, o) {
+          return (a.type = 'throw'), (a.arg = e), (r.next = n), o && ((r.method = 'next'), (r.arg = t)), !!o
         }
-      }
-      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
-      var a = i ? i.completion : {};
-      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
-    },
-    complete: function (t, e) {
-      if ("throw" === t.type) throw t.arg;
-      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
-    },
-    finish: function (t) {
-      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
-        var r = this.tryEntries[e];
-        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
-      }
-    },
-    catch: function (t) {
-      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
-        var r = this.tryEntries[e];
-        if (r.tryLoc === t) {
-          var n = r.completion;
-          if ("throw" === n.type) {
-            var o = n.arg;
-            resetTryEntry(r);
+        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
+          var i = this.tryEntries[o],
+            a = i.completion
+          if ('root' === i.tryLoc) return handle('end')
+          if (i.tryLoc <= this.prev) {
+            var c = n.call(i, 'catchLoc'),
+              u = n.call(i, 'finallyLoc')
+            if (c && u) {
+              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0)
+              if (this.prev < i.finallyLoc) return handle(i.finallyLoc)
+            } else if (c) {
+              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0)
+            } else {
+              if (!u) throw new Error('try statement without catch or finally')
+              if (this.prev < i.finallyLoc) return handle(i.finallyLoc)
+            }
           }
-          return o;
         }
-      }
-      throw new Error("illegal catch attempt");
-    },
-    delegateYield: function (e, r, n) {
-      return this.delegate = {
-        iterator: values(e),
-        resultName: r,
-        nextLoc: n
-      }, "next" === this.method && (this.arg = t), y;
-    }
-  }, e;
+      },
+      abrupt: function (t, e) {
+        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
+          var o = this.tryEntries[r]
+          if (o.tryLoc <= this.prev && n.call(o, 'finallyLoc') && this.prev < o.finallyLoc) {
+            var i = o
+            break
+          }
+        }
+        i && ('break' === t || 'continue' === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null)
+        var a = i ? i.completion : {}
+        return (a.type = t), (a.arg = e), i ? ((this.method = 'next'), (this.next = i.finallyLoc), y) : this.complete(a)
+      },
+      complete: function (t, e) {
+        if ('throw' === t.type) throw t.arg
+        return (
+          'break' === t.type || 'continue' === t.type
+            ? (this.next = t.arg)
+            : 'return' === t.type
+              ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
+              : 'normal' === t.type && e && (this.next = e),
+          y
+        )
+      },
+      finish: function (t) {
+        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+          var r = this.tryEntries[e]
+          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y
+        }
+      },
+      catch: function (t) {
+        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+          var r = this.tryEntries[e]
+          if (r.tryLoc === t) {
+            var n = r.completion
+            if ('throw' === n.type) {
+              var o = n.arg
+              resetTryEntry(r)
+            }
+            return o
+          }
+        }
+        throw new Error('illegal catch attempt')
+      },
+      delegateYield: function (e, r, n) {
+        return (
+          (this.delegate = {
+            iterator: values(e),
+            resultName: r,
+            nextLoc: n,
+          }),
+          'next' === this.method && (this.arg = t),
+          y
+        )
+      },
+    }),
+    e
+  )
 }
 function _toPrimitive(t, r) {
-  if ("object" != typeof t || !t) return t;
-  var e = t[Symbol.toPrimitive];
+  if ('object' != typeof t || !t) return t
+  var e = t[Symbol.toPrimitive]
   if (void 0 !== e) {
-    var i = e.call(t, r || "default");
-    if ("object" != typeof i) return i;
-    throw new TypeError("@@toPrimitive must return a primitive value.");
+    var i = e.call(t, r || 'default')
+    if ('object' != typeof i) return i
+    throw new TypeError('@@toPrimitive must return a primitive value.')
   }
-  return ("string" === r ? String : Number)(t);
+  return ('string' === r ? String : Number)(t)
 }
 function _toPropertyKey(t) {
-  var i = _toPrimitive(t, "string");
-  return "symbol" == typeof i ? i : String(i);
+  var i = _toPrimitive(t, 'string')
+  return 'symbol' == typeof i ? i : String(i)
 }
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
   try {
-    var info = gen[key](arg);
-    var value = info.value;
+    var info = gen[key](arg)
+    var value = info.value
   } catch (error) {
-    reject(error);
-    return;
+    reject(error)
+    return
   }
   if (info.done) {
-    resolve(value);
+    resolve(value)
   } else {
-    Promise.resolve(value).then(_next, _throw);
+    Promise.resolve(value).then(_next, _throw)
   }
 }
 function _asyncToGenerator(fn) {
   return function () {
     var self = this,
-      args = arguments;
+      args = arguments
     return new Promise(function (resolve, reject) {
-      var gen = fn.apply(self, args);
+      var gen = fn.apply(self, args)
       function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value)
       }
       function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err)
       }
-      _next(undefined);
-    });
-  };
+      _next(undefined)
+    })
+  }
 }
 function _defineProperties(target, props) {
   for (var i = 0; i < props.length; i++) {
-    var descriptor = props[i];
-    descriptor.enumerable = descriptor.enumerable || false;
-    descriptor.configurable = true;
-    if ("value" in descriptor) descriptor.writable = true;
-    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
+    var descriptor = props[i]
+    descriptor.enumerable = descriptor.enumerable || false
+    descriptor.configurable = true
+    if ('value' in descriptor) descriptor.writable = true
+    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor)
   }
 }
 function _createClass(Constructor, protoProps, staticProps) {
-  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
-  if (staticProps) _defineProperties(Constructor, staticProps);
-  Object.defineProperty(Constructor, "prototype", {
-    writable: false
-  });
-  return Constructor;
+  if (protoProps) _defineProperties(Constructor.prototype, protoProps)
+  if (staticProps) _defineProperties(Constructor, staticProps)
+  Object.defineProperty(Constructor, 'prototype', {
+    writable: false,
+  })
+  return Constructor
 }
 function _extends() {
-  _extends = Object.assign ? Object.assign.bind() : function (target) {
-    for (var i = 1; i < arguments.length; i++) {
-      var source = arguments[i];
-      for (var key in source) {
-        if (Object.prototype.hasOwnProperty.call(source, key)) {
-          target[key] = source[key];
+  _extends = Object.assign
+    ? Object.assign.bind()
+    : function (target) {
+        for (var i = 1; i < arguments.length; i++) {
+          var source = arguments[i]
+          for (var key in source) {
+            if (Object.prototype.hasOwnProperty.call(source, key)) {
+              target[key] = source[key]
+            }
+          }
         }
+        return target
       }
-    }
-    return target;
-  };
-  return _extends.apply(this, arguments);
+  return _extends.apply(this, arguments)
 }
 function _objectWithoutPropertiesLoose(source, excluded) {
-  if (source == null) return {};
-  var target = {};
-  var sourceKeys = Object.keys(source);
-  var key, i;
+  if (source == null) return {}
+  var target = {}
+  var sourceKeys = Object.keys(source)
+  var key, i
   for (i = 0; i < sourceKeys.length; i++) {
-    key = sourceKeys[i];
-    if (excluded.indexOf(key) >= 0) continue;
-    target[key] = source[key];
+    key = sourceKeys[i]
+    if (excluded.indexOf(key) >= 0) continue
+    target[key] = source[key]
   }
-  return target;
+  return target
 }
 function _unsupportedIterableToArray(o, minLen) {
-  if (!o) return;
-  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
-  var n = Object.prototype.toString.call(o).slice(8, -1);
-  if (n === "Object" && o.constructor) n = o.constructor.name;
-  if (n === "Map" || n === "Set") return Array.from(o);
-  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
+  if (!o) return
+  if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
+  var n = Object.prototype.toString.call(o).slice(8, -1)
+  if (n === 'Object' && o.constructor) n = o.constructor.name
+  if (n === 'Map' || n === 'Set') return Array.from(o)
+  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen)
 }
 function _arrayLikeToArray(arr, len) {
-  if (len == null || len > arr.length) len = arr.length;
-  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
-  return arr2;
+  if (len == null || len > arr.length) len = arr.length
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]
+  return arr2
 }
 function _createForOfIteratorHelperLoose(o, allowArrayLike) {
-  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
-  if (it) return (it = it.call(o)).next.bind(it);
-  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
-    if (it) o = it;
-    var i = 0;
+  var it = (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator']
+  if (it) return (it = it.call(o)).next.bind(it)
+  if (
+    Array.isArray(o) ||
+    (it = _unsupportedIterableToArray(o)) ||
+    (allowArrayLike && o && typeof o.length === 'number')
+  ) {
+    if (it) o = it
+    var i = 0
     return function () {
-      if (i >= o.length) return {
-        done: true
-      };
+      if (i >= o.length)
+        return {
+          done: true,
+        }
       return {
         done: false,
-        value: o[i++]
-      };
-    };
+        value: o[i++],
+      }
+    }
   }
-  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+  throw new TypeError(
+    'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
+  )
 }
 
-var _TICK_SPACINGS;
-var FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984';
-var ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
+var _TICK_SPACINGS
+var FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984'
+var ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'
 // @deprecated please use poolInitCodeHash(chainId: ChainId)
-var POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54';
+var POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'
 function poolInitCodeHash(chainId) {
   switch (chainId) {
     case sdkCore.ChainId.ZKSYNC:
-      return '0x010013f177ea1fcbc4520f9a3ca7cd2d1d77959e05aa66484027cb38e712aeed';
+      return '0x010013f177ea1fcbc4520f9a3ca7cd2d1d77959e05aa66484027cb38e712aeed'
     default:
-      return POOL_INIT_CODE_HASH;
+      return POOL_INIT_CODE_HASH
   }
 }
-(function (FeeAmount) {
-  FeeAmount[FeeAmount["LOWEST"] = 100] = "LOWEST";
-  FeeAmount[FeeAmount["LOW_200"] = 200] = "LOW_200";
-  FeeAmount[FeeAmount["LOW_300"] = 300] = "LOW_300";
-  FeeAmount[FeeAmount["LOW_400"] = 400] = "LOW_400";
-  FeeAmount[FeeAmount["LOW"] = 500] = "LOW";
-  FeeAmount[FeeAmount["MEDIUM"] = 3000] = "MEDIUM";
-  FeeAmount[FeeAmount["HIGH"] = 10000] = "HIGH";
-})(exports.FeeAmount || (exports.FeeAmount = {}));
+;(function (FeeAmount) {
+  FeeAmount[(FeeAmount['LOWEST'] = 100)] = 'LOWEST'
+  FeeAmount[(FeeAmount['LOW_200'] = 200)] = 'LOW_200'
+  FeeAmount[(FeeAmount['LOW_300'] = 300)] = 'LOW_300'
+  FeeAmount[(FeeAmount['LOW_400'] = 400)] = 'LOW_400'
+  FeeAmount[(FeeAmount['LOW'] = 500)] = 'LOW'
+  FeeAmount[(FeeAmount['MEDIUM'] = 3000)] = 'MEDIUM'
+  FeeAmount[(FeeAmount['HIGH'] = 10000)] = 'HIGH'
+  FeeAmount[(FeeAmount['LOWEST_SWAPMODE'] = 80)] = 'LOWEST_SWAPMODE'
+  FeeAmount[(FeeAmount['LOW_SWAPMODE'] = 350)] = 'LOW_SWAPMODE'
+  FeeAmount[(FeeAmount['LOW_SWAPMODE_450'] = 450)] = 'LOW_SWAPMODE_450'
+  FeeAmount[(FeeAmount['MEDIUM_SWAPMODE'] = 2500)] = 'MEDIUM_SWAPMODE'
+})(exports.FeeAmount || (exports.FeeAmount = {}))
 /**
  * The default factory tick spacings by fee amount.
  */
-var TICK_SPACINGS = (_TICK_SPACINGS = {}, _TICK_SPACINGS[exports.FeeAmount.LOWEST] = 1, _TICK_SPACINGS[exports.FeeAmount.LOW_200] = 4, _TICK_SPACINGS[exports.FeeAmount.LOW_300] = 6, _TICK_SPACINGS[exports.FeeAmount.LOW_400] = 8, _TICK_SPACINGS[exports.FeeAmount.LOW] = 10, _TICK_SPACINGS[exports.FeeAmount.MEDIUM] = 60, _TICK_SPACINGS[exports.FeeAmount.HIGH] = 200, _TICK_SPACINGS);
+var TICK_SPACINGS =
+  ((_TICK_SPACINGS = {}),
+  (_TICK_SPACINGS[exports.FeeAmount.LOWEST] = 1),
+  (_TICK_SPACINGS[exports.FeeAmount.LOW_200] = 4),
+  (_TICK_SPACINGS[exports.FeeAmount.LOW_300] = 6),
+  (_TICK_SPACINGS[exports.FeeAmount.LOW_400] = 8),
+  (_TICK_SPACINGS[exports.FeeAmount.LOW] = 10),
+  (_TICK_SPACINGS[exports.FeeAmount.MEDIUM] = 60),
+  (_TICK_SPACINGS[exports.FeeAmount.HIGH] = 200),
+  (_TICK_SPACINGS[exports.FeeAmount.LOWEST_SWAPMODE] = 1),
+  (_TICK_SPACINGS[exports.FeeAmount.LOW_SWAPMODE] = 10),
+  (_TICK_SPACINGS[exports.FeeAmount.LOW_SWAPMODE_450] = 10),
+  (_TICK_SPACINGS[exports.FeeAmount.MEDIUM_SWAPMODE] = 60),
+  _TICK_SPACINGS)
 
 // constants used internally but not expected to be used externally
-var NEGATIVE_ONE = /*#__PURE__*/JSBI.BigInt(-1);
-var ZERO = /*#__PURE__*/JSBI.BigInt(0);
-var ONE = /*#__PURE__*/JSBI.BigInt(1);
+var NEGATIVE_ONE = /*#__PURE__*/ JSBI.BigInt(-1)
+var ZERO = /*#__PURE__*/ JSBI.BigInt(0)
+var ONE = /*#__PURE__*/ JSBI.BigInt(1)
 // used in liquidity amount math
-var Q96 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(96));
-var Q192 = /*#__PURE__*/JSBI.exponentiate(Q96, /*#__PURE__*/JSBI.BigInt(2));
+var Q96 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(96))
+var Q192 = /*#__PURE__*/ JSBI.exponentiate(Q96, /*#__PURE__*/ JSBI.BigInt(2))
 
 /**
  * Computes a pool address
@@ -490,200 +621,272 @@ function computePoolAddress(_ref) {
     tokenB = _ref.tokenB,
     fee = _ref.fee,
     initCodeHashManualOverride = _ref.initCodeHashManualOverride,
-    chainId = _ref.chainId;
+    chainId = _ref.chainId
   var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],
     token0 = _ref2[0],
-    token1 = _ref2[1]; // does safety checks
-  var salt = solidity.keccak256(['bytes'], [abi.defaultAbiCoder.encode(['address', 'address', 'uint24'], [token0.address, token1.address, fee])]);
-  var initCodeHash = initCodeHashManualOverride != null ? initCodeHashManualOverride : poolInitCodeHash(chainId);
+    token1 = _ref2[1] // does safety checks
+  var salt = solidity.keccak256(
+    ['bytes'],
+    [abi.defaultAbiCoder.encode(['address', 'address', 'uint24'], [token0.address, token1.address, fee])],
+  )
+  var initCodeHash = initCodeHashManualOverride != null ? initCodeHashManualOverride : poolInitCodeHash(chainId)
   // ZKSync uses a different create2 address computation
   // Most likely all ZKEVM chains will use the different computation from standard create2
   switch (chainId) {
     case sdkCore.ChainId.ZKSYNC:
-      return sdkCore.computeZksyncCreate2Address(factoryAddress, initCodeHash, salt);
+      return sdkCore.computeZksyncCreate2Address(factoryAddress, initCodeHash, salt)
     default:
-      return address.getCreate2Address(factoryAddress, salt, initCodeHash);
+      return address.getCreate2Address(factoryAddress, salt, initCodeHash)
   }
 }
 
-var FullMath = /*#__PURE__*/function () {
+var FullMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function FullMath() {}
   FullMath.mulDivRoundingUp = function mulDivRoundingUp(a, b, denominator) {
-    var product = JSBI.multiply(a, b);
-    var result = JSBI.divide(product, denominator);
-    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE);
-    return result;
-  };
-  return FullMath;
-}();
+    var product = JSBI.multiply(a, b)
+    var result = JSBI.divide(product, denominator)
+    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE)
+    return result
+  }
+  return FullMath
+})()
 
-var MaxUint160 = /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(160)), ONE);
+var MaxUint160 = /*#__PURE__*/ JSBI.subtract(
+  /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(160)),
+  ONE,
+)
 function multiplyIn256(x, y) {
-  var product = JSBI.multiply(x, y);
-  return JSBI.bitwiseAnd(product, sdkCore.MaxUint256);
+  var product = JSBI.multiply(x, y)
+  return JSBI.bitwiseAnd(product, sdkCore.MaxUint256)
 }
 function addIn256(x, y) {
-  var sum = JSBI.add(x, y);
-  return JSBI.bitwiseAnd(sum, sdkCore.MaxUint256);
+  var sum = JSBI.add(x, y)
+  return JSBI.bitwiseAnd(sum, sdkCore.MaxUint256)
 }
-var SqrtPriceMath = /*#__PURE__*/function () {
+var SqrtPriceMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function SqrtPriceMath() {}
   SqrtPriceMath.getAmount0Delta = function getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
     if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-      var _ref = [sqrtRatioBX96, sqrtRatioAX96];
-      sqrtRatioAX96 = _ref[0];
-      sqrtRatioBX96 = _ref[1];
-    }
-    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
-    var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96);
-    return roundUp ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96) : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96);
-  };
+      var _ref = [sqrtRatioBX96, sqrtRatioAX96]
+      sqrtRatioAX96 = _ref[0]
+      sqrtRatioBX96 = _ref[1]
+    }
+    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96))
+    var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)
+    return roundUp
+      ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96)
+      : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96)
+  }
   SqrtPriceMath.getAmount1Delta = function getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
     if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-      var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
-      sqrtRatioAX96 = _ref2[0];
-      sqrtRatioBX96 = _ref2[1];
-    }
-    return roundUp ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96) : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96);
-  };
-  SqrtPriceMath.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne) {
-    !JSBI.greaterThan(sqrtPX96, ZERO) ?  invariant(false)  : void 0;
-    !JSBI.greaterThan(liquidity, ZERO) ?  invariant(false)  : void 0;
-    return zeroForOne ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true) : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
-  };
-  SqrtPriceMath.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne) {
-    !JSBI.greaterThan(sqrtPX96, ZERO) ?  invariant(false)  : void 0;
-    !JSBI.greaterThan(liquidity, ZERO) ?  invariant(false)  : void 0;
-    return zeroForOne ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false) : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
-  };
-  SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amount, add) {
-    if (JSBI.equal(amount, ZERO)) return sqrtPX96;
-    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
+      var _ref2 = [sqrtRatioBX96, sqrtRatioAX96]
+      sqrtRatioAX96 = _ref2[0]
+      sqrtRatioBX96 = _ref2[1]
+    }
+    return roundUp
+      ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96)
+      : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96)
+  }
+  SqrtPriceMath.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(
+    sqrtPX96,
+    liquidity,
+    amountIn,
+    zeroForOne,
+  ) {
+    !JSBI.greaterThan(sqrtPX96, ZERO) ? invariant(false) : void 0
+    !JSBI.greaterThan(liquidity, ZERO) ? invariant(false) : void 0
+    return zeroForOne
+      ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
+      : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true)
+  }
+  SqrtPriceMath.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(
+    sqrtPX96,
+    liquidity,
+    amountOut,
+    zeroForOne,
+  ) {
+    !JSBI.greaterThan(sqrtPX96, ZERO) ? invariant(false) : void 0
+    !JSBI.greaterThan(liquidity, ZERO) ? invariant(false) : void 0
+    return zeroForOne
+      ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
+      : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false)
+  }
+  SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(
+    sqrtPX96,
+    liquidity,
+    amount,
+    add,
+  ) {
+    if (JSBI.equal(amount, ZERO)) return sqrtPX96
+    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96))
     if (add) {
-      var product = multiplyIn256(amount, sqrtPX96);
+      var product = multiplyIn256(amount, sqrtPX96)
       if (JSBI.equal(JSBI.divide(product, amount), sqrtPX96)) {
-        var denominator = addIn256(numerator1, product);
+        var denominator = addIn256(numerator1, product)
         if (JSBI.greaterThanOrEqual(denominator, numerator1)) {
-          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator);
+          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator)
         }
       }
-      return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount));
+      return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount))
     } else {
-      var _product = multiplyIn256(amount, sqrtPX96);
-      !JSBI.equal(JSBI.divide(_product, amount), sqrtPX96) ?  invariant(false)  : void 0;
-      !JSBI.greaterThan(numerator1, _product) ?  invariant(false)  : void 0;
-      var _denominator = JSBI.subtract(numerator1, _product);
-      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator);
-    }
-  };
-  SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amount, add) {
+      var _product = multiplyIn256(amount, sqrtPX96)
+      !JSBI.equal(JSBI.divide(_product, amount), sqrtPX96) ? invariant(false) : void 0
+      !JSBI.greaterThan(numerator1, _product) ? invariant(false) : void 0
+      var _denominator = JSBI.subtract(numerator1, _product)
+      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator)
+    }
+  }
+  SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(
+    sqrtPX96,
+    liquidity,
+    amount,
+    add,
+  ) {
     if (add) {
-      var quotient = JSBI.lessThanOrEqual(amount, MaxUint160) ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity) : JSBI.divide(JSBI.multiply(amount, Q96), liquidity);
-      return JSBI.add(sqrtPX96, quotient);
+      var quotient = JSBI.lessThanOrEqual(amount, MaxUint160)
+        ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity)
+        : JSBI.divide(JSBI.multiply(amount, Q96), liquidity)
+      return JSBI.add(sqrtPX96, quotient)
     } else {
-      var _quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity);
-      !JSBI.greaterThan(sqrtPX96, _quotient) ?  invariant(false)  : void 0;
-      return JSBI.subtract(sqrtPX96, _quotient);
+      var _quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity)
+      !JSBI.greaterThan(sqrtPX96, _quotient) ? invariant(false) : void 0
+      return JSBI.subtract(sqrtPX96, _quotient)
     }
-  };
-  return SqrtPriceMath;
-}();
+  }
+  return SqrtPriceMath
+})()
 
-var MAX_FEE = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(10), /*#__PURE__*/JSBI.BigInt(6));
-var SwapMath = /*#__PURE__*/function () {
+var MAX_FEE = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(10), /*#__PURE__*/ JSBI.BigInt(6))
+var SwapMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function SwapMath() {}
-  SwapMath.computeSwapStep = function computeSwapStep(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, amountRemaining, feePips) {
-    var returnValues = {};
-    feePips = JSBI.BigInt(feePips);
-    var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96);
-    var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO);
+  SwapMath.computeSwapStep = function computeSwapStep(
+    sqrtRatioCurrentX96,
+    sqrtRatioTargetX96,
+    liquidity,
+    amountRemaining,
+    feePips,
+  ) {
+    var returnValues = {}
+    feePips = JSBI.BigInt(feePips)
+    var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96)
+    var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO)
     if (exactIn) {
-      var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, feePips)), MAX_FEE);
-      returnValues.amountIn = zeroForOne ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true) : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
+      var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, feePips)), MAX_FEE)
+      returnValues.amountIn = zeroForOne
+        ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
+        : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true)
       if (JSBI.greaterThanOrEqual(amountRemainingLessFee, returnValues.amountIn)) {
-        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
+        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96
       } else {
-        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne);
+        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
+          sqrtRatioCurrentX96,
+          liquidity,
+          amountRemainingLessFee,
+          zeroForOne,
+        )
       }
     } else {
-      returnValues.amountOut = zeroForOne ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false) : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
+      returnValues.amountOut = zeroForOne
+        ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
+        : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false)
       if (JSBI.greaterThanOrEqual(JSBI.multiply(amountRemaining, NEGATIVE_ONE), returnValues.amountOut)) {
-        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
+        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96
       } else {
-        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtRatioCurrentX96, liquidity, JSBI.multiply(amountRemaining, NEGATIVE_ONE), zeroForOne);
+        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
+          sqrtRatioCurrentX96,
+          liquidity,
+          JSBI.multiply(amountRemaining, NEGATIVE_ONE),
+          zeroForOne,
+        )
       }
     }
-    var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96);
+    var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96)
     if (zeroForOne) {
-      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
-      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
+      returnValues.amountIn =
+        max && exactIn
+          ? returnValues.amountIn
+          : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true)
+      returnValues.amountOut =
+        max && !exactIn
+          ? returnValues.amountOut
+          : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false)
     } else {
-      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true);
-      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false);
+      returnValues.amountIn =
+        max && exactIn
+          ? returnValues.amountIn
+          : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true)
+      returnValues.amountOut =
+        max && !exactIn
+          ? returnValues.amountOut
+          : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false)
     }
     if (!exactIn && JSBI.greaterThan(returnValues.amountOut, JSBI.multiply(amountRemaining, NEGATIVE_ONE))) {
-      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE);
+      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE)
     }
     if (exactIn && JSBI.notEqual(returnValues.sqrtRatioNextX96, sqrtRatioTargetX96)) {
       // we didn't reach the target, so take the remainder of the maximum input as fee
-      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn);
+      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn)
     } else {
-      returnValues.feeAmount = FullMath.mulDivRoundingUp(returnValues.amountIn, feePips, JSBI.subtract(MAX_FEE, feePips));
+      returnValues.feeAmount = FullMath.mulDivRoundingUp(
+        returnValues.amountIn,
+        feePips,
+        JSBI.subtract(MAX_FEE, feePips),
+      )
     }
-    return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount];
-  };
-  return SwapMath;
-}();
+    return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount]
+  }
+  return SwapMath
+})()
 
-var LiquidityMath = /*#__PURE__*/function () {
+var LiquidityMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function LiquidityMath() {}
   LiquidityMath.addDelta = function addDelta(x, y) {
     if (JSBI.lessThan(y, ZERO)) {
-      return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE));
+      return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE))
     } else {
-      return JSBI.add(x, y);
+      return JSBI.add(x, y)
     }
-  };
-  return LiquidityMath;
-}();
+  }
+  return LiquidityMath
+})()
 
-var TWO = /*#__PURE__*/JSBI.BigInt(2);
-var POWERS_OF_2 = /*#__PURE__*/[128, 64, 32, 16, 8, 4, 2, 1].map(function (pow) {
-  return [pow, JSBI.exponentiate(TWO, JSBI.BigInt(pow))];
-});
+var TWO = /*#__PURE__*/ JSBI.BigInt(2)
+var POWERS_OF_2 = /*#__PURE__*/ [128, 64, 32, 16, 8, 4, 2, 1].map(function (pow) {
+  return [pow, JSBI.exponentiate(TWO, JSBI.BigInt(pow))]
+})
 function mostSignificantBit(x) {
-  !JSBI.greaterThan(x, ZERO) ?  invariant(false, 'ZERO')  : void 0;
-  !JSBI.lessThanOrEqual(x, sdkCore.MaxUint256) ?  invariant(false, 'MAX')  : void 0;
-  var msb = 0;
-  for (var _iterator = _createForOfIteratorHelperLoose(POWERS_OF_2), _step; !(_step = _iterator()).done;) {
+  !JSBI.greaterThan(x, ZERO) ? invariant(false, 'ZERO') : void 0
+  !JSBI.lessThanOrEqual(x, sdkCore.MaxUint256) ? invariant(false, 'MAX') : void 0
+  var msb = 0
+  for (var _iterator = _createForOfIteratorHelperLoose(POWERS_OF_2), _step; !(_step = _iterator()).done; ) {
     var _step$value = _step.value,
       power = _step$value[0],
-      min = _step$value[1];
+      min = _step$value[1]
     if (JSBI.greaterThanOrEqual(x, min)) {
-      x = JSBI.signedRightShift(x, JSBI.BigInt(power));
-      msb += power;
+      x = JSBI.signedRightShift(x, JSBI.BigInt(power))
+      msb += power
     }
   }
-  return msb;
+  return msb
 }
 
 function mulShift(val, mulBy) {
-  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128));
+  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128))
 }
-var Q32 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(32));
-var TickMath = /*#__PURE__*/function () {
+var Q32 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(32))
+var TickMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
@@ -693,226 +896,293 @@ var TickMath = /*#__PURE__*/function () {
    * @param tick the tick for which to compute the sqrt ratio
    */
   TickMath.getSqrtRatioAtTick = function getSqrtRatioAtTick(tick) {
-    !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick)) ?  invariant(false, 'TICK')  : void 0;
-    var absTick = tick < 0 ? tick * -1 : tick;
-    var ratio = (absTick & 0x1) !== 0 ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001') : JSBI.BigInt('0x100000000000000000000000000000000');
-    if ((absTick & 0x2) !== 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a');
-    if ((absTick & 0x4) !== 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc');
-    if ((absTick & 0x8) !== 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0');
-    if ((absTick & 0x10) !== 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644');
-    if ((absTick & 0x20) !== 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0');
-    if ((absTick & 0x40) !== 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861');
-    if ((absTick & 0x80) !== 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053');
-    if ((absTick & 0x100) !== 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4');
-    if ((absTick & 0x200) !== 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54');
-    if ((absTick & 0x400) !== 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3');
-    if ((absTick & 0x800) !== 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9');
-    if ((absTick & 0x1000) !== 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825');
-    if ((absTick & 0x2000) !== 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5');
-    if ((absTick & 0x4000) !== 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7');
-    if ((absTick & 0x8000) !== 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6');
-    if ((absTick & 0x10000) !== 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9');
-    if ((absTick & 0x20000) !== 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604');
-    if ((absTick & 0x40000) !== 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98');
-    if ((absTick & 0x80000) !== 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2');
-    if (tick > 0) ratio = JSBI.divide(sdkCore.MaxUint256, ratio);
+    !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick))
+      ? invariant(false, 'TICK')
+      : void 0
+    var absTick = tick < 0 ? tick * -1 : tick
+    var ratio =
+      (absTick & 0x1) !== 0
+        ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001')
+        : JSBI.BigInt('0x100000000000000000000000000000000')
+    if ((absTick & 0x2) !== 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a')
+    if ((absTick & 0x4) !== 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc')
+    if ((absTick & 0x8) !== 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0')
+    if ((absTick & 0x10) !== 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644')
+    if ((absTick & 0x20) !== 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0')
+    if ((absTick & 0x40) !== 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861')
+    if ((absTick & 0x80) !== 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053')
+    if ((absTick & 0x100) !== 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4')
+    if ((absTick & 0x200) !== 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54')
+    if ((absTick & 0x400) !== 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3')
+    if ((absTick & 0x800) !== 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9')
+    if ((absTick & 0x1000) !== 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825')
+    if ((absTick & 0x2000) !== 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5')
+    if ((absTick & 0x4000) !== 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7')
+    if ((absTick & 0x8000) !== 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6')
+    if ((absTick & 0x10000) !== 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9')
+    if ((absTick & 0x20000) !== 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604')
+    if ((absTick & 0x40000) !== 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98')
+    if ((absTick & 0x80000) !== 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2')
+    if (tick > 0) ratio = JSBI.divide(sdkCore.MaxUint256, ratio)
     // back to Q96
-    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO) ? JSBI.add(JSBI.divide(ratio, Q32), ONE) : JSBI.divide(ratio, Q32);
+    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO)
+      ? JSBI.add(JSBI.divide(ratio, Q32), ONE)
+      : JSBI.divide(ratio, Q32)
   }
   /**
    * Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96
    * and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96
    * @param sqrtRatioX96 the sqrt ratio as a Q64.96 for which to compute the tick
-   */;
+   */
   TickMath.getTickAtSqrtRatio = function getTickAtSqrtRatio(sqrtRatioX96) {
-    !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) ?  invariant(false, 'SQRT_RATIO')  : void 0;
-    var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32));
-    var msb = mostSignificantBit(sqrtRatioX128);
-    var r;
+    !(
+      JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&
+      JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)
+    )
+      ? invariant(false, 'SQRT_RATIO')
+      : void 0
+    var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32))
+    var msb = mostSignificantBit(sqrtRatioX128)
+    var r
     if (JSBI.greaterThanOrEqual(JSBI.BigInt(msb), JSBI.BigInt(128))) {
-      r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127));
+      r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127))
     } else {
-      r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb));
+      r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb))
     }
-    var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64));
+    var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64))
     for (var i = 0; i < 14; i++) {
-      r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127));
-      var f = JSBI.signedRightShift(r, JSBI.BigInt(128));
-      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)));
-      r = JSBI.signedRightShift(r, f);
-    }
-    var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'));
-    var tickLow = JSBI.toNumber(JSBI.signedRightShift(JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')), JSBI.BigInt(128)));
-    var tickHigh = JSBI.toNumber(JSBI.signedRightShift(JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')), JSBI.BigInt(128)));
-    return tickLow === tickHigh ? tickLow : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96) ? tickHigh : tickLow;
-  };
-  return TickMath;
-}();
+      r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127))
+      var f = JSBI.signedRightShift(r, JSBI.BigInt(128))
+      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)))
+      r = JSBI.signedRightShift(r, f)
+    }
+    var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'))
+    var tickLow = JSBI.toNumber(
+      JSBI.signedRightShift(
+        JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')),
+        JSBI.BigInt(128),
+      ),
+    )
+    var tickHigh = JSBI.toNumber(
+      JSBI.signedRightShift(
+        JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')),
+        JSBI.BigInt(128),
+      ),
+    )
+    return tickLow === tickHigh
+      ? tickLow
+      : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96)
+        ? tickHigh
+        : tickLow
+  }
+  return TickMath
+})()
 /**
  * The minimum tick that can be used on any pool.
  */
-TickMath.MIN_TICK = -887272;
+TickMath.MIN_TICK = -887272
 /**
  * The maximum tick that can be used on any pool.
  */
-TickMath.MAX_TICK = -TickMath.MIN_TICK;
+TickMath.MAX_TICK = -TickMath.MIN_TICK
 /**
  * The sqrt ratio corresponding to the minimum tick that could be used on any pool.
  */
-TickMath.MIN_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('4295128739');
+TickMath.MIN_SQRT_RATIO = /*#__PURE__*/ JSBI.BigInt('4295128739')
 /**
  * The sqrt ratio corresponding to the maximum tick that could be used on any pool.
  */
-TickMath.MAX_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('1461446703485210103287273052203988822378723970342');
+TickMath.MAX_SQRT_RATIO = /*#__PURE__*/ JSBI.BigInt('1461446703485210103287273052203988822378723970342')
 
 function v3Swap(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {
-  return _v3Swap.apply(this, arguments);
+  return _v3Swap.apply(this, arguments)
 }
 function _v3Swap() {
-  _v3Swap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fee, sqrtRatioX96, tickCurrent, liquidity, tickSpacing, tickDataProvider, zeroForOne, amountSpecified, sqrtPriceLimitX96) {
-    var exactInput, state, step, _yield$tickDataProvid, _SwapMath$computeSwap, liquidityNet;
-    return _regeneratorRuntime().wrap(function _callee$(_context) {
-      while (1) switch (_context.prev = _context.next) {
-        case 0:
-          if (!sqrtPriceLimitX96) sqrtPriceLimitX96 = zeroForOne ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE) : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE);
-          if (zeroForOne) {
-            !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO) ?  invariant(false, 'RATIO_MIN')  : void 0;
-            !JSBI.lessThan(sqrtPriceLimitX96, sqrtRatioX96) ?  invariant(false, 'RATIO_CURRENT')  : void 0;
-          } else {
-            !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO) ?  invariant(false, 'RATIO_MAX')  : void 0;
-            !JSBI.greaterThan(sqrtPriceLimitX96, sqrtRatioX96) ?  invariant(false, 'RATIO_CURRENT')  : void 0;
-          }
-          exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO); // keep track of swap state
-          state = {
-            amountSpecifiedRemaining: amountSpecified,
-            amountCalculated: ZERO,
-            sqrtPriceX96: sqrtRatioX96,
-            tick: tickCurrent,
-            liquidity: liquidity
-          }; // start swap while loop
-        case 4:
-          if (!(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 !== sqrtPriceLimitX96)) {
-            _context.next = 35;
-            break;
-          }
-          step = {};
-          step.sqrtPriceStartX96 = state.sqrtPriceX96;
-          _context.next = 9;
-          return tickDataProvider.nextInitializedTickWithinOneWord(state.tick, zeroForOne, tickSpacing);
-        case 9:
-          _yield$tickDataProvid = _context.sent;
-          step.tickNext = _yield$tickDataProvid[0];
-          step.initialized = _yield$tickDataProvid[1];
-          if (step.tickNext < TickMath.MIN_TICK) {
-            step.tickNext = TickMath.MIN_TICK;
-          } else if (step.tickNext > TickMath.MAX_TICK) {
-            step.tickNext = TickMath.MAX_TICK;
-          }
-          step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
-          _SwapMath$computeSwap = SwapMath.computeSwapStep(state.sqrtPriceX96, (zeroForOne ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96) : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state.liquidity, state.amountSpecifiedRemaining, fee);
-          state.sqrtPriceX96 = _SwapMath$computeSwap[0];
-          step.amountIn = _SwapMath$computeSwap[1];
-          step.amountOut = _SwapMath$computeSwap[2];
-          step.feeAmount = _SwapMath$computeSwap[3];
-          if (exactInput) {
-            state.amountSpecifiedRemaining = JSBI.subtract(state.amountSpecifiedRemaining, JSBI.add(step.amountIn, step.feeAmount));
-            state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut);
-          } else {
-            state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut);
-            state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount));
-          }
-          // TODO
-          if (!JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {
-            _context.next = 32;
-            break;
-          }
-          if (!step.initialized) {
-            _context.next = 29;
-            break;
-          }
-          _context.t0 = JSBI;
-          _context.next = 25;
-          return tickDataProvider.getTick(step.tickNext);
-        case 25:
-          _context.t1 = _context.sent.liquidityNet;
-          liquidityNet = _context.t0.BigInt.call(_context.t0, _context.t1);
-          // if we're moving leftward, we interpret liquidityNet as the opposite sign
-          // safe because liquidityNet cannot be type(int128).min
-          if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE);
-          state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
-        case 29:
-          state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
-          _context.next = 33;
-          break;
-        case 32:
-          if (JSBI.notEqual(state.sqrtPriceX96, step.sqrtPriceStartX96)) {
-            // updated comparison function
-            // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
-            state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
-          }
-        case 33:
-          _context.next = 4;
-          break;
-        case 35:
-          return _context.abrupt("return", {
-            amountCalculated: state.amountCalculated,
-            sqrtRatioX96: state.sqrtPriceX96,
-            liquidity: state.liquidity,
-            tickCurrent: state.tick
-          });
-        case 36:
-        case "end":
-          return _context.stop();
-      }
-    }, _callee);
-  }));
-  return _v3Swap.apply(this, arguments);
+  _v3Swap = _asyncToGenerator(
+    /*#__PURE__*/ _regeneratorRuntime().mark(
+      function _callee(
+        fee,
+        sqrtRatioX96,
+        tickCurrent,
+        liquidity,
+        tickSpacing,
+        tickDataProvider,
+        zeroForOne,
+        amountSpecified,
+        sqrtPriceLimitX96,
+      ) {
+        var exactInput, state, step, _yield$tickDataProvid, _SwapMath$computeSwap, liquidityNet
+        return _regeneratorRuntime().wrap(function _callee$(_context) {
+          while (1)
+            switch ((_context.prev = _context.next)) {
+              case 0:
+                if (!sqrtPriceLimitX96)
+                  sqrtPriceLimitX96 = zeroForOne
+                    ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE)
+                    : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE)
+                if (zeroForOne) {
+                  !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO) ? invariant(false, 'RATIO_MIN') : void 0
+                  !JSBI.lessThan(sqrtPriceLimitX96, sqrtRatioX96) ? invariant(false, 'RATIO_CURRENT') : void 0
+                } else {
+                  !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO) ? invariant(false, 'RATIO_MAX') : void 0
+                  !JSBI.greaterThan(sqrtPriceLimitX96, sqrtRatioX96) ? invariant(false, 'RATIO_CURRENT') : void 0
+                }
+                exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO) // keep track of swap state
+                state = {
+                  amountSpecifiedRemaining: amountSpecified,
+                  amountCalculated: ZERO,
+                  sqrtPriceX96: sqrtRatioX96,
+                  tick: tickCurrent,
+                  liquidity: liquidity,
+                } // start swap while loop
+              case 4:
+                if (
+                  !(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 !== sqrtPriceLimitX96)
+                ) {
+                  _context.next = 35
+                  break
+                }
+                step = {}
+                step.sqrtPriceStartX96 = state.sqrtPriceX96
+                _context.next = 9
+                return tickDataProvider.nextInitializedTickWithinOneWord(state.tick, zeroForOne, tickSpacing)
+              case 9:
+                _yield$tickDataProvid = _context.sent
+                step.tickNext = _yield$tickDataProvid[0]
+                step.initialized = _yield$tickDataProvid[1]
+                if (step.tickNext < TickMath.MIN_TICK) {
+                  step.tickNext = TickMath.MIN_TICK
+                } else if (step.tickNext > TickMath.MAX_TICK) {
+                  step.tickNext = TickMath.MAX_TICK
+                }
+                step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext)
+                _SwapMath$computeSwap = SwapMath.computeSwapStep(
+                  state.sqrtPriceX96,
+                  (
+                    zeroForOne
+                      ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)
+                      : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)
+                  )
+                    ? sqrtPriceLimitX96
+                    : step.sqrtPriceNextX96,
+                  state.liquidity,
+                  state.amountSpecifiedRemaining,
+                  fee,
+                )
+                state.sqrtPriceX96 = _SwapMath$computeSwap[0]
+                step.amountIn = _SwapMath$computeSwap[1]
+                step.amountOut = _SwapMath$computeSwap[2]
+                step.feeAmount = _SwapMath$computeSwap[3]
+                if (exactInput) {
+                  state.amountSpecifiedRemaining = JSBI.subtract(
+                    state.amountSpecifiedRemaining,
+                    JSBI.add(step.amountIn, step.feeAmount),
+                  )
+                  state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut)
+                } else {
+                  state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut)
+                  state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount))
+                }
+                // TODO
+                if (!JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {
+                  _context.next = 32
+                  break
+                }
+                if (!step.initialized) {
+                  _context.next = 29
+                  break
+                }
+                _context.t0 = JSBI
+                _context.next = 25
+                return tickDataProvider.getTick(step.tickNext)
+              case 25:
+                _context.t1 = _context.sent.liquidityNet
+                liquidityNet = _context.t0.BigInt.call(_context.t0, _context.t1)
+                // if we're moving leftward, we interpret liquidityNet as the opposite sign
+                // safe because liquidityNet cannot be type(int128).min
+                if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE)
+                state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet)
+              case 29:
+                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext
+                _context.next = 33
+                break
+              case 32:
+                if (JSBI.notEqual(state.sqrtPriceX96, step.sqrtPriceStartX96)) {
+                  // updated comparison function
+                  // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
+                  state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96)
+                }
+              case 33:
+                _context.next = 4
+                break
+              case 35:
+                return _context.abrupt('return', {
+                  amountCalculated: state.amountCalculated,
+                  sqrtRatioX96: state.sqrtPriceX96,
+                  liquidity: state.liquidity,
+                  tickCurrent: state.tick,
+                })
+              case 36:
+              case 'end':
+                return _context.stop()
+            }
+        }, _callee)
+      },
+    ),
+  )
+  return _v3Swap.apply(this, arguments)
 }
 
 /**
  * This tick data provider does not know how to fetch any tick data. It throws whenever it is required. Useful if you
  * do not need to load tick data for your use case.
  */
-var NoTickDataProvider = /*#__PURE__*/function () {
+var NoTickDataProvider = /*#__PURE__*/ (function () {
   function NoTickDataProvider() {}
-  var _proto = NoTickDataProvider.prototype;
-  _proto.getTick = /*#__PURE__*/function () {
-    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_tick) {
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
-          case 1:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee);
-    }));
+  var _proto = NoTickDataProvider.prototype
+  _proto.getTick = /*#__PURE__*/ (function () {
+    var _getTick = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(_tick) {
+        return _regeneratorRuntime().wrap(function _callee$(_context) {
+          while (1)
+            switch ((_context.prev = _context.next)) {
+              case 0:
+                throw new Error(NoTickDataProvider.ERROR_MESSAGE)
+              case 1:
+              case 'end':
+                return _context.stop()
+            }
+        }, _callee)
+      }),
+    )
     function getTick(_x) {
-      return _getTick.apply(this, arguments);
-    }
-    return getTick;
-  }();
-  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
-    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_tick, _lte, _tickSpacing) {
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2);
-    }));
+      return _getTick.apply(this, arguments)
+    }
+    return getTick
+  })()
+  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/ (function () {
+    var _nextInitializedTickWithinOneWord = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(_tick, _lte, _tickSpacing) {
+        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+          while (1)
+            switch ((_context2.prev = _context2.next)) {
+              case 0:
+                throw new Error(NoTickDataProvider.ERROR_MESSAGE)
+              case 1:
+              case 'end':
+                return _context2.stop()
+            }
+        }, _callee2)
+      }),
+    )
     function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
-      return _nextInitializedTickWithinOneWord.apply(this, arguments);
+      return _nextInitializedTickWithinOneWord.apply(this, arguments)
     }
-    return nextInitializedTickWithinOneWord;
-  }();
-  return NoTickDataProvider;
-}();
-NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';
+    return nextInitializedTickWithinOneWord
+  })()
+  return NoTickDataProvider
+})()
+NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given'
 
 /**
  * Determines if a tick list is sorted
@@ -923,114 +1193,121 @@ NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';
 function isSorted(list, comparator) {
   for (var i = 0; i < list.length - 1; i++) {
     if (comparator(list[i], list[i + 1]) > 0) {
-      return false;
+      return false
     }
   }
-  return true;
+  return true
 }
 
 function tickComparator(a, b) {
-  return a.index - b.index;
+  return a.index - b.index
 }
 /**
  * Utility methods for interacting with sorted lists of ticks
  */
-var TickList = /*#__PURE__*/function () {
+var TickList = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed
    */
   function TickList() {}
   TickList.validateList = function validateList(ticks, tickSpacing) {
-    !(tickSpacing > 0) ?  invariant(false, 'TICK_SPACING_NONZERO')  : void 0;
+    !(tickSpacing > 0) ? invariant(false, 'TICK_SPACING_NONZERO') : void 0
     // ensure ticks are spaced appropriately
     !ticks.every(function (_ref) {
-      var index = _ref.index;
-      return index % tickSpacing === 0;
-    }) ?  invariant(false, 'TICK_SPACING')  : void 0;
+      var index = _ref.index
+      return index % tickSpacing === 0
+    })
+      ? invariant(false, 'TICK_SPACING')
+      : void 0
     // ensure tick liquidity deltas sum to 0
-    !JSBI.equal(ticks.reduce(function (accumulator, _ref2) {
-      var liquidityNet = _ref2.liquidityNet;
-      return JSBI.add(accumulator, liquidityNet);
-    }, ZERO), ZERO) ?  invariant(false, 'ZERO_NET')  : void 0;
-    !isSorted(ticks, tickComparator) ?  invariant(false, 'SORTED')  : void 0;
-  };
+    !JSBI.equal(
+      ticks.reduce(function (accumulator, _ref2) {
+        var liquidityNet = _ref2.liquidityNet
+        return JSBI.add(accumulator, liquidityNet)
+      }, ZERO),
+      ZERO,
+    )
+      ? invariant(false, 'ZERO_NET')
+      : void 0
+    !isSorted(ticks, tickComparator) ? invariant(false, 'SORTED') : void 0
+  }
   TickList.isBelowSmallest = function isBelowSmallest(ticks, tick) {
-    !(ticks.length > 0) ?  invariant(false, 'LENGTH')  : void 0;
-    return tick < ticks[0].index;
-  };
+    !(ticks.length > 0) ? invariant(false, 'LENGTH') : void 0
+    return tick < ticks[0].index
+  }
   TickList.isAtOrAboveLargest = function isAtOrAboveLargest(ticks, tick) {
-    !(ticks.length > 0) ?  invariant(false, 'LENGTH')  : void 0;
-    return tick >= ticks[ticks.length - 1].index;
-  };
+    !(ticks.length > 0) ? invariant(false, 'LENGTH') : void 0
+    return tick >= ticks[ticks.length - 1].index
+  }
   TickList.getTick = function getTick(ticks, index) {
-    var tick = ticks[this.binarySearch(ticks, index)];
-    !(tick.index === index) ?  invariant(false, 'NOT_CONTAINED')  : void 0;
-    return tick;
+    var tick = ticks[this.binarySearch(ticks, index)]
+    !(tick.index === index) ? invariant(false, 'NOT_CONTAINED') : void 0
+    return tick
   }
   /**
    * Finds the largest tick in the list of ticks that is less than or equal to tick
    * @param ticks list of ticks
    * @param tick tick to find the largest tick that is less than or equal to tick
    * @private
-   */;
+   */
   TickList.binarySearch = function binarySearch(ticks, tick) {
-    !!this.isBelowSmallest(ticks, tick) ?  invariant(false, 'BELOW_SMALLEST')  : void 0;
-    var l = 0;
-    var r = ticks.length - 1;
-    var i;
+    !!this.isBelowSmallest(ticks, tick) ? invariant(false, 'BELOW_SMALLEST') : void 0
+    var l = 0
+    var r = ticks.length - 1
+    var i
     while (true) {
-      i = Math.floor((l + r) / 2);
+      i = Math.floor((l + r) / 2)
       if (ticks[i].index <= tick && (i === ticks.length - 1 || ticks[i + 1].index > tick)) {
-        return i;
+        return i
       }
       if (ticks[i].index < tick) {
-        l = i + 1;
+        l = i + 1
       } else {
-        r = i - 1;
+        r = i - 1
       }
     }
-  };
+  }
   TickList.nextInitializedTick = function nextInitializedTick(ticks, tick, lte) {
     if (lte) {
-      !!TickList.isBelowSmallest(ticks, tick) ?  invariant(false, 'BELOW_SMALLEST')  : void 0;
+      !!TickList.isBelowSmallest(ticks, tick) ? invariant(false, 'BELOW_SMALLEST') : void 0
       if (TickList.isAtOrAboveLargest(ticks, tick)) {
-        return ticks[ticks.length - 1];
+        return ticks[ticks.length - 1]
       }
-      var index = this.binarySearch(ticks, tick);
-      return ticks[index];
+      var index = this.binarySearch(ticks, tick)
+      return ticks[index]
     } else {
-      !!this.isAtOrAboveLargest(ticks, tick) ?  invariant(false, 'AT_OR_ABOVE_LARGEST')  : void 0;
+      !!this.isAtOrAboveLargest(ticks, tick) ? invariant(false, 'AT_OR_ABOVE_LARGEST') : void 0
       if (this.isBelowSmallest(ticks, tick)) {
-        return ticks[0];
+        return ticks[0]
       }
-      var _index = this.binarySearch(ticks, tick);
-      return ticks[_index + 1];
+      var _index = this.binarySearch(ticks, tick)
+      return ticks[_index + 1]
     }
-  };
+  }
   TickList.nextInitializedTickWithinOneWord = function nextInitializedTickWithinOneWord(ticks, tick, lte, tickSpacing) {
-    var compressed = Math.floor(tick / tickSpacing); // matches rounding in the code
+    var compressed = Math.floor(tick / tickSpacing) // matches rounding in the code
     if (lte) {
-      var wordPos = compressed >> 8;
-      var minimum = (wordPos << 8) * tickSpacing;
+      var wordPos = compressed >> 8
+      var minimum = (wordPos << 8) * tickSpacing
       if (TickList.isBelowSmallest(ticks, tick)) {
-        return [minimum, false];
+        return [minimum, false]
       }
-      var index = TickList.nextInitializedTick(ticks, tick, lte).index;
-      var nextInitializedTick = Math.max(minimum, index);
-      return [nextInitializedTick, nextInitializedTick === index];
+      var index = TickList.nextInitializedTick(ticks, tick, lte).index
+      var nextInitializedTick = Math.max(minimum, index)
+      return [nextInitializedTick, nextInitializedTick === index]
     } else {
-      var _wordPos = compressed + 1 >> 8;
-      var maximum = ((_wordPos + 1 << 8) - 1) * tickSpacing;
+      var _wordPos = (compressed + 1) >> 8
+      var maximum = (((_wordPos + 1) << 8) - 1) * tickSpacing
       if (this.isAtOrAboveLargest(ticks, tick)) {
-        return [maximum, false];
+        return [maximum, false]
       }
-      var _index2 = this.nextInitializedTick(ticks, tick, lte).index;
-      var _nextInitializedTick = Math.min(maximum, _index2);
-      return [_nextInitializedTick, _nextInitializedTick === _index2];
+      var _index2 = this.nextInitializedTick(ticks, tick, lte).index
+      var _nextInitializedTick = Math.min(maximum, _index2)
+      return [_nextInitializedTick, _nextInitializedTick === _index2]
     }
-  };
-  return TickList;
-}();
+  }
+  return TickList
+})()
 
 /**
  * Converts a big int to a hex string
@@ -1038,12 +1315,12 @@ var TickList = /*#__PURE__*/function () {
  * @returns The hex encoded calldata
  */
 function toHex(bigintIsh) {
-  var bigInt = JSBI.BigInt(bigintIsh);
-  var hex = bigInt.toString(16);
+  var bigInt = JSBI.BigInt(bigintIsh)
+  var hex = bigInt.toString(16)
   if (hex.length % 2 !== 0) {
-    hex = "0" + hex;
+    hex = '0' + hex
   }
-  return "0x" + hex;
+  return '0x' + hex
 }
 
 /**
@@ -1052,33 +1329,36 @@ function toHex(bigintIsh) {
  * @param exactOutput whether the route should be encoded in reverse, for making exact output swaps
  */
 function encodeRouteToPath(route, exactOutput) {
-  var firstInputToken = route.input.wrapped;
-  var _route$pools$reduce = route.pools.reduce(function (_ref, pool, index) {
-      var inputToken = _ref.inputToken,
-        path = _ref.path,
-        types = _ref.types;
-      var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;
-      if (index === 0) {
-        return {
-          inputToken: outputToken,
-          types: ['address', 'uint24', 'address'],
-          path: [inputToken.address, pool.fee, outputToken.address]
-        };
-      } else {
-        return {
-          inputToken: outputToken,
-          types: [].concat(types, ['uint24', 'address']),
-          path: [].concat(path, [pool.fee, outputToken.address])
-        };
-      }
-    }, {
-      inputToken: firstInputToken,
-      path: [],
-      types: []
-    }),
+  var firstInputToken = route.input.wrapped
+  var _route$pools$reduce = route.pools.reduce(
+      function (_ref, pool, index) {
+        var inputToken = _ref.inputToken,
+          path = _ref.path,
+          types = _ref.types
+        var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0
+        if (index === 0) {
+          return {
+            inputToken: outputToken,
+            types: ['address', 'uint24', 'address'],
+            path: [inputToken.address, pool.fee, outputToken.address],
+          }
+        } else {
+          return {
+            inputToken: outputToken,
+            types: [].concat(types, ['uint24', 'address']),
+            path: [].concat(path, [pool.fee, outputToken.address]),
+          }
+        }
+      },
+      {
+        inputToken: firstInputToken,
+        path: [],
+        types: [],
+      },
+    ),
     path = _route$pools$reduce.path,
-    types = _route$pools$reduce.types;
-  return exactOutput ? solidity.pack(types.reverse(), path.reverse()) : solidity.pack(types, path);
+    types = _route$pools$reduce.types
+  return exactOutput ? solidity.pack(types.reverse(), path.reverse()) : solidity.pack(types, path)
 }
 
 /**
@@ -1088,10 +1368,10 @@ function encodeRouteToPath(route, exactOutput) {
  * @returns The sqrt ratio
  */
 function encodeSqrtRatioX96(amount1, amount0) {
-  var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192));
-  var denominator = JSBI.BigInt(amount0);
-  var ratioX192 = JSBI.divide(numerator, denominator);
-  return sdkCore.sqrt(ratioX192);
+  var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192))
+  var denominator = JSBI.BigInt(amount0)
+  var ratioX192 = JSBI.divide(numerator, denominator)
+  return sdkCore.sqrt(ratioX192)
 }
 
 /**
@@ -1107,12 +1387,12 @@ function encodeSqrtRatioX96(amount1, amount0) {
  */
 function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref[0];
-    sqrtRatioBX96 = _ref[1];
+    var _ref = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref[0]
+    sqrtRatioBX96 = _ref[1]
   }
-  var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96);
-  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
+  var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96)
+  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))
 }
 /**
  * Returns a precise maximum amount of liquidity received for a given amount of token 0 by dividing by Q64 instead of Q96 in the intermediate step,
@@ -1124,13 +1404,13 @@ function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0)
  */
 function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref2[0];
-    sqrtRatioBX96 = _ref2[1];
+    var _ref2 = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref2[0]
+    sqrtRatioBX96 = _ref2[1]
   }
-  var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96);
-  var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
-  return JSBI.divide(numerator, denominator);
+  var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96)
+  var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))
+  return JSBI.divide(numerator, denominator)
 }
 /**
  * Computes the maximum amount of liquidity received for a given amount of token1
@@ -1141,11 +1421,11 @@ function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  */
 function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref3 = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref3[0];
-    sqrtRatioBX96 = _ref3[1];
+    var _ref3 = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref3[0]
+    sqrtRatioBX96 = _ref3[1]
   }
-  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
+  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))
 }
 /**
  * Computes the maximum amount of liquidity received for a given amount of token0, token1,
@@ -1160,19 +1440,19 @@ function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
  */
 function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref4 = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref4[0];
-    sqrtRatioBX96 = _ref4[1];
+    var _ref4 = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref4[0]
+    sqrtRatioBX96 = _ref4[1]
   }
-  var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise;
+  var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise
   if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {
-    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
+    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0)
   } else if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {
-    var liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0);
-    var liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1);
-    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1;
+    var liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0)
+    var liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1)
+    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1
   } else {
-    return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
+    return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1)
   }
 }
 
@@ -1182,27 +1462,41 @@ function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX9
  * @param tickSpacing the spacing of the pool
  */
 function nearestUsableTick(tick, tickSpacing) {
-  !(Number.isInteger(tick) && Number.isInteger(tickSpacing)) ?  invariant(false, 'INTEGERS')  : void 0;
-  !(tickSpacing > 0) ?  invariant(false, 'TICK_SPACING')  : void 0;
-  !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK) ?  invariant(false, 'TICK_BOUND')  : void 0;
-  var rounded = Math.round(tick / tickSpacing) * tickSpacing;
-  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;else return rounded;
+  !(Number.isInteger(tick) && Number.isInteger(tickSpacing)) ? invariant(false, 'INTEGERS') : void 0
+  !(tickSpacing > 0) ? invariant(false, 'TICK_SPACING') : void 0
+  !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK) ? invariant(false, 'TICK_BOUND') : void 0
+  var rounded = Math.round(tick / tickSpacing) * tickSpacing
+  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing
+  else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing
+  else return rounded
 }
 
-var Q128 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128));
-var PositionLibrary = /*#__PURE__*/function () {
+var Q128 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(128))
+var PositionLibrary = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function PositionLibrary() {}
   // replicates the portions of Position#update required to compute unaccounted fees
-  PositionLibrary.getTokensOwed = function getTokensOwed(feeGrowthInside0LastX128, feeGrowthInside1LastX128, liquidity, feeGrowthInside0X128, feeGrowthInside1X128) {
-    var tokensOwed0 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity), Q128);
-    var tokensOwed1 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity), Q128);
-    return [tokensOwed0, tokensOwed1];
-  };
-  return PositionLibrary;
-}();
+  PositionLibrary.getTokensOwed = function getTokensOwed(
+    feeGrowthInside0LastX128,
+    feeGrowthInside1LastX128,
+    liquidity,
+    feeGrowthInside0X128,
+    feeGrowthInside1X128,
+  ) {
+    var tokensOwed0 = JSBI.divide(
+      JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity),
+      Q128,
+    )
+    var tokensOwed1 = JSBI.divide(
+      JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity),
+      Q128,
+    )
+    return [tokensOwed0, tokensOwed1]
+  }
+  return PositionLibrary
+})()
 
 /**
  * Returns a price object corresponding to the input tick and the base/quote token
@@ -1212,9 +1506,11 @@ var PositionLibrary = /*#__PURE__*/function () {
  * @param tick the tick for which to return the price
  */
 function tickToPrice(baseToken, quoteToken, tick) {
-  var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
-  var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);
-  return baseToken.sortsBefore(quoteToken) ? new sdkCore.Price(baseToken, quoteToken, Q192, ratioX192) : new sdkCore.Price(baseToken, quoteToken, ratioX192, Q192);
+  var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick)
+  var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96)
+  return baseToken.sortsBefore(quoteToken)
+    ? new sdkCore.Price(baseToken, quoteToken, Q192, ratioX192)
+    : new sdkCore.Price(baseToken, quoteToken, ratioX192, Q192)
 }
 /**
  * Returns the first tick for which the given price is greater than or equal to the tick price
@@ -1222,127 +1518,157 @@ function tickToPrice(baseToken, quoteToken, tick) {
  * i.e. the price of the returned tick is less than or equal to the input price
  */
 function priceToClosestTick(price) {
-  var sorted = price.baseCurrency.sortsBefore(price.quoteCurrency);
-  var sqrtRatioX96 = sorted ? encodeSqrtRatioX96(price.numerator, price.denominator) : encodeSqrtRatioX96(price.denominator, price.numerator);
-  var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);
-  var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);
+  var sorted = price.baseCurrency.sortsBefore(price.quoteCurrency)
+  var sqrtRatioX96 = sorted
+    ? encodeSqrtRatioX96(price.numerator, price.denominator)
+    : encodeSqrtRatioX96(price.denominator, price.numerator)
+  var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96)
+  var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1)
   if (sorted) {
     if (!price.lessThan(nextTickPrice)) {
-      tick++;
+      tick++
     }
   } else {
     if (!price.greaterThan(nextTickPrice)) {
-      tick++;
+      tick++
     }
   }
-  return tick;
+  return tick
 }
 
-var Q256 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(256));
+var Q256 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(256))
 function subIn256(x, y) {
-  var difference = JSBI.subtract(x, y);
+  var difference = JSBI.subtract(x, y)
   if (JSBI.lessThan(difference, ZERO)) {
-    return JSBI.add(Q256, difference);
+    return JSBI.add(Q256, difference)
   } else {
-    return difference;
+    return difference
   }
 }
-var TickLibrary = /*#__PURE__*/function () {
+var TickLibrary = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function TickLibrary() {}
-  TickLibrary.getFeeGrowthInside = function getFeeGrowthInside(feeGrowthOutsideLower, feeGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, feeGrowthGlobal0X128, feeGrowthGlobal1X128) {
-    var feeGrowthBelow0X128;
-    var feeGrowthBelow1X128;
+  TickLibrary.getFeeGrowthInside = function getFeeGrowthInside(
+    feeGrowthOutsideLower,
+    feeGrowthOutsideUpper,
+    tickLower,
+    tickUpper,
+    tickCurrent,
+    feeGrowthGlobal0X128,
+    feeGrowthGlobal1X128,
+  ) {
+    var feeGrowthBelow0X128
+    var feeGrowthBelow1X128
     if (tickCurrent >= tickLower) {
-      feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128;
-      feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128;
+      feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128
+      feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128
     } else {
-      feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128);
-      feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128);
+      feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128)
+      feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128)
     }
-    var feeGrowthAbove0X128;
-    var feeGrowthAbove1X128;
+    var feeGrowthAbove0X128
+    var feeGrowthAbove1X128
     if (tickCurrent < tickUpper) {
-      feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128;
-      feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128;
+      feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128
+      feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128
     } else {
-      feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128);
-      feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128);
+      feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128)
+      feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128)
     }
-    return [subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128), subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128)];
-  };
-  return TickLibrary;
-}();
+    return [
+      subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128),
+      subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128),
+    ]
+  }
+  return TickLibrary
+})()
 
 var Tick = function Tick(_ref) {
   var index = _ref.index,
     liquidityGross = _ref.liquidityGross,
-    liquidityNet = _ref.liquidityNet;
-  !(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK) ?  invariant(false, 'TICK')  : void 0;
-  this.index = index;
-  this.liquidityGross = JSBI.BigInt(liquidityGross);
-  this.liquidityNet = JSBI.BigInt(liquidityNet);
-};
+    liquidityNet = _ref.liquidityNet
+  !(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK) ? invariant(false, 'TICK') : void 0
+  this.index = index
+  this.liquidityGross = JSBI.BigInt(liquidityGross)
+  this.liquidityNet = JSBI.BigInt(liquidityNet)
+}
 
 /**
  * A data provider for ticks that is backed by an in-memory array of ticks.
  */
-var TickListDataProvider = /*#__PURE__*/function () {
+var TickListDataProvider = /*#__PURE__*/ (function () {
   function TickListDataProvider(ticks, tickSpacing) {
     var ticksMapped = ticks.map(function (t) {
-      return t instanceof Tick ? t : new Tick(t);
-    });
-    TickList.validateList(ticksMapped, tickSpacing);
-    this.ticks = ticksMapped;
-  }
-  var _proto = TickListDataProvider.prototype;
-  _proto.getTick = /*#__PURE__*/function () {
-    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tick) {
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            return _context.abrupt("return", TickList.getTick(this.ticks, tick));
-          case 1:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee, this);
-    }));
+      return t instanceof Tick ? t : new Tick(t)
+    })
+    TickList.validateList(ticksMapped, tickSpacing)
+    this.ticks = ticksMapped
+  }
+  var _proto = TickListDataProvider.prototype
+  _proto.getTick = /*#__PURE__*/ (function () {
+    var _getTick = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(tick) {
+        return _regeneratorRuntime().wrap(
+          function _callee$(_context) {
+            while (1)
+              switch ((_context.prev = _context.next)) {
+                case 0:
+                  return _context.abrupt('return', TickList.getTick(this.ticks, tick))
+                case 1:
+                case 'end':
+                  return _context.stop()
+              }
+          },
+          _callee,
+          this,
+        )
+      }),
+    )
     function getTick(_x) {
-      return _getTick.apply(this, arguments);
-    }
-    return getTick;
-  }();
-  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
-    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tick, lte, tickSpacing) {
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            return _context2.abrupt("return", TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing));
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2, this);
-    }));
+      return _getTick.apply(this, arguments)
+    }
+    return getTick
+  })()
+  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/ (function () {
+    var _nextInitializedTickWithinOneWord = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(tick, lte, tickSpacing) {
+        return _regeneratorRuntime().wrap(
+          function _callee2$(_context2) {
+            while (1)
+              switch ((_context2.prev = _context2.next)) {
+                case 0:
+                  return _context2.abrupt(
+                    'return',
+                    TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing),
+                  )
+                case 1:
+                case 'end':
+                  return _context2.stop()
+              }
+          },
+          _callee2,
+          this,
+        )
+      }),
+    )
     function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
-      return _nextInitializedTickWithinOneWord.apply(this, arguments);
+      return _nextInitializedTickWithinOneWord.apply(this, arguments)
     }
-    return nextInitializedTickWithinOneWord;
-  }();
-  return TickListDataProvider;
-}();
+    return nextInitializedTickWithinOneWord
+  })()
+  return TickListDataProvider
+})()
 
 /**
  * By default, pools will not allow operations that require ticks.
  */
-var NO_TICK_DATA_PROVIDER_DEFAULT = /*#__PURE__*/new NoTickDataProvider();
+var NO_TICK_DATA_PROVIDER_DEFAULT = /*#__PURE__*/ new NoTickDataProvider()
 /**
  * Represents a V3 pool
  */
-var Pool = /*#__PURE__*/function () {
+var Pool = /*#__PURE__*/ (function () {
   /**
    * Construct a pool
    * @param tokenA One of the tokens in the pool
@@ -1355,20 +1681,25 @@ var Pool = /*#__PURE__*/function () {
    */
   function Pool(tokenA, tokenB, fee, sqrtRatioX96, liquidity, tickCurrent, ticks) {
     if (ticks === void 0) {
-      ticks = NO_TICK_DATA_PROVIDER_DEFAULT;
-    }
-    !(Number.isInteger(fee) && fee < 1000000) ?  invariant(false, 'FEE')  : void 0;
-    var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent);
-    var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1);
-    !(JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) && JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)) ?  invariant(false, 'PRICE_BOUNDS')  : void 0;
-    var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
-    this.token0 = _ref[0];
-    this.token1 = _ref[1];
-    this.fee = fee;
-    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96);
-    this.liquidity = JSBI.BigInt(liquidity);
-    this.tickCurrent = tickCurrent;
-    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks;
+      ticks = NO_TICK_DATA_PROVIDER_DEFAULT
+    }
+    !(Number.isInteger(fee) && fee < 1000000) ? invariant(false, 'FEE') : void 0
+    var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent)
+    var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1)
+    !(
+      JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) &&
+      JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)
+    )
+      ? invariant(false, 'PRICE_BOUNDS')
+      : void 0
+    var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]
+    this.token0 = _ref[0]
+    this.token1 = _ref[1]
+    this.fee = fee
+    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96)
+    this.liquidity = JSBI.BigInt(liquidity)
+    this.tickCurrent = tickCurrent
+    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks
   }
   Pool.getAddress = function getAddress(tokenA, tokenB, fee, initCodeHashManualOverride, factoryAddressOverride) {
     return computePoolAddress({
@@ -1376,33 +1707,33 @@ var Pool = /*#__PURE__*/function () {
       fee: fee,
       tokenA: tokenA,
       tokenB: tokenB,
-      initCodeHashManualOverride: initCodeHashManualOverride
-    });
+      initCodeHashManualOverride: initCodeHashManualOverride,
+    })
   }
   /**
    * Returns true if the token is either token0 or token1
    * @param token The token to check
    * @returns True if token is either token0 or token
-   */;
-  var _proto = Pool.prototype;
+   */
+  var _proto = Pool.prototype
   _proto.involvesToken = function involvesToken(token) {
-    return token.equals(this.token0) || token.equals(this.token1);
+    return token.equals(this.token0) || token.equals(this.token1)
   }
   /**
    * Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0
-   */;
+   */
   /**
    * Return the price of the given token in terms of the other token in the pool.
    * @param token The token to return price of
    * @returns The price of the given token, in terms of the other.
    */
   _proto.priceOf = function priceOf(token) {
-    !this.involvesToken(token) ?  invariant(false, 'TOKEN')  : void 0;
-    return token.equals(this.token0) ? this.token0Price : this.token1Price;
+    !this.involvesToken(token) ? invariant(false, 'TOKEN') : void 0
+    return token.equals(this.token0) ? this.token0Price : this.token1Price
   }
   /**
    * Returns the chain ID of the tokens in the pool.
-   */;
+   */
   /**
    * Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade
    * @param inputAmount The input amount for which to quote the output amount
@@ -1410,74 +1741,111 @@ var Pool = /*#__PURE__*/function () {
    * @returns The output amount and the pool with updated state
    */
   _proto.getOutputAmount =
-  /*#__PURE__*/
-  function () {
-    var _getOutputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputAmount, sqrtPriceLimitX96) {
-      var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken;
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            !this.involvesToken(inputAmount.currency) ?  invariant(false, 'TOKEN')  : void 0;
-            zeroForOne = inputAmount.currency.equals(this.token0);
-            _context.next = 4;
-            return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96);
-          case 4:
-            _yield$this$swap = _context.sent;
-            outputAmount = _yield$this$swap.amountCalculated;
-            sqrtRatioX96 = _yield$this$swap.sqrtRatioX96;
-            liquidity = _yield$this$swap.liquidity;
-            tickCurrent = _yield$this$swap.tickCurrent;
-            outputToken = zeroForOne ? this.token1 : this.token0;
-            return _context.abrupt("return", [sdkCore.CurrencyAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)), new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
-          case 11:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee, this);
-    }));
-    function getOutputAmount(_x, _x2) {
-      return _getOutputAmount.apply(this, arguments);
-    }
-    return getOutputAmount;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _getOutputAmount = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(inputAmount, sqrtPriceLimitX96) {
+          var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken
+          return _regeneratorRuntime().wrap(
+            function _callee$(_context) {
+              while (1)
+                switch ((_context.prev = _context.next)) {
+                  case 0:
+                    !this.involvesToken(inputAmount.currency) ? invariant(false, 'TOKEN') : void 0
+                    zeroForOne = inputAmount.currency.equals(this.token0)
+                    _context.next = 4
+                    return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96)
+                  case 4:
+                    _yield$this$swap = _context.sent
+                    outputAmount = _yield$this$swap.amountCalculated
+                    sqrtRatioX96 = _yield$this$swap.sqrtRatioX96
+                    liquidity = _yield$this$swap.liquidity
+                    tickCurrent = _yield$this$swap.tickCurrent
+                    outputToken = zeroForOne ? this.token1 : this.token0
+                    return _context.abrupt('return', [
+                      sdkCore.CurrencyAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)),
+                      new Pool(
+                        this.token0,
+                        this.token1,
+                        this.fee,
+                        sqrtRatioX96,
+                        liquidity,
+                        tickCurrent,
+                        this.tickDataProvider,
+                      ),
+                    ])
+                  case 11:
+                  case 'end':
+                    return _context.stop()
+                }
+            },
+            _callee,
+            this,
+          )
+        }),
+      )
+      function getOutputAmount(_x, _x2) {
+        return _getOutputAmount.apply(this, arguments)
+      }
+      return getOutputAmount
+    })()
   /**
    * Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade
    * @param outputAmount the output amount for which to quote the input amount
    * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap
    * @returns The input amount and the pool with updated state
    */
-  ;
   _proto.getInputAmount =
-  /*#__PURE__*/
-  function () {
-    var _getInputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
-      var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken;
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            !(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency)) ?  invariant(false, 'TOKEN')  : void 0;
-            zeroForOne = outputAmount.currency.equals(this.token1);
-            _context2.next = 4;
-            return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96);
-          case 4:
-            _yield$this$swap2 = _context2.sent;
-            inputAmount = _yield$this$swap2.amountCalculated;
-            sqrtRatioX96 = _yield$this$swap2.sqrtRatioX96;
-            liquidity = _yield$this$swap2.liquidity;
-            tickCurrent = _yield$this$swap2.tickCurrent;
-            inputToken = zeroForOne ? this.token0 : this.token1;
-            return _context2.abrupt("return", [sdkCore.CurrencyAmount.fromRawAmount(inputToken, inputAmount), new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
-          case 11:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2, this);
-    }));
-    function getInputAmount(_x3, _x4) {
-      return _getInputAmount.apply(this, arguments);
-    }
-    return getInputAmount;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _getInputAmount = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
+          var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken
+          return _regeneratorRuntime().wrap(
+            function _callee2$(_context2) {
+              while (1)
+                switch ((_context2.prev = _context2.next)) {
+                  case 0:
+                    !(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency))
+                      ? invariant(false, 'TOKEN')
+                      : void 0
+                    zeroForOne = outputAmount.currency.equals(this.token1)
+                    _context2.next = 4
+                    return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96)
+                  case 4:
+                    _yield$this$swap2 = _context2.sent
+                    inputAmount = _yield$this$swap2.amountCalculated
+                    sqrtRatioX96 = _yield$this$swap2.sqrtRatioX96
+                    liquidity = _yield$this$swap2.liquidity
+                    tickCurrent = _yield$this$swap2.tickCurrent
+                    inputToken = zeroForOne ? this.token0 : this.token1
+                    return _context2.abrupt('return', [
+                      sdkCore.CurrencyAmount.fromRawAmount(inputToken, inputAmount),
+                      new Pool(
+                        this.token0,
+                        this.token1,
+                        this.fee,
+                        sqrtRatioX96,
+                        liquidity,
+                        tickCurrent,
+                        this.tickDataProvider,
+                      ),
+                    ])
+                  case 11:
+                  case 'end':
+                    return _context2.stop()
+                }
+            },
+            _callee2,
+            this,
+          )
+        }),
+      )
+      function getInputAmount(_x3, _x4) {
+        return _getInputAmount.apply(this, arguments)
+      }
+      return getInputAmount
+    })()
   /**
    * Executes a swap
    * @param zeroForOne Whether the amount in is token0 or token1
@@ -1488,59 +1856,97 @@ var Pool = /*#__PURE__*/function () {
    * @returns liquidity
    * @returns tickCurrent
    */
-  ;
   _proto.swap =
-  /*#__PURE__*/
-  function () {
-    var _swap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
-      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
-        while (1) switch (_context3.prev = _context3.next) {
-          case 0:
-            return _context3.abrupt("return", v3Swap(JSBI.BigInt(this.fee), this.sqrtRatioX96, this.tickCurrent, this.liquidity, this.tickSpacing, this.tickDataProvider, zeroForOne, amountSpecified, sqrtPriceLimitX96));
-          case 1:
-          case "end":
-            return _context3.stop();
-        }
-      }, _callee3, this);
-    }));
-    function swap(_x5, _x6, _x7) {
-      return _swap.apply(this, arguments);
-    }
-    return swap;
-  }();
-  _createClass(Pool, [{
-    key: "token0Price",
-    get: function get() {
-      var _this$_token0Price;
-      return (_this$_token0Price = this._token0Price) != null ? _this$_token0Price : this._token0Price = new sdkCore.Price(this.token0, this.token1, Q192, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96));
-    }
-    /**
-     * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
-     */
-  }, {
-    key: "token1Price",
-    get: function get() {
-      var _this$_token1Price;
-      return (_this$_token1Price = this._token1Price) != null ? _this$_token1Price : this._token1Price = new sdkCore.Price(this.token1, this.token0, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96), Q192);
-    }
-  }, {
-    key: "chainId",
-    get: function get() {
-      return this.token0.chainId;
-    }
-  }, {
-    key: "tickSpacing",
-    get: function get() {
-      return TICK_SPACINGS[this.fee];
-    }
-  }]);
-  return Pool;
-}();
+    /*#__PURE__*/
+    (function () {
+      var _swap = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
+          return _regeneratorRuntime().wrap(
+            function _callee3$(_context3) {
+              while (1)
+                switch ((_context3.prev = _context3.next)) {
+                  case 0:
+                    return _context3.abrupt(
+                      'return',
+                      v3Swap(
+                        JSBI.BigInt(this.fee),
+                        this.sqrtRatioX96,
+                        this.tickCurrent,
+                        this.liquidity,
+                        this.tickSpacing,
+                        this.tickDataProvider,
+                        zeroForOne,
+                        amountSpecified,
+                        sqrtPriceLimitX96,
+                      ),
+                    )
+                  case 1:
+                  case 'end':
+                    return _context3.stop()
+                }
+            },
+            _callee3,
+            this,
+          )
+        }),
+      )
+      function swap(_x5, _x6, _x7) {
+        return _swap.apply(this, arguments)
+      }
+      return swap
+    })()
+  _createClass(Pool, [
+    {
+      key: 'token0Price',
+      get: function get() {
+        var _this$_token0Price
+        return (_this$_token0Price = this._token0Price) != null
+          ? _this$_token0Price
+          : (this._token0Price = new sdkCore.Price(
+              this.token0,
+              this.token1,
+              Q192,
+              JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96),
+            ))
+      },
+      /**
+       * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
+       */
+    },
+    {
+      key: 'token1Price',
+      get: function get() {
+        var _this$_token1Price
+        return (_this$_token1Price = this._token1Price) != null
+          ? _this$_token1Price
+          : (this._token1Price = new sdkCore.Price(
+              this.token1,
+              this.token0,
+              JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96),
+              Q192,
+            ))
+      },
+    },
+    {
+      key: 'chainId',
+      get: function get() {
+        return this.token0.chainId
+      },
+    },
+    {
+      key: 'tickSpacing',
+      get: function get() {
+        return TICK_SPACINGS[this.fee]
+      },
+    },
+  ])
+  return Pool
+})()
 
 /**
  * Represents a position on a Uniswap V3 Pool
  */
-var Position = /*#__PURE__*/function () {
+var Position = /*#__PURE__*/ (function () {
   /**
    * Constructs a position for a given pool with the given liquidity
    * @param pool For which pool the liquidity is assigned
@@ -1552,124 +1958,158 @@ var Position = /*#__PURE__*/function () {
     var pool = _ref.pool,
       liquidity = _ref.liquidity,
       tickLower = _ref.tickLower,
-      tickUpper = _ref.tickUpper;
+      tickUpper = _ref.tickUpper
     // cached resuts for the getters
-    this._token0Amount = null;
-    this._token1Amount = null;
-    this._mintAmounts = null;
-    !(tickLower < tickUpper) ?  invariant(false, 'TICK_ORDER')  : void 0;
-    !(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0) ?  invariant(false, 'TICK_LOWER')  : void 0;
-    !(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0) ?  invariant(false, 'TICK_UPPER')  : void 0;
-    this.pool = pool;
-    this.tickLower = tickLower;
-    this.tickUpper = tickUpper;
-    this.liquidity = JSBI.BigInt(liquidity);
+    this._token0Amount = null
+    this._token1Amount = null
+    this._mintAmounts = null
+    !(tickLower < tickUpper) ? invariant(false, 'TICK_ORDER') : void 0
+    !(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0) ? invariant(false, 'TICK_LOWER') : void 0
+    !(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0) ? invariant(false, 'TICK_UPPER') : void 0
+    this.pool = pool
+    this.tickLower = tickLower
+    this.tickUpper = tickUpper
+    this.liquidity = JSBI.BigInt(liquidity)
   }
   /**
    * Returns the price of token0 at the lower tick
    */
-  var _proto = Position.prototype;
+  var _proto = Position.prototype
   /**
    * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage
    * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert
    * @returns The sqrt ratios after slippage
    */
   _proto.ratiosAfterSlippage = function ratiosAfterSlippage(slippageTolerance) {
-    var priceLower = this.pool.token0Price.asFraction.multiply(new sdkCore.Percent(1).subtract(slippageTolerance));
-    var priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1));
-    var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);
+    var priceLower = this.pool.token0Price.asFraction.multiply(new sdkCore.Percent(1).subtract(slippageTolerance))
+    var priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1))
+    var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator)
     if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {
-      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));
+      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1))
     }
-    var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);
+    var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator)
     if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {
-      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));
+      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1))
     }
     return {
       sqrtRatioX96Lower: sqrtRatioX96Lower,
-      sqrtRatioX96Upper: sqrtRatioX96Upper
-    };
+      sqrtRatioX96Upper: sqrtRatioX96Upper,
+    }
   }
   /**
    * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position
    * with the given slippage tolerance
    * @param slippageTolerance Tolerance of unfavorable slippage from the current price
    * @returns The amounts, with slippage
-   */;
+   */
   _proto.mintAmountsWithSlippage = function mintAmountsWithSlippage(slippageTolerance) {
     // get lower/upper prices
     var _this$ratiosAfterSlip = this.ratiosAfterSlippage(slippageTolerance),
       sqrtRatioX96Upper = _this$ratiosAfterSlip.sqrtRatioX96Upper,
-      sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower;
+      sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower
     // construct counterfactual pools
-    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
-    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper));
+    var poolLower = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Lower,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower),
+    )
+    var poolUpper = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Upper,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper),
+    )
     // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)
-    var positionThatWillBeCreated = Position.fromAmounts(_extends({
-      pool: this.pool,
-      tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }, this.mintAmounts, {
-      useFullPrecision: false
-    }));
+    var positionThatWillBeCreated = Position.fromAmounts(
+      _extends(
+        {
+          pool: this.pool,
+          tickLower: this.tickLower,
+          tickUpper: this.tickUpper,
+        },
+        this.mintAmounts,
+        {
+          useFullPrecision: false,
+        },
+      ),
+    )
     // we want the smaller amounts...
     // ...which occurs at the upper price for amount0...
     var amount0 = new Position({
       pool: poolUpper,
       liquidity: positionThatWillBeCreated.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).mintAmounts.amount0;
+      tickUpper: this.tickUpper,
+    }).mintAmounts.amount0
     // ...and the lower for amount1
     var amount1 = new Position({
       pool: poolLower,
       liquidity: positionThatWillBeCreated.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).mintAmounts.amount1;
+      tickUpper: this.tickUpper,
+    }).mintAmounts.amount1
     return {
       amount0: amount0,
-      amount1: amount1
-    };
+      amount1: amount1,
+    }
   }
   /**
    * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the
    * position with the given slippage tolerance
    * @param slippageTolerance tolerance of unfavorable slippage from the current price
    * @returns The amounts, with slippage
-   */;
+   */
   _proto.burnAmountsWithSlippage = function burnAmountsWithSlippage(slippageTolerance) {
     // get lower/upper prices
     var _this$ratiosAfterSlip2 = this.ratiosAfterSlippage(slippageTolerance),
       sqrtRatioX96Upper = _this$ratiosAfterSlip2.sqrtRatioX96Upper,
-      sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower;
+      sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower
     // construct counterfactual pools
-    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
-    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper));
+    var poolLower = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Lower,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower),
+    )
+    var poolUpper = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Upper,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper),
+    )
     // we want the smaller amounts...
     // ...which occurs at the upper price for amount0...
     var amount0 = new Position({
       pool: poolUpper,
       liquidity: this.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).amount0;
+      tickUpper: this.tickUpper,
+    }).amount0
     // ...and the lower for amount1
     var amount1 = new Position({
       pool: poolLower,
       liquidity: this.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).amount1;
+      tickUpper: this.tickUpper,
+    }).amount1
     return {
       amount0: amount0.quotient,
-      amount1: amount1.quotient
-    };
+      amount1: amount1.quotient,
+    }
   }
   /**
    * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at
    * the current price for the pool
-   */;
+   */
   /**
    * Computes the maximum amount of liquidity received for a given amount of token0, token1,
    * and the prices at the tick boundaries.
@@ -1688,15 +2128,22 @@ var Position = /*#__PURE__*/function () {
       tickUpper = _ref2.tickUpper,
       amount0 = _ref2.amount0,
       amount1 = _ref2.amount1,
-      useFullPrecision = _ref2.useFullPrecision;
-    var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
-    var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
+      useFullPrecision = _ref2.useFullPrecision
+    var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower)
+    var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper)
     return new Position({
       pool: pool,
       tickLower: tickLower,
       tickUpper: tickUpper,
-      liquidity: maxLiquidityForAmounts(pool.sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision)
-    });
+      liquidity: maxLiquidityForAmounts(
+        pool.sqrtRatioX96,
+        sqrtRatioAX96,
+        sqrtRatioBX96,
+        amount0,
+        amount1,
+        useFullPrecision,
+      ),
+    })
   }
   /**
    * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1
@@ -1707,21 +2154,21 @@ var Position = /*#__PURE__*/function () {
    * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
    * not what core can theoretically support
    * @returns The position
-   */;
+   */
   Position.fromAmount0 = function fromAmount0(_ref3) {
     var pool = _ref3.pool,
       tickLower = _ref3.tickLower,
       tickUpper = _ref3.tickUpper,
       amount0 = _ref3.amount0,
-      useFullPrecision = _ref3.useFullPrecision;
+      useFullPrecision = _ref3.useFullPrecision
     return Position.fromAmounts({
       pool: pool,
       tickLower: tickLower,
       tickUpper: tickUpper,
       amount0: amount0,
       amount1: sdkCore.MaxUint256,
-      useFullPrecision: useFullPrecision
-    });
+      useFullPrecision: useFullPrecision,
+    })
   }
   /**
    * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0
@@ -1730,12 +2177,12 @@ var Position = /*#__PURE__*/function () {
    * @param tickUpper The upper tick
    * @param amount1 The desired amount of token1
    * @returns The position
-   */;
+   */
   Position.fromAmount1 = function fromAmount1(_ref4) {
     var pool = _ref4.pool,
       tickLower = _ref4.tickLower,
       tickUpper = _ref4.tickUpper,
-      amount1 = _ref4.amount1;
+      amount1 = _ref4.amount1
     // this function always uses full precision,
     return Position.fromAmounts({
       pool: pool,
@@ -1743,89 +2190,147 @@ var Position = /*#__PURE__*/function () {
       tickUpper: tickUpper,
       amount0: sdkCore.MaxUint256,
       amount1: amount1,
-      useFullPrecision: true
-    });
-  };
-  _createClass(Position, [{
-    key: "token0PriceLower",
-    get: function get() {
-      return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower);
-    }
-    /**
-     * Returns the price of token0 at the upper tick
-     */
-  }, {
-    key: "token0PriceUpper",
-    get: function get() {
-      return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper);
-    }
-    /**
-     * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
-     */
-  }, {
-    key: "amount0",
-    get: function get() {
-      if (this._token0Amount === null) {
-        if (this.pool.tickCurrent < this.tickLower) {
-          this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
-        } else if (this.pool.tickCurrent < this.tickUpper) {
-          this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
-        } else {
-          this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token0, ZERO);
+      useFullPrecision: true,
+    })
+  }
+  _createClass(Position, [
+    {
+      key: 'token0PriceLower',
+      get: function get() {
+        return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower)
+      },
+      /**
+       * Returns the price of token0 at the upper tick
+       */
+    },
+    {
+      key: 'token0PriceUpper',
+      get: function get() {
+        return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper)
+      },
+      /**
+       * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
+       */
+    },
+    {
+      key: 'amount0',
+      get: function get() {
+        if (this._token0Amount === null) {
+          if (this.pool.tickCurrent < this.tickLower) {
+            this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(
+              this.pool.token0,
+              SqrtPriceMath.getAmount0Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                false,
+              ),
+            )
+          } else if (this.pool.tickCurrent < this.tickUpper) {
+            this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(
+              this.pool.token0,
+              SqrtPriceMath.getAmount0Delta(
+                this.pool.sqrtRatioX96,
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                false,
+              ),
+            )
+          } else {
+            this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token0, ZERO)
+          }
         }
-      }
-      return this._token0Amount;
-    }
-    /**
-     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
-     */
-  }, {
-    key: "amount1",
-    get: function get() {
-      if (this._token1Amount === null) {
-        if (this.pool.tickCurrent < this.tickLower) {
-          this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token1, ZERO);
-        } else if (this.pool.tickCurrent < this.tickUpper) {
-          this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, false));
-        } else {
-          this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
+        return this._token0Amount
+      },
+      /**
+       * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
+       */
+    },
+    {
+      key: 'amount1',
+      get: function get() {
+        if (this._token1Amount === null) {
+          if (this.pool.tickCurrent < this.tickLower) {
+            this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token1, ZERO)
+          } else if (this.pool.tickCurrent < this.tickUpper) {
+            this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(
+              this.pool.token1,
+              SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                this.pool.sqrtRatioX96,
+                this.liquidity,
+                false,
+              ),
+            )
+          } else {
+            this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(
+              this.pool.token1,
+              SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                false,
+              ),
+            )
+          }
         }
-      }
-      return this._token1Amount;
-    }
-  }, {
-    key: "mintAmounts",
-    get: function get() {
-      if (this._mintAmounts === null) {
-        if (this.pool.tickCurrent < this.tickLower) {
-          return {
-            amount0: SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
-            amount1: ZERO
-          };
-        } else if (this.pool.tickCurrent < this.tickUpper) {
-          return {
-            amount0: SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
-            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, true)
-          };
-        } else {
-          return {
-            amount0: ZERO,
-            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true)
-          };
+        return this._token1Amount
+      },
+    },
+    {
+      key: 'mintAmounts',
+      get: function get() {
+        if (this._mintAmounts === null) {
+          if (this.pool.tickCurrent < this.tickLower) {
+            return {
+              amount0: SqrtPriceMath.getAmount0Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                true,
+              ),
+              amount1: ZERO,
+            }
+          } else if (this.pool.tickCurrent < this.tickUpper) {
+            return {
+              amount0: SqrtPriceMath.getAmount0Delta(
+                this.pool.sqrtRatioX96,
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                true,
+              ),
+              amount1: SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                this.pool.sqrtRatioX96,
+                this.liquidity,
+                true,
+              ),
+            }
+          } else {
+            return {
+              amount0: ZERO,
+              amount1: SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                true,
+              ),
+            }
+          }
         }
-      }
-      return this._mintAmounts;
-    }
-  }]);
-  return Position;
-}();
+        return this._mintAmounts
+      },
+    },
+  ])
+  return Position
+})()
 
 /**
  * Represents a list of pools through which a swap can occur
  * @template TInput The input token
  * @template TOutput The output token
  */
-var Route = /*#__PURE__*/function () {
+var Route = /*#__PURE__*/ (function () {
   /**
    * Creates an instance of route.
    * @param pools An array of `Pool` objects, ordered by the route the swap will take
@@ -1833,68 +2338,80 @@ var Route = /*#__PURE__*/function () {
    * @param output The output token
    */
   function Route(pools, input, output) {
-    this._midPrice = null;
-    !(pools.length > 0) ?  invariant(false, 'POOLS')  : void 0;
-    var chainId = pools[0].chainId;
+    this._midPrice = null
+    !(pools.length > 0) ? invariant(false, 'POOLS') : void 0
+    var chainId = pools[0].chainId
     var allOnSameChain = pools.every(function (pool) {
-      return pool.chainId === chainId;
-    });
-    !allOnSameChain ?  invariant(false, 'CHAIN_IDS')  : void 0;
-    var wrappedInput = input.wrapped;
-    !pools[0].involvesToken(wrappedInput) ?  invariant(false, 'INPUT')  : void 0;
-    !pools[pools.length - 1].involvesToken(output.wrapped) ?  invariant(false, 'OUTPUT')  : void 0;
+      return pool.chainId === chainId
+    })
+    !allOnSameChain ? invariant(false, 'CHAIN_IDS') : void 0
+    var wrappedInput = input.wrapped
+    !pools[0].involvesToken(wrappedInput) ? invariant(false, 'INPUT') : void 0
+    !pools[pools.length - 1].involvesToken(output.wrapped) ? invariant(false, 'OUTPUT') : void 0
     /**
      * Normalizes token0-token1 order and selects the next token/fee step to add to the path
      * */
-    var tokenPath = [wrappedInput];
-    for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done;) {
+    var tokenPath = [wrappedInput]
+    for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done; ) {
       var _step$value = _step.value,
         i = _step$value[0],
-        pool = _step$value[1];
-      var currentInputToken = tokenPath[i];
-      !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1)) ?  invariant(false, 'PATH')  : void 0;
-      var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0;
-      tokenPath.push(nextToken);
-    }
-    this.pools = pools;
-    this.tokenPath = tokenPath;
-    this.input = input;
-    this.output = output != null ? output : tokenPath[tokenPath.length - 1];
-  }
-  _createClass(Route, [{
-    key: "chainId",
-    get: function get() {
-      return this.pools[0].chainId;
+        pool = _step$value[1]
+      var currentInputToken = tokenPath[i]
+      !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1))
+        ? invariant(false, 'PATH')
+        : void 0
+      var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0
+      tokenPath.push(nextToken)
     }
-    /**
-     * Returns the mid price of the route
-     */
-  }, {
-    key: "midPrice",
-    get: function get() {
-      if (this._midPrice !== null) return this._midPrice;
-      var price = this.pools.slice(1).reduce(function (_ref, pool) {
-        var nextInput = _ref.nextInput,
-          price = _ref.price;
-        return nextInput.equals(pool.token0) ? {
-          nextInput: pool.token1,
-          price: price.multiply(pool.token0Price)
-        } : {
-          nextInput: pool.token0,
-          price: price.multiply(pool.token1Price)
-        };
-      }, this.pools[0].token0.equals(this.input.wrapped) ? {
-        nextInput: this.pools[0].token1,
-        price: this.pools[0].token0Price
-      } : {
-        nextInput: this.pools[0].token0,
-        price: this.pools[0].token1Price
-      }).price;
-      return this._midPrice = new sdkCore.Price(this.input, this.output, price.denominator, price.numerator);
-    }
-  }]);
-  return Route;
-}();
+    this.pools = pools
+    this.tokenPath = tokenPath
+    this.input = input
+    this.output = output != null ? output : tokenPath[tokenPath.length - 1]
+  }
+  _createClass(Route, [
+    {
+      key: 'chainId',
+      get: function get() {
+        return this.pools[0].chainId
+      },
+      /**
+       * Returns the mid price of the route
+       */
+    },
+    {
+      key: 'midPrice',
+      get: function get() {
+        if (this._midPrice !== null) return this._midPrice
+        var price = this.pools.slice(1).reduce(
+          function (_ref, pool) {
+            var nextInput = _ref.nextInput,
+              price = _ref.price
+            return nextInput.equals(pool.token0)
+              ? {
+                  nextInput: pool.token1,
+                  price: price.multiply(pool.token0Price),
+                }
+              : {
+                  nextInput: pool.token0,
+                  price: price.multiply(pool.token1Price),
+                }
+          },
+          this.pools[0].token0.equals(this.input.wrapped)
+            ? {
+                nextInput: this.pools[0].token1,
+                price: this.pools[0].token0Price,
+              }
+            : {
+                nextInput: this.pools[0].token0,
+                price: this.pools[0].token1Price,
+              },
+        ).price
+        return (this._midPrice = new sdkCore.Price(this.input, this.output, price.denominator, price.numerator))
+      },
+    },
+  ])
+  return Route
+})()
 
 /**
  * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them
@@ -1907,31 +2424,31 @@ var Route = /*#__PURE__*/function () {
  */
 function tradeComparator(a, b) {
   // must have same input and output token for comparison
-  !a.inputAmount.currency.equals(b.inputAmount.currency) ?  invariant(false, 'INPUT_CURRENCY')  : void 0;
-  !a.outputAmount.currency.equals(b.outputAmount.currency) ?  invariant(false, 'OUTPUT_CURRENCY')  : void 0;
+  !a.inputAmount.currency.equals(b.inputAmount.currency) ? invariant(false, 'INPUT_CURRENCY') : void 0
+  !a.outputAmount.currency.equals(b.outputAmount.currency) ? invariant(false, 'OUTPUT_CURRENCY') : void 0
   if (a.outputAmount.equalTo(b.outputAmount)) {
     if (a.inputAmount.equalTo(b.inputAmount)) {
       // consider the number of hops since each hop costs gas
       var aHops = a.swaps.reduce(function (total, cur) {
-        return total + cur.route.tokenPath.length;
-      }, 0);
+        return total + cur.route.tokenPath.length
+      }, 0)
       var bHops = b.swaps.reduce(function (total, cur) {
-        return total + cur.route.tokenPath.length;
-      }, 0);
-      return aHops - bHops;
+        return total + cur.route.tokenPath.length
+      }, 0)
+      return aHops - bHops
     }
     // trade A requires less input than trade B, so A should come first
     if (a.inputAmount.lessThan(b.inputAmount)) {
-      return -1;
+      return -1
     } else {
-      return 1;
+      return 1
     }
   } else {
     // tradeA has less output than trade B, so should come second
     if (a.outputAmount.lessThan(b.outputAmount)) {
-      return 1;
+      return 1
     } else {
-      return -1;
+      return -1
     }
   }
 }
@@ -1947,7 +2464,7 @@ function tradeComparator(a, b) {
  * @template TOutput The output token, either Ether or an ERC-20
  * @template TTradeType The trade type, either exact input or exact output
  */
-var Trade = /*#__PURE__*/function () {
+var Trade = /*#__PURE__*/ (function () {
   /**
    * Construct a trade by passing in the pre-computed property values
    * @param routes The routes through which the trade occurs
@@ -1955,34 +2472,40 @@ var Trade = /*#__PURE__*/function () {
    */
   function Trade(_ref) {
     var routes = _ref.routes,
-      tradeType = _ref.tradeType;
-    var inputCurrency = routes[0].inputAmount.currency;
-    var outputCurrency = routes[0].outputAmount.currency;
+      tradeType = _ref.tradeType
+    var inputCurrency = routes[0].inputAmount.currency
+    var outputCurrency = routes[0].outputAmount.currency
     !routes.every(function (_ref2) {
-      var route = _ref2.route;
-      return inputCurrency.wrapped.equals(route.input.wrapped);
-    }) ?  invariant(false, 'INPUT_CURRENCY_MATCH')  : void 0;
+      var route = _ref2.route
+      return inputCurrency.wrapped.equals(route.input.wrapped)
+    })
+      ? invariant(false, 'INPUT_CURRENCY_MATCH')
+      : void 0
     !routes.every(function (_ref3) {
-      var route = _ref3.route;
-      return outputCurrency.wrapped.equals(route.output.wrapped);
-    }) ?  invariant(false, 'OUTPUT_CURRENCY_MATCH')  : void 0;
-    var numPools = routes.map(function (_ref4) {
-      var route = _ref4.route;
-      return route.pools.length;
-    }).reduce(function (total, cur) {
-      return total + cur;
-    }, 0);
-    var poolAddressSet = new Set();
-    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done;) {
-      var route = _step.value.route;
-      for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done;) {
-        var pool = _step2.value;
-        poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee));
+      var route = _ref3.route
+      return outputCurrency.wrapped.equals(route.output.wrapped)
+    })
+      ? invariant(false, 'OUTPUT_CURRENCY_MATCH')
+      : void 0
+    var numPools = routes
+      .map(function (_ref4) {
+        var route = _ref4.route
+        return route.pools.length
+      })
+      .reduce(function (total, cur) {
+        return total + cur
+      }, 0)
+    var poolAddressSet = new Set()
+    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done; ) {
+      var route = _step.value.route
+      for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done; ) {
+        var pool = _step2.value
+        poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee))
       }
     }
-    !(numPools === poolAddressSet.size) ?  invariant(false, 'POOLS_DUPLICATED')  : void 0;
-    this.swaps = routes;
-    this.tradeType = tradeType;
+    !(numPools === poolAddressSet.size) ? invariant(false, 'POOLS_DUPLICATED') : void 0
+    this.swaps = routes
+    this.tradeType = tradeType
   }
   /**
    * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes
@@ -2000,24 +2523,27 @@ var Trade = /*#__PURE__*/function () {
    * @returns The exact in trade
    */
   Trade.exactIn =
-  /*#__PURE__*/
-  function () {
-    var _exactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(route, amountIn) {
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            return _context.abrupt("return", Trade.fromRoute(route, amountIn, sdkCore.TradeType.EXACT_INPUT));
-          case 1:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee);
-    }));
-    function exactIn(_x, _x2) {
-      return _exactIn.apply(this, arguments);
-    }
-    return exactIn;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _exactIn = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(route, amountIn) {
+          return _regeneratorRuntime().wrap(function _callee$(_context) {
+            while (1)
+              switch ((_context.prev = _context.next)) {
+                case 0:
+                  return _context.abrupt('return', Trade.fromRoute(route, amountIn, sdkCore.TradeType.EXACT_INPUT))
+                case 1:
+                case 'end':
+                  return _context.stop()
+              }
+          }, _callee)
+        }),
+      )
+      function exactIn(_x, _x2) {
+        return _exactIn.apply(this, arguments)
+      }
+      return exactIn
+    })()
   /**
    * Constructs an exact out trade with the given amount out and route
    * @template TInput The input token, either Ether or an ERC-20
@@ -2026,26 +2552,28 @@ var Trade = /*#__PURE__*/function () {
    * @param amountOut The amount returned by the trade
    * @returns The exact out trade
    */
-  ;
   Trade.exactOut =
-  /*#__PURE__*/
-  function () {
-    var _exactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(route, amountOut) {
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            return _context2.abrupt("return", Trade.fromRoute(route, amountOut, sdkCore.TradeType.EXACT_OUTPUT));
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2);
-    }));
-    function exactOut(_x3, _x4) {
-      return _exactOut.apply(this, arguments);
-    }
-    return exactOut;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _exactOut = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(route, amountOut) {
+          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+            while (1)
+              switch ((_context2.prev = _context2.next)) {
+                case 0:
+                  return _context2.abrupt('return', Trade.fromRoute(route, amountOut, sdkCore.TradeType.EXACT_OUTPUT))
+                case 1:
+                case 'end':
+                  return _context2.stop()
+              }
+          }, _callee2)
+        }),
+      )
+      function exactOut(_x3, _x4) {
+        return _exactOut.apply(this, arguments)
+      }
+      return exactOut
+    })()
   /**
    * Constructs a trade by simulating swaps through the given route
    * @template TInput The input token, either Ether or an ERC-20.
@@ -2056,87 +2584,120 @@ var Trade = /*#__PURE__*/function () {
    * @param tradeType whether the trade is an exact input or exact output swap
    * @returns The route
    */
-  ;
   Trade.fromRoute =
-  /*#__PURE__*/
-  function () {
-    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(route, amount, tradeType) {
-      var amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput, _outputAmount, _i, _pool, _yield$_pool$getInput, _inputAmount;
-      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
-        while (1) switch (_context3.prev = _context3.next) {
-          case 0:
-            amounts = new Array(route.tokenPath.length);
-            if (!(tradeType === sdkCore.TradeType.EXACT_INPUT)) {
-              _context3.next = 19;
-              break;
-            }
-            !amount.currency.equals(route.input) ?  invariant(false, 'INPUT')  : void 0;
-            amounts[0] = amount.wrapped;
-            i = 0;
-          case 5:
-            if (!(i < route.tokenPath.length - 1)) {
-              _context3.next = 15;
-              break;
-            }
-            pool = route.pools[i];
-            _context3.next = 9;
-            return pool.getOutputAmount(amounts[i]);
-          case 9:
-            _yield$pool$getOutput = _context3.sent;
-            _outputAmount = _yield$pool$getOutput[0];
-            amounts[i + 1] = _outputAmount;
-          case 12:
-            i++;
-            _context3.next = 5;
-            break;
-          case 15:
-            inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
-            outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
-            _context3.next = 34;
-            break;
-          case 19:
-            !amount.currency.equals(route.output) ?  invariant(false, 'OUTPUT')  : void 0;
-            amounts[amounts.length - 1] = amount.wrapped;
-            _i = route.tokenPath.length - 1;
-          case 22:
-            if (!(_i > 0)) {
-              _context3.next = 32;
-              break;
-            }
-            _pool = route.pools[_i - 1];
-            _context3.next = 26;
-            return _pool.getInputAmount(amounts[_i]);
-          case 26:
-            _yield$_pool$getInput = _context3.sent;
-            _inputAmount = _yield$_pool$getInput[0];
-            amounts[_i - 1] = _inputAmount;
-          case 29:
-            _i--;
-            _context3.next = 22;
-            break;
-          case 32:
-            inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
-            outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
-          case 34:
-            return _context3.abrupt("return", new Trade({
-              routes: [{
-                inputAmount: inputAmount,
-                outputAmount: outputAmount,
-                route: route
-              }],
-              tradeType: tradeType
-            }));
-          case 35:
-          case "end":
-            return _context3.stop();
-        }
-      }, _callee3);
-    }));
-    function fromRoute(_x5, _x6, _x7) {
-      return _fromRoute.apply(this, arguments);
-    }
-    return fromRoute;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _fromRoute = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee3(route, amount, tradeType) {
+          var amounts,
+            inputAmount,
+            outputAmount,
+            i,
+            pool,
+            _yield$pool$getOutput,
+            _outputAmount,
+            _i,
+            _pool,
+            _yield$_pool$getInput,
+            _inputAmount
+          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
+            while (1)
+              switch ((_context3.prev = _context3.next)) {
+                case 0:
+                  amounts = new Array(route.tokenPath.length)
+                  if (!(tradeType === sdkCore.TradeType.EXACT_INPUT)) {
+                    _context3.next = 19
+                    break
+                  }
+                  !amount.currency.equals(route.input) ? invariant(false, 'INPUT') : void 0
+                  amounts[0] = amount.wrapped
+                  i = 0
+                case 5:
+                  if (!(i < route.tokenPath.length - 1)) {
+                    _context3.next = 15
+                    break
+                  }
+                  pool = route.pools[i]
+                  _context3.next = 9
+                  return pool.getOutputAmount(amounts[i])
+                case 9:
+                  _yield$pool$getOutput = _context3.sent
+                  _outputAmount = _yield$pool$getOutput[0]
+                  amounts[i + 1] = _outputAmount
+                case 12:
+                  i++
+                  _context3.next = 5
+                  break
+                case 15:
+                  inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.input,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.output,
+                    amounts[amounts.length - 1].numerator,
+                    amounts[amounts.length - 1].denominator,
+                  )
+                  _context3.next = 34
+                  break
+                case 19:
+                  !amount.currency.equals(route.output) ? invariant(false, 'OUTPUT') : void 0
+                  amounts[amounts.length - 1] = amount.wrapped
+                  _i = route.tokenPath.length - 1
+                case 22:
+                  if (!(_i > 0)) {
+                    _context3.next = 32
+                    break
+                  }
+                  _pool = route.pools[_i - 1]
+                  _context3.next = 26
+                  return _pool.getInputAmount(amounts[_i])
+                case 26:
+                  _yield$_pool$getInput = _context3.sent
+                  _inputAmount = _yield$_pool$getInput[0]
+                  amounts[_i - 1] = _inputAmount
+                case 29:
+                  _i--
+                  _context3.next = 22
+                  break
+                case 32:
+                  inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.input,
+                    amounts[0].numerator,
+                    amounts[0].denominator,
+                  )
+                  outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.output,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                case 34:
+                  return _context3.abrupt(
+                    'return',
+                    new Trade({
+                      routes: [
+                        {
+                          inputAmount: inputAmount,
+                          outputAmount: outputAmount,
+                          route: route,
+                        },
+                      ],
+                      tradeType: tradeType,
+                    }),
+                  )
+                case 35:
+                case 'end':
+                  return _context3.stop()
+              }
+          }, _callee3)
+        }),
+      )
+      function fromRoute(_x5, _x6, _x7) {
+        return _fromRoute.apply(this, arguments)
+      }
+      return fromRoute
+    })()
   /**
    * Constructs a trade from routes by simulating swaps
    *
@@ -2147,102 +2708,147 @@ var Trade = /*#__PURE__*/function () {
    * @param tradeType whether the trade is an exact input or exact output swap
    * @returns The trade
    */
-  ;
   Trade.fromRoutes =
-  /*#__PURE__*/
-  function () {
-    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(routes, tradeType) {
-      var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput2, _outputAmount2, _i2, _pool2, _yield$_pool2$getInpu, _inputAmount2;
-      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
-        while (1) switch (_context4.prev = _context4.next) {
-          case 0:
-            populatedRoutes = [];
-            _iterator3 = _createForOfIteratorHelperLoose(routes);
-          case 2:
-            if ((_step3 = _iterator3()).done) {
-              _context4.next = 43;
-              break;
-            }
-            _step3$value = _step3.value, route = _step3$value.route, amount = _step3$value.amount;
-            amounts = new Array(route.tokenPath.length);
-            inputAmount = void 0;
-            outputAmount = void 0;
-            if (!(tradeType === sdkCore.TradeType.EXACT_INPUT)) {
-              _context4.next = 25;
-              break;
-            }
-            !amount.currency.equals(route.input) ?  invariant(false, 'INPUT')  : void 0;
-            inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
-            amounts[0] = sdkCore.CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);
-            i = 0;
-          case 12:
-            if (!(i < route.tokenPath.length - 1)) {
-              _context4.next = 22;
-              break;
-            }
-            pool = route.pools[i];
-            _context4.next = 16;
-            return pool.getOutputAmount(amounts[i]);
-          case 16:
-            _yield$pool$getOutput2 = _context4.sent;
-            _outputAmount2 = _yield$pool$getOutput2[0];
-            amounts[i + 1] = _outputAmount2;
-          case 19:
-            i++;
-            _context4.next = 12;
-            break;
-          case 22:
-            outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
-            _context4.next = 40;
-            break;
-          case 25:
-            !amount.currency.equals(route.output) ?  invariant(false, 'OUTPUT')  : void 0;
-            outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
-            amounts[amounts.length - 1] = sdkCore.CurrencyAmount.fromFractionalAmount(route.output.wrapped, amount.numerator, amount.denominator);
-            _i2 = route.tokenPath.length - 1;
-          case 29:
-            if (!(_i2 > 0)) {
-              _context4.next = 39;
-              break;
-            }
-            _pool2 = route.pools[_i2 - 1];
-            _context4.next = 33;
-            return _pool2.getInputAmount(amounts[_i2]);
-          case 33:
-            _yield$_pool2$getInpu = _context4.sent;
-            _inputAmount2 = _yield$_pool2$getInpu[0];
-            amounts[_i2 - 1] = _inputAmount2;
-          case 36:
-            _i2--;
-            _context4.next = 29;
-            break;
-          case 39:
-            inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
-          case 40:
-            populatedRoutes.push({
-              route: route,
-              inputAmount: inputAmount,
-              outputAmount: outputAmount
-            });
-          case 41:
-            _context4.next = 2;
-            break;
-          case 43:
-            return _context4.abrupt("return", new Trade({
-              routes: populatedRoutes,
-              tradeType: tradeType
-            }));
-          case 44:
-          case "end":
-            return _context4.stop();
-        }
-      }, _callee4);
-    }));
-    function fromRoutes(_x8, _x9) {
-      return _fromRoutes.apply(this, arguments);
-    }
-    return fromRoutes;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _fromRoutes = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee4(routes, tradeType) {
+          var populatedRoutes,
+            _iterator3,
+            _step3,
+            _step3$value,
+            route,
+            amount,
+            amounts,
+            inputAmount,
+            outputAmount,
+            i,
+            pool,
+            _yield$pool$getOutput2,
+            _outputAmount2,
+            _i2,
+            _pool2,
+            _yield$_pool2$getInpu,
+            _inputAmount2
+          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
+            while (1)
+              switch ((_context4.prev = _context4.next)) {
+                case 0:
+                  populatedRoutes = []
+                  _iterator3 = _createForOfIteratorHelperLoose(routes)
+                case 2:
+                  if ((_step3 = _iterator3()).done) {
+                    _context4.next = 43
+                    break
+                  }
+                  ;(_step3$value = _step3.value), (route = _step3$value.route), (amount = _step3$value.amount)
+                  amounts = new Array(route.tokenPath.length)
+                  inputAmount = void 0
+                  outputAmount = void 0
+                  if (!(tradeType === sdkCore.TradeType.EXACT_INPUT)) {
+                    _context4.next = 25
+                    break
+                  }
+                  !amount.currency.equals(route.input) ? invariant(false, 'INPUT') : void 0
+                  inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.input,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  amounts[0] = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.input.wrapped,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  i = 0
+                case 12:
+                  if (!(i < route.tokenPath.length - 1)) {
+                    _context4.next = 22
+                    break
+                  }
+                  pool = route.pools[i]
+                  _context4.next = 16
+                  return pool.getOutputAmount(amounts[i])
+                case 16:
+                  _yield$pool$getOutput2 = _context4.sent
+                  _outputAmount2 = _yield$pool$getOutput2[0]
+                  amounts[i + 1] = _outputAmount2
+                case 19:
+                  i++
+                  _context4.next = 12
+                  break
+                case 22:
+                  outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.output,
+                    amounts[amounts.length - 1].numerator,
+                    amounts[amounts.length - 1].denominator,
+                  )
+                  _context4.next = 40
+                  break
+                case 25:
+                  !amount.currency.equals(route.output) ? invariant(false, 'OUTPUT') : void 0
+                  outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.output,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  amounts[amounts.length - 1] = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.output.wrapped,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  _i2 = route.tokenPath.length - 1
+                case 29:
+                  if (!(_i2 > 0)) {
+                    _context4.next = 39
+                    break
+                  }
+                  _pool2 = route.pools[_i2 - 1]
+                  _context4.next = 33
+                  return _pool2.getInputAmount(amounts[_i2])
+                case 33:
+                  _yield$_pool2$getInpu = _context4.sent
+                  _inputAmount2 = _yield$_pool2$getInpu[0]
+                  amounts[_i2 - 1] = _inputAmount2
+                case 36:
+                  _i2--
+                  _context4.next = 29
+                  break
+                case 39:
+                  inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(
+                    route.input,
+                    amounts[0].numerator,
+                    amounts[0].denominator,
+                  )
+                case 40:
+                  populatedRoutes.push({
+                    route: route,
+                    inputAmount: inputAmount,
+                    outputAmount: outputAmount,
+                  })
+                case 41:
+                  _context4.next = 2
+                  break
+                case 43:
+                  return _context4.abrupt(
+                    'return',
+                    new Trade({
+                      routes: populatedRoutes,
+                      tradeType: tradeType,
+                    }),
+                  )
+                case 44:
+                case 'end':
+                  return _context4.stop()
+              }
+          }, _callee4)
+        }),
+      )
+      function fromRoutes(_x8, _x9) {
+        return _fromRoutes.apply(this, arguments)
+      }
+      return fromRoutes
+    })()
   /**
    * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade
    * elsewhere and do not have any tick data
@@ -2252,15 +2858,18 @@ var Trade = /*#__PURE__*/function () {
    * @param constructorArguments The arguments passed to the trade constructor
    * @returns The unchecked trade
    */
-  ;
   Trade.createUncheckedTrade = function createUncheckedTrade(constructorArguments) {
-    return new Trade(_extends({}, constructorArguments, {
-      routes: [{
-        inputAmount: constructorArguments.inputAmount,
-        outputAmount: constructorArguments.outputAmount,
-        route: constructorArguments.route
-      }]
-    }));
+    return new Trade(
+      _extends({}, constructorArguments, {
+        routes: [
+          {
+            inputAmount: constructorArguments.inputAmount,
+            outputAmount: constructorArguments.outputAmount,
+            route: constructorArguments.route,
+          },
+        ],
+      }),
+    )
   }
   /**
    * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade
@@ -2270,52 +2879,62 @@ var Trade = /*#__PURE__*/function () {
    * @template TTradeType The type of the trade, either exact in or exact out
    * @param constructorArguments The arguments passed to the trade constructor
    * @returns The unchecked trade
-   */;
+   */
   Trade.createUncheckedTradeWithMultipleRoutes = function createUncheckedTradeWithMultipleRoutes(constructorArguments) {
-    return new Trade(constructorArguments);
+    return new Trade(constructorArguments)
   }
   /**
    * Get the minimum amount that must be received from this trade for the given slippage tolerance
    * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
    * @returns The amount out
-   */;
-  var _proto = Trade.prototype;
+   */
+  var _proto = Trade.prototype
   _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {
     if (amountOut === void 0) {
-      amountOut = this.outputAmount;
+      amountOut = this.outputAmount
     }
-    !!slippageTolerance.lessThan(ZERO) ?  invariant(false, 'SLIPPAGE_TOLERANCE')  : void 0;
+    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0
     if (this.tradeType === sdkCore.TradeType.EXACT_OUTPUT) {
-      return amountOut;
+      return amountOut
     } else {
-      var slippageAdjustedAmountOut = new sdkCore.Fraction(ONE).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;
-      return sdkCore.CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);
+      var slippageAdjustedAmountOut = new sdkCore.Fraction(ONE)
+        .add(slippageTolerance)
+        .invert()
+        .multiply(amountOut.quotient).quotient
+      return sdkCore.CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)
     }
   }
   /**
    * Get the maximum amount in that can be spent via this trade for the given slippage tolerance
    * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
    * @returns The amount in
-   */;
+   */
   _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {
     if (amountIn === void 0) {
-      amountIn = this.inputAmount;
+      amountIn = this.inputAmount
     }
-    !!slippageTolerance.lessThan(ZERO) ?  invariant(false, 'SLIPPAGE_TOLERANCE')  : void 0;
+    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0
     if (this.tradeType === sdkCore.TradeType.EXACT_INPUT) {
-      return amountIn;
+      return amountIn
     } else {
-      var slippageAdjustedAmountIn = new sdkCore.Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient;
-      return sdkCore.CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);
+      var slippageAdjustedAmountIn = new sdkCore.Fraction(ONE)
+        .add(slippageTolerance)
+        .multiply(amountIn.quotient).quotient
+      return sdkCore.CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)
     }
   }
   /**
    * Return the execution price after accounting for slippage tolerance
    * @param slippageTolerance the allowed tolerated slippage
    * @returns The execution price
-   */;
+   */
   _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {
-    return new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
+    return new sdkCore.Price(
+      this.inputAmount.currency,
+      this.outputAmount.currency,
+      this.maximumAmountIn(slippageTolerance).quotient,
+      this.minimumAmountOut(slippageTolerance).quotient,
+    )
   }
   /**
    * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
@@ -2331,108 +2950,154 @@ var Trade = /*#__PURE__*/function () {
    * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter
    * @param bestTrades used in recursion; the current list of best trades
    * @returns The exact in trade
-   */;
+   */
   Trade.bestTradeExactIn =
-  /*#__PURE__*/
-  function () {
-    var _bestTradeExactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(pools, currencyAmountIn, currencyOut, _temp,
-    // used in recursion.
-    currentPools, nextAmountIn, bestTrades) {
-      var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i, pool, amountOut, _yield$pool$getOutput3, poolsExcludingThisPool;
-      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
-        while (1) switch (_context5.prev = _context5.next) {
-          case 0:
-            _ref5 = _temp === void 0 ? {} : _temp, _ref5$maxNumResults = _ref5.maxNumResults, maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults, _ref5$maxHops = _ref5.maxHops, maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops;
-            if (currentPools === void 0) {
-              currentPools = [];
-            }
-            if (nextAmountIn === void 0) {
-              nextAmountIn = currencyAmountIn;
-            }
-            if (bestTrades === void 0) {
-              bestTrades = [];
-            }
-            !(pools.length > 0) ?  invariant(false, 'POOLS')  : void 0;
-            !(maxHops > 0) ?  invariant(false, 'MAX_HOPS')  : void 0;
-            !(currencyAmountIn === nextAmountIn || currentPools.length > 0) ?  invariant(false, 'INVALID_RECURSION')  : void 0;
-            amountIn = nextAmountIn.wrapped;
-            tokenOut = currencyOut.wrapped;
-            i = 0;
-          case 10:
-            if (!(i < pools.length)) {
-              _context5.next = 46;
-              break;
-            }
-            pool = pools[i]; // pool irrelevant
-            if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {
-              _context5.next = 14;
-              break;
-            }
-            return _context5.abrupt("continue", 43);
-          case 14:
-            amountOut = void 0;
-            _context5.prev = 15;
-            _context5.next = 19;
-            return pool.getOutputAmount(amountIn);
-          case 19:
-            _yield$pool$getOutput3 = _context5.sent;
-            amountOut = _yield$pool$getOutput3[0];
-            _context5.next = 28;
-            break;
-          case 23:
-            _context5.prev = 23;
-            _context5.t0 = _context5["catch"](15);
-            if (!_context5.t0.isInsufficientInputAmountError) {
-              _context5.next = 27;
-              break;
-            }
-            return _context5.abrupt("continue", 43);
-          case 27:
-            throw _context5.t0;
-          case 28:
-            if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {
-              _context5.next = 39;
-              break;
-            }
-            _context5.t1 = sdkCore.sortedInsert;
-            _context5.t2 = bestTrades;
-            _context5.next = 33;
-            return Trade.fromRoute(new Route([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut), currencyAmountIn, sdkCore.TradeType.EXACT_INPUT);
-          case 33:
-            _context5.t3 = _context5.sent;
-            _context5.t4 = maxNumResults;
-            _context5.t5 = tradeComparator;
-            (0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5);
-            _context5.next = 43;
-            break;
-          case 39:
-            if (!(maxHops > 1 && pools.length > 1)) {
-              _context5.next = 43;
-              break;
-            }
-            poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops
-            _context5.next = 43;
-            return Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {
-              maxNumResults: maxNumResults,
-              maxHops: maxHops - 1
-            }, [].concat(currentPools, [pool]), amountOut, bestTrades);
-          case 43:
-            i++;
-            _context5.next = 10;
-            break;
-          case 46:
-            return _context5.abrupt("return", bestTrades);
-          case 47:
-          case "end":
-            return _context5.stop();
-        }
-      }, _callee5, null, [[15, 23]]);
-    }));
-    function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
-      return _bestTradeExactIn.apply(this, arguments);
-    }
-    return bestTradeExactIn;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _bestTradeExactIn = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(
+          function _callee5(
+            pools,
+            currencyAmountIn,
+            currencyOut,
+            _temp,
+            // used in recursion.
+            currentPools,
+            nextAmountIn,
+            bestTrades,
+          ) {
+            var _ref5,
+              _ref5$maxNumResults,
+              maxNumResults,
+              _ref5$maxHops,
+              maxHops,
+              amountIn,
+              tokenOut,
+              i,
+              pool,
+              amountOut,
+              _yield$pool$getOutput3,
+              poolsExcludingThisPool
+            return _regeneratorRuntime().wrap(
+              function _callee5$(_context5) {
+                while (1)
+                  switch ((_context5.prev = _context5.next)) {
+                    case 0:
+                      ;(_ref5 = _temp === void 0 ? {} : _temp),
+                        (_ref5$maxNumResults = _ref5.maxNumResults),
+                        (maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults),
+                        (_ref5$maxHops = _ref5.maxHops),
+                        (maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops)
+                      if (currentPools === void 0) {
+                        currentPools = []
+                      }
+                      if (nextAmountIn === void 0) {
+                        nextAmountIn = currencyAmountIn
+                      }
+                      if (bestTrades === void 0) {
+                        bestTrades = []
+                      }
+                      !(pools.length > 0) ? invariant(false, 'POOLS') : void 0
+                      !(maxHops > 0) ? invariant(false, 'MAX_HOPS') : void 0
+                      !(currencyAmountIn === nextAmountIn || currentPools.length > 0)
+                        ? invariant(false, 'INVALID_RECURSION')
+                        : void 0
+                      amountIn = nextAmountIn.wrapped
+                      tokenOut = currencyOut.wrapped
+                      i = 0
+                    case 10:
+                      if (!(i < pools.length)) {
+                        _context5.next = 46
+                        break
+                      }
+                      pool = pools[i] // pool irrelevant
+                      if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {
+                        _context5.next = 14
+                        break
+                      }
+                      return _context5.abrupt('continue', 43)
+                    case 14:
+                      amountOut = void 0
+                      _context5.prev = 15
+                      _context5.next = 19
+                      return pool.getOutputAmount(amountIn)
+                    case 19:
+                      _yield$pool$getOutput3 = _context5.sent
+                      amountOut = _yield$pool$getOutput3[0]
+                      _context5.next = 28
+                      break
+                    case 23:
+                      _context5.prev = 23
+                      _context5.t0 = _context5['catch'](15)
+                      if (!_context5.t0.isInsufficientInputAmountError) {
+                        _context5.next = 27
+                        break
+                      }
+                      return _context5.abrupt('continue', 43)
+                    case 27:
+                      throw _context5.t0
+                    case 28:
+                      if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {
+                        _context5.next = 39
+                        break
+                      }
+                      _context5.t1 = sdkCore.sortedInsert
+                      _context5.t2 = bestTrades
+                      _context5.next = 33
+                      return Trade.fromRoute(
+                        new Route([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut),
+                        currencyAmountIn,
+                        sdkCore.TradeType.EXACT_INPUT,
+                      )
+                    case 33:
+                      _context5.t3 = _context5.sent
+                      _context5.t4 = maxNumResults
+                      _context5.t5 = tradeComparator
+                      ;(0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5)
+                      _context5.next = 43
+                      break
+                    case 39:
+                      if (!(maxHops > 1 && pools.length > 1)) {
+                        _context5.next = 43
+                        break
+                      }
+                      poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)) // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops
+                      _context5.next = 43
+                      return Trade.bestTradeExactIn(
+                        poolsExcludingThisPool,
+                        currencyAmountIn,
+                        currencyOut,
+                        {
+                          maxNumResults: maxNumResults,
+                          maxHops: maxHops - 1,
+                        },
+                        [].concat(currentPools, [pool]),
+                        amountOut,
+                        bestTrades,
+                      )
+                    case 43:
+                      i++
+                      _context5.next = 10
+                      break
+                    case 46:
+                      return _context5.abrupt('return', bestTrades)
+                    case 47:
+                    case 'end':
+                      return _context5.stop()
+                  }
+              },
+              _callee5,
+              null,
+              [[15, 23]],
+            )
+          },
+        ),
+      )
+      function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
+        return _bestTradeExactIn.apply(this, arguments)
+      }
+      return bestTradeExactIn
+    })()
   /**
    * similar to the above method but instead targets a fixed output amount
    * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
@@ -2449,477 +3114,638 @@ var Trade = /*#__PURE__*/function () {
    * @param bestTrades used in recursion; the current list of best trades
    * @returns The exact out trade
    */
-  ;
   Trade.bestTradeExactOut =
-  /*#__PURE__*/
-  function () {
-    var _bestTradeExactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pools, currencyIn, currencyAmountOut, _temp2,
-    // used in recursion.
-    currentPools, nextAmountOut, bestTrades) {
-      var _ref6, _ref6$maxNumResults, maxNumResults, _ref6$maxHops, maxHops, amountOut, tokenIn, i, pool, amountIn, _yield$pool$getInputA, poolsExcludingThisPool;
-      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
-        while (1) switch (_context6.prev = _context6.next) {
-          case 0:
-            _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$maxNumResults = _ref6.maxNumResults, maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults, _ref6$maxHops = _ref6.maxHops, maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops;
-            if (currentPools === void 0) {
-              currentPools = [];
-            }
-            if (nextAmountOut === void 0) {
-              nextAmountOut = currencyAmountOut;
-            }
-            if (bestTrades === void 0) {
-              bestTrades = [];
-            }
-            !(pools.length > 0) ?  invariant(false, 'POOLS')  : void 0;
-            !(maxHops > 0) ?  invariant(false, 'MAX_HOPS')  : void 0;
-            !(currencyAmountOut === nextAmountOut || currentPools.length > 0) ?  invariant(false, 'INVALID_RECURSION')  : void 0;
-            amountOut = nextAmountOut.wrapped;
-            tokenIn = currencyIn.wrapped;
-            i = 0;
-          case 10:
-            if (!(i < pools.length)) {
-              _context6.next = 46;
-              break;
-            }
-            pool = pools[i]; // pool irrelevant
-            if (!(!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))) {
-              _context6.next = 14;
-              break;
-            }
-            return _context6.abrupt("continue", 43);
-          case 14:
-            amountIn = void 0;
-            _context6.prev = 15;
-            _context6.next = 19;
-            return pool.getInputAmount(amountOut);
-          case 19:
-            _yield$pool$getInputA = _context6.sent;
-            amountIn = _yield$pool$getInputA[0];
-            _context6.next = 28;
-            break;
-          case 23:
-            _context6.prev = 23;
-            _context6.t0 = _context6["catch"](15);
-            if (!_context6.t0.isInsufficientReservesError) {
-              _context6.next = 27;
-              break;
-            }
-            return _context6.abrupt("continue", 43);
-          case 27:
-            throw _context6.t0;
-          case 28:
-            if (!amountIn.currency.equals(tokenIn)) {
-              _context6.next = 39;
-              break;
-            }
-            _context6.t1 = sdkCore.sortedInsert;
-            _context6.t2 = bestTrades;
-            _context6.next = 33;
-            return Trade.fromRoute(new Route([pool].concat(currentPools), currencyIn, currencyAmountOut.currency), currencyAmountOut, sdkCore.TradeType.EXACT_OUTPUT);
-          case 33:
-            _context6.t3 = _context6.sent;
-            _context6.t4 = maxNumResults;
-            _context6.t5 = tradeComparator;
-            (0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5);
-            _context6.next = 43;
-            break;
-          case 39:
-            if (!(maxHops > 1 && pools.length > 1)) {
-              _context6.next = 43;
-              break;
-            }
-            poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops
-            _context6.next = 43;
-            return Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {
-              maxNumResults: maxNumResults,
-              maxHops: maxHops - 1
-            }, [pool].concat(currentPools), amountIn, bestTrades);
-          case 43:
-            i++;
-            _context6.next = 10;
-            break;
-          case 46:
-            return _context6.abrupt("return", bestTrades);
-          case 47:
-          case "end":
-            return _context6.stop();
-        }
-      }, _callee6, null, [[15, 23]]);
-    }));
-    function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
-      return _bestTradeExactOut.apply(this, arguments);
-    }
-    return bestTradeExactOut;
-  }();
-  _createClass(Trade, [{
-    key: "route",
-    get: function get() {
-      !(this.swaps.length === 1) ?  invariant(false, 'MULTIPLE_ROUTES')  : void 0;
-      return this.swaps[0].route;
-    }
-    /**
-     * The input amount for the trade assuming no slippage.
-     */
-  }, {
-    key: "inputAmount",
-    get: function get() {
-      if (this._inputAmount) {
-        return this._inputAmount;
-      }
-      var inputCurrency = this.swaps[0].inputAmount.currency;
-      var totalInputFromRoutes = this.swaps.map(function (_ref7) {
-        var inputAmount = _ref7.inputAmount;
-        return inputAmount;
-      }).reduce(function (total, cur) {
-        return total.add(cur);
-      }, sdkCore.CurrencyAmount.fromRawAmount(inputCurrency, 0));
-      this._inputAmount = totalInputFromRoutes;
-      return this._inputAmount;
-    }
-    /**
-     * The output amount for the trade assuming no slippage.
-     */
-  }, {
-    key: "outputAmount",
-    get: function get() {
-      if (this._outputAmount) {
-        return this._outputAmount;
+    /*#__PURE__*/
+    (function () {
+      var _bestTradeExactOut = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(
+          function _callee6(
+            pools,
+            currencyIn,
+            currencyAmountOut,
+            _temp2,
+            // used in recursion.
+            currentPools,
+            nextAmountOut,
+            bestTrades,
+          ) {
+            var _ref6,
+              _ref6$maxNumResults,
+              maxNumResults,
+              _ref6$maxHops,
+              maxHops,
+              amountOut,
+              tokenIn,
+              i,
+              pool,
+              amountIn,
+              _yield$pool$getInputA,
+              poolsExcludingThisPool
+            return _regeneratorRuntime().wrap(
+              function _callee6$(_context6) {
+                while (1)
+                  switch ((_context6.prev = _context6.next)) {
+                    case 0:
+                      ;(_ref6 = _temp2 === void 0 ? {} : _temp2),
+                        (_ref6$maxNumResults = _ref6.maxNumResults),
+                        (maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults),
+                        (_ref6$maxHops = _ref6.maxHops),
+                        (maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops)
+                      if (currentPools === void 0) {
+                        currentPools = []
+                      }
+                      if (nextAmountOut === void 0) {
+                        nextAmountOut = currencyAmountOut
+                      }
+                      if (bestTrades === void 0) {
+                        bestTrades = []
+                      }
+                      !(pools.length > 0) ? invariant(false, 'POOLS') : void 0
+                      !(maxHops > 0) ? invariant(false, 'MAX_HOPS') : void 0
+                      !(currencyAmountOut === nextAmountOut || currentPools.length > 0)
+                        ? invariant(false, 'INVALID_RECURSION')
+                        : void 0
+                      amountOut = nextAmountOut.wrapped
+                      tokenIn = currencyIn.wrapped
+                      i = 0
+                    case 10:
+                      if (!(i < pools.length)) {
+                        _context6.next = 46
+                        break
+                      }
+                      pool = pools[i] // pool irrelevant
+                      if (!(!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))) {
+                        _context6.next = 14
+                        break
+                      }
+                      return _context6.abrupt('continue', 43)
+                    case 14:
+                      amountIn = void 0
+                      _context6.prev = 15
+                      _context6.next = 19
+                      return pool.getInputAmount(amountOut)
+                    case 19:
+                      _yield$pool$getInputA = _context6.sent
+                      amountIn = _yield$pool$getInputA[0]
+                      _context6.next = 28
+                      break
+                    case 23:
+                      _context6.prev = 23
+                      _context6.t0 = _context6['catch'](15)
+                      if (!_context6.t0.isInsufficientReservesError) {
+                        _context6.next = 27
+                        break
+                      }
+                      return _context6.abrupt('continue', 43)
+                    case 27:
+                      throw _context6.t0
+                    case 28:
+                      if (!amountIn.currency.equals(tokenIn)) {
+                        _context6.next = 39
+                        break
+                      }
+                      _context6.t1 = sdkCore.sortedInsert
+                      _context6.t2 = bestTrades
+                      _context6.next = 33
+                      return Trade.fromRoute(
+                        new Route([pool].concat(currentPools), currencyIn, currencyAmountOut.currency),
+                        currencyAmountOut,
+                        sdkCore.TradeType.EXACT_OUTPUT,
+                      )
+                    case 33:
+                      _context6.t3 = _context6.sent
+                      _context6.t4 = maxNumResults
+                      _context6.t5 = tradeComparator
+                      ;(0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5)
+                      _context6.next = 43
+                      break
+                    case 39:
+                      if (!(maxHops > 1 && pools.length > 1)) {
+                        _context6.next = 43
+                        break
+                      }
+                      poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)) // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops
+                      _context6.next = 43
+                      return Trade.bestTradeExactOut(
+                        poolsExcludingThisPool,
+                        currencyIn,
+                        currencyAmountOut,
+                        {
+                          maxNumResults: maxNumResults,
+                          maxHops: maxHops - 1,
+                        },
+                        [pool].concat(currentPools),
+                        amountIn,
+                        bestTrades,
+                      )
+                    case 43:
+                      i++
+                      _context6.next = 10
+                      break
+                    case 46:
+                      return _context6.abrupt('return', bestTrades)
+                    case 47:
+                    case 'end':
+                      return _context6.stop()
+                  }
+              },
+              _callee6,
+              null,
+              [[15, 23]],
+            )
+          },
+        ),
+      )
+      function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
+        return _bestTradeExactOut.apply(this, arguments)
       }
-      var outputCurrency = this.swaps[0].outputAmount.currency;
-      var totalOutputFromRoutes = this.swaps.map(function (_ref8) {
-        var outputAmount = _ref8.outputAmount;
-        return outputAmount;
-      }).reduce(function (total, cur) {
-        return total.add(cur);
-      }, sdkCore.CurrencyAmount.fromRawAmount(outputCurrency, 0));
-      this._outputAmount = totalOutputFromRoutes;
-      return this._outputAmount;
-    }
-    /**
-     * The price expressed in terms of output amount/input amount.
-     */
-  }, {
-    key: "executionPrice",
-    get: function get() {
-      var _this$_executionPrice;
-      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
-    }
-    /**
-     * Returns the percent difference between the route's mid price and the price impact
-     */
-  }, {
-    key: "priceImpact",
-    get: function get() {
-      if (this._priceImpact) {
-        return this._priceImpact;
-      }
-      var spotOutputAmount = sdkCore.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);
-      for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done;) {
-        var _step4$value = _step4.value,
-          route = _step4$value.route,
-          inputAmount = _step4$value.inputAmount;
-        var midPrice = route.midPrice;
-        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));
-      }
-      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);
-      this._priceImpact = new sdkCore.Percent(priceImpact.numerator, priceImpact.denominator);
-      return this._priceImpact;
-    }
-  }]);
-  return Trade;
-}();
+      return bestTradeExactOut
+    })()
+  _createClass(Trade, [
+    {
+      key: 'route',
+      get: function get() {
+        !(this.swaps.length === 1) ? invariant(false, 'MULTIPLE_ROUTES') : void 0
+        return this.swaps[0].route
+      },
+      /**
+       * The input amount for the trade assuming no slippage.
+       */
+    },
+    {
+      key: 'inputAmount',
+      get: function get() {
+        if (this._inputAmount) {
+          return this._inputAmount
+        }
+        var inputCurrency = this.swaps[0].inputAmount.currency
+        var totalInputFromRoutes = this.swaps
+          .map(function (_ref7) {
+            var inputAmount = _ref7.inputAmount
+            return inputAmount
+          })
+          .reduce(
+            function (total, cur) {
+              return total.add(cur)
+            },
+            sdkCore.CurrencyAmount.fromRawAmount(inputCurrency, 0),
+          )
+        this._inputAmount = totalInputFromRoutes
+        return this._inputAmount
+      },
+      /**
+       * The output amount for the trade assuming no slippage.
+       */
+    },
+    {
+      key: 'outputAmount',
+      get: function get() {
+        if (this._outputAmount) {
+          return this._outputAmount
+        }
+        var outputCurrency = this.swaps[0].outputAmount.currency
+        var totalOutputFromRoutes = this.swaps
+          .map(function (_ref8) {
+            var outputAmount = _ref8.outputAmount
+            return outputAmount
+          })
+          .reduce(
+            function (total, cur) {
+              return total.add(cur)
+            },
+            sdkCore.CurrencyAmount.fromRawAmount(outputCurrency, 0),
+          )
+        this._outputAmount = totalOutputFromRoutes
+        return this._outputAmount
+      },
+      /**
+       * The price expressed in terms of output amount/input amount.
+       */
+    },
+    {
+      key: 'executionPrice',
+      get: function get() {
+        var _this$_executionPrice
+        return (_this$_executionPrice = this._executionPrice) != null
+          ? _this$_executionPrice
+          : (this._executionPrice = new sdkCore.Price(
+              this.inputAmount.currency,
+              this.outputAmount.currency,
+              this.inputAmount.quotient,
+              this.outputAmount.quotient,
+            ))
+      },
+      /**
+       * Returns the percent difference between the route's mid price and the price impact
+       */
+    },
+    {
+      key: 'priceImpact',
+      get: function get() {
+        if (this._priceImpact) {
+          return this._priceImpact
+        }
+        var spotOutputAmount = sdkCore.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)
+        for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done; ) {
+          var _step4$value = _step4.value,
+            route = _step4$value.route,
+            inputAmount = _step4$value.inputAmount
+          var midPrice = route.midPrice
+          spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))
+        }
+        var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)
+        this._priceImpact = new sdkCore.Percent(priceImpact.numerator, priceImpact.denominator)
+        return this._priceImpact
+      },
+    },
+  ])
+  return Trade
+})()
 
-var Multicall = /*#__PURE__*/function () {
+var Multicall = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function Multicall() {}
   Multicall.encodeMulticall = function encodeMulticall(calldatas) {
     if (!Array.isArray(calldatas)) {
-      calldatas = [calldatas];
+      calldatas = [calldatas]
     }
-    return calldatas.length === 1 ? calldatas[0] : Multicall.INTERFACE.encodeFunctionData('multicall', [calldatas]);
-  };
+    return calldatas.length === 1 ? calldatas[0] : Multicall.INTERFACE.encodeFunctionData('multicall', [calldatas])
+  }
   Multicall.decodeMulticall = function decodeMulticall(multicall) {
-    return Multicall.INTERFACE.decodeFunctionData('multicall', multicall).data;
-  };
-  return Multicall;
-}();
-Multicall.INTERFACE = /*#__PURE__*/new abi.Interface(IMulticall.abi);
+    return Multicall.INTERFACE.decodeFunctionData('multicall', multicall).data
+  }
+  return Multicall
+})()
+Multicall.INTERFACE = /*#__PURE__*/ new abi.Interface(IMulticall.abi)
 
 function isAllowedPermit(permitOptions) {
-  return 'nonce' in permitOptions;
+  return 'nonce' in permitOptions
 }
-var SelfPermit = /*#__PURE__*/function () {
+var SelfPermit = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function SelfPermit() {}
   SelfPermit.encodePermit = function encodePermit(token, options) {
-    return isAllowedPermit(options) ? SelfPermit.INTERFACE.encodeFunctionData('selfPermitAllowed', [token.address, toHex(options.nonce), toHex(options.expiry), options.v, options.r, options.s]) : SelfPermit.INTERFACE.encodeFunctionData('selfPermit', [token.address, toHex(options.amount), toHex(options.deadline), options.v, options.r, options.s]);
-  };
-  return SelfPermit;
-}();
-SelfPermit.INTERFACE = /*#__PURE__*/new abi.Interface(ISelfPermit.abi);
+    return isAllowedPermit(options)
+      ? SelfPermit.INTERFACE.encodeFunctionData('selfPermitAllowed', [
+          token.address,
+          toHex(options.nonce),
+          toHex(options.expiry),
+          options.v,
+          options.r,
+          options.s,
+        ])
+      : SelfPermit.INTERFACE.encodeFunctionData('selfPermit', [
+          token.address,
+          toHex(options.amount),
+          toHex(options.deadline),
+          options.v,
+          options.r,
+          options.s,
+        ])
+  }
+  return SelfPermit
+})()
+SelfPermit.INTERFACE = /*#__PURE__*/ new abi.Interface(ISelfPermit.abi)
 
-var Payments = /*#__PURE__*/function () {
+var Payments = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function Payments() {}
   Payments.encodeFeeBips = function encodeFeeBips(fee) {
-    return toHex(fee.multiply(10000).quotient);
-  };
+    return toHex(fee.multiply(10000).quotient)
+  }
   Payments.encodeUnwrapWETH9 = function encodeUnwrapWETH9(amountMinimum, recipient, feeOptions) {
-    recipient = sdkCore.validateAndParseAddress(recipient);
+    recipient = sdkCore.validateAndParseAddress(recipient)
     if (!!feeOptions) {
-      var feeBips = this.encodeFeeBips(feeOptions.fee);
-      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);
-      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9WithFee', [toHex(amountMinimum), recipient, feeBips, feeRecipient]);
+      var feeBips = this.encodeFeeBips(feeOptions.fee)
+      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient)
+      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9WithFee', [
+        toHex(amountMinimum),
+        recipient,
+        feeBips,
+        feeRecipient,
+      ])
     } else {
-      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9', [toHex(amountMinimum), recipient]);
+      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9', [toHex(amountMinimum), recipient])
     }
-  };
+  }
   Payments.encodeSweepToken = function encodeSweepToken(token, amountMinimum, recipient, feeOptions) {
-    recipient = sdkCore.validateAndParseAddress(recipient);
+    recipient = sdkCore.validateAndParseAddress(recipient)
     if (!!feeOptions) {
-      var feeBips = this.encodeFeeBips(feeOptions.fee);
-      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);
-      return Payments.INTERFACE.encodeFunctionData('sweepTokenWithFee', [token.address, toHex(amountMinimum), recipient, feeBips, feeRecipient]);
+      var feeBips = this.encodeFeeBips(feeOptions.fee)
+      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient)
+      return Payments.INTERFACE.encodeFunctionData('sweepTokenWithFee', [
+        token.address,
+        toHex(amountMinimum),
+        recipient,
+        feeBips,
+        feeRecipient,
+      ])
     } else {
-      return Payments.INTERFACE.encodeFunctionData('sweepToken', [token.address, toHex(amountMinimum), recipient]);
+      return Payments.INTERFACE.encodeFunctionData('sweepToken', [token.address, toHex(amountMinimum), recipient])
     }
-  };
+  }
   Payments.encodeRefundETH = function encodeRefundETH() {
-    return Payments.INTERFACE.encodeFunctionData('refundETH');
-  };
-  return Payments;
-}();
-Payments.INTERFACE = /*#__PURE__*/new abi.Interface(IPeripheryPaymentsWithFee.abi);
+    return Payments.INTERFACE.encodeFunctionData('refundETH')
+  }
+  return Payments
+})()
+Payments.INTERFACE = /*#__PURE__*/ new abi.Interface(IPeripheryPaymentsWithFee.abi)
 
-var _excluded = ["expectedCurrencyOwed0", "expectedCurrencyOwed1"];
-var MaxUint128 = /*#__PURE__*/toHex( /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128)), /*#__PURE__*/JSBI.BigInt(1)));
+var _excluded = ['expectedCurrencyOwed0', 'expectedCurrencyOwed1']
+var MaxUint128 = /*#__PURE__*/ toHex(
+  /*#__PURE__*/ JSBI.subtract(
+    /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(128)),
+    /*#__PURE__*/ JSBI.BigInt(1),
+  ),
+)
 // type guard
 function isMint(options) {
   return Object.keys(options).some(function (k) {
-    return k === 'recipient';
-  });
+    return k === 'recipient'
+  })
 }
 var NFT_PERMIT_TYPES = {
-  Permit: [{
-    name: 'spender',
-    type: 'address'
-  }, {
-    name: 'tokenId',
-    type: 'uint256'
-  }, {
-    name: 'nonce',
-    type: 'uint256'
-  }, {
-    name: 'deadline',
-    type: 'uint256'
-  }]
-};
-var NonfungiblePositionManager = /*#__PURE__*/function () {
+  Permit: [
+    {
+      name: 'spender',
+      type: 'address',
+    },
+    {
+      name: 'tokenId',
+      type: 'uint256',
+    },
+    {
+      name: 'nonce',
+      type: 'uint256',
+    },
+    {
+      name: 'deadline',
+      type: 'uint256',
+    },
+  ],
+}
+var NonfungiblePositionManager = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function NonfungiblePositionManager() {}
   NonfungiblePositionManager.encodeCreate = function encodeCreate(pool) {
-    return NonfungiblePositionManager.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [pool.token0.address, pool.token1.address, pool.fee, toHex(pool.sqrtRatioX96)]);
-  };
+    return NonfungiblePositionManager.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [
+      pool.token0.address,
+      pool.token1.address,
+      pool.fee,
+      toHex(pool.sqrtRatioX96),
+    ])
+  }
   NonfungiblePositionManager.createCallParameters = function createCallParameters(pool) {
     return {
       calldata: this.encodeCreate(pool),
-      value: toHex(0)
-    };
-  };
+      value: toHex(0),
+    }
+  }
   NonfungiblePositionManager.addCallParameters = function addCallParameters(position, options) {
-    !JSBI.greaterThan(position.liquidity, ZERO) ?  invariant(false, 'ZERO_LIQUIDITY')  : void 0;
-    var calldatas = [];
+    !JSBI.greaterThan(position.liquidity, ZERO) ? invariant(false, 'ZERO_LIQUIDITY') : void 0
+    var calldatas = []
     // get amounts
     var _position$mintAmounts = position.mintAmounts,
       amount0Desired = _position$mintAmounts.amount0,
-      amount1Desired = _position$mintAmounts.amount1;
+      amount1Desired = _position$mintAmounts.amount1
     // adjust for slippage
-    var minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance);
-    var amount0Min = toHex(minimumAmounts.amount0);
-    var amount1Min = toHex(minimumAmounts.amount1);
-    var deadline = toHex(options.deadline);
+    var minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance)
+    var amount0Min = toHex(minimumAmounts.amount0)
+    var amount1Min = toHex(minimumAmounts.amount1)
+    var deadline = toHex(options.deadline)
     // create pool if needed
     if (isMint(options) && options.createPool) {
-      calldatas.push(this.encodeCreate(position.pool));
+      calldatas.push(this.encodeCreate(position.pool))
     }
     // permits if necessary
     if (options.token0Permit) {
-      calldatas.push(SelfPermit.encodePermit(position.pool.token0, options.token0Permit));
+      calldatas.push(SelfPermit.encodePermit(position.pool.token0, options.token0Permit))
     }
     if (options.token1Permit) {
-      calldatas.push(SelfPermit.encodePermit(position.pool.token1, options.token1Permit));
+      calldatas.push(SelfPermit.encodePermit(position.pool.token1, options.token1Permit))
     }
     // mint
     if (isMint(options)) {
-      var recipient = sdkCore.validateAndParseAddress(options.recipient);
-      calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('mint', [{
-        token0: position.pool.token0.address,
-        token1: position.pool.token1.address,
-        fee: position.pool.fee,
-        tickLower: position.tickLower,
-        tickUpper: position.tickUpper,
-        amount0Desired: toHex(amount0Desired),
-        amount1Desired: toHex(amount1Desired),
-        amount0Min: amount0Min,
-        amount1Min: amount1Min,
-        recipient: recipient,
-        deadline: deadline
-      }]));
+      var recipient = sdkCore.validateAndParseAddress(options.recipient)
+      calldatas.push(
+        NonfungiblePositionManager.INTERFACE.encodeFunctionData('mint', [
+          {
+            token0: position.pool.token0.address,
+            token1: position.pool.token1.address,
+            fee: position.pool.fee,
+            tickLower: position.tickLower,
+            tickUpper: position.tickUpper,
+            amount0Desired: toHex(amount0Desired),
+            amount1Desired: toHex(amount1Desired),
+            amount0Min: amount0Min,
+            amount1Min: amount1Min,
+            recipient: recipient,
+            deadline: deadline,
+          },
+        ]),
+      )
     } else {
       // increase
-      calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('increaseLiquidity', [{
-        tokenId: toHex(options.tokenId),
-        amount0Desired: toHex(amount0Desired),
-        amount1Desired: toHex(amount1Desired),
-        amount0Min: amount0Min,
-        amount1Min: amount1Min,
-        deadline: deadline
-      }]));
-    }
-    var value = toHex(0);
+      calldatas.push(
+        NonfungiblePositionManager.INTERFACE.encodeFunctionData('increaseLiquidity', [
+          {
+            tokenId: toHex(options.tokenId),
+            amount0Desired: toHex(amount0Desired),
+            amount1Desired: toHex(amount1Desired),
+            amount0Min: amount0Min,
+            amount1Min: amount1Min,
+            deadline: deadline,
+          },
+        ]),
+      )
+    }
+    var value = toHex(0)
     if (options.useNative) {
-      var wrapped = options.useNative.wrapped;
-      !(position.pool.token0.equals(wrapped) || position.pool.token1.equals(wrapped)) ?  invariant(false, 'NO_WETH')  : void 0;
-      var wrappedValue = position.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired;
+      var wrapped = options.useNative.wrapped
+      !(position.pool.token0.equals(wrapped) || position.pool.token1.equals(wrapped))
+        ? invariant(false, 'NO_WETH')
+        : void 0
+      var wrappedValue = position.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired
       // we only need to refund if we're actually sending ETH
       if (JSBI.greaterThan(wrappedValue, ZERO)) {
-        calldatas.push(Payments.encodeRefundETH());
+        calldatas.push(Payments.encodeRefundETH())
       }
-      value = toHex(wrappedValue);
+      value = toHex(wrappedValue)
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: value
-    };
-  };
+      value: value,
+    }
+  }
   NonfungiblePositionManager.encodeCollect = function encodeCollect(options) {
-    var calldatas = [];
-    var tokenId = toHex(options.tokenId);
-    var involvesETH = options.expectedCurrencyOwed0.currency.isNative || options.expectedCurrencyOwed1.currency.isNative;
-    var recipient = sdkCore.validateAndParseAddress(options.recipient);
+    var calldatas = []
+    var tokenId = toHex(options.tokenId)
+    var involvesETH = options.expectedCurrencyOwed0.currency.isNative || options.expectedCurrencyOwed1.currency.isNative
+    var recipient = sdkCore.validateAndParseAddress(options.recipient)
     // collect
-    calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('collect', [{
-      tokenId: tokenId,
-      recipient: involvesETH ? ADDRESS_ZERO : recipient,
-      amount0Max: MaxUint128,
-      amount1Max: MaxUint128
-    }]));
+    calldatas.push(
+      NonfungiblePositionManager.INTERFACE.encodeFunctionData('collect', [
+        {
+          tokenId: tokenId,
+          recipient: involvesETH ? ADDRESS_ZERO : recipient,
+          amount0Max: MaxUint128,
+          amount1Max: MaxUint128,
+        },
+      ]),
+    )
     if (involvesETH) {
-      var ethAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed0.quotient : options.expectedCurrencyOwed1.quotient;
-      var token = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.currency : options.expectedCurrencyOwed0.currency;
-      var tokenAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.quotient : options.expectedCurrencyOwed0.quotient;
-      calldatas.push(Payments.encodeUnwrapWETH9(ethAmount, recipient));
-      calldatas.push(Payments.encodeSweepToken(token, tokenAmount, recipient));
-    }
-    return calldatas;
-  };
+      var ethAmount = options.expectedCurrencyOwed0.currency.isNative
+        ? options.expectedCurrencyOwed0.quotient
+        : options.expectedCurrencyOwed1.quotient
+      var token = options.expectedCurrencyOwed0.currency.isNative
+        ? options.expectedCurrencyOwed1.currency
+        : options.expectedCurrencyOwed0.currency
+      var tokenAmount = options.expectedCurrencyOwed0.currency.isNative
+        ? options.expectedCurrencyOwed1.quotient
+        : options.expectedCurrencyOwed0.quotient
+      calldatas.push(Payments.encodeUnwrapWETH9(ethAmount, recipient))
+      calldatas.push(Payments.encodeSweepToken(token, tokenAmount, recipient))
+    }
+    return calldatas
+  }
   NonfungiblePositionManager.collectCallParameters = function collectCallParameters(options) {
-    var calldatas = NonfungiblePositionManager.encodeCollect(options);
+    var calldatas = NonfungiblePositionManager.encodeCollect(options)
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   /**
    * Produces the calldata for completely or partially exiting a position
    * @param position The position to exit
    * @param options Additional information necessary for generating the calldata
    * @returns The call parameters
-   */;
+   */
   NonfungiblePositionManager.removeCallParameters = function removeCallParameters(position, options) {
-    var calldatas = [];
-    var deadline = toHex(options.deadline);
-    var tokenId = toHex(options.tokenId);
+    var calldatas = []
+    var deadline = toHex(options.deadline)
+    var tokenId = toHex(options.tokenId)
     // construct a partial position with a percentage of liquidity
     var partialPosition = new Position({
       pool: position.pool,
       liquidity: options.liquidityPercentage.multiply(position.liquidity).quotient,
       tickLower: position.tickLower,
-      tickUpper: position.tickUpper
-    });
-    !JSBI.greaterThan(partialPosition.liquidity, ZERO) ?  invariant(false, 'ZERO_LIQUIDITY')  : void 0;
+      tickUpper: position.tickUpper,
+    })
+    !JSBI.greaterThan(partialPosition.liquidity, ZERO) ? invariant(false, 'ZERO_LIQUIDITY') : void 0
     // slippage-adjusted underlying amounts
     var _partialPosition$burn = partialPosition.burnAmountsWithSlippage(options.slippageTolerance),
       amount0Min = _partialPosition$burn.amount0,
-      amount1Min = _partialPosition$burn.amount1;
+      amount1Min = _partialPosition$burn.amount1
     if (options.permit) {
-      calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('permit', [sdkCore.validateAndParseAddress(options.permit.spender), tokenId, toHex(options.permit.deadline), options.permit.v, options.permit.r, options.permit.s]));
+      calldatas.push(
+        NonfungiblePositionManager.INTERFACE.encodeFunctionData('permit', [
+          sdkCore.validateAndParseAddress(options.permit.spender),
+          tokenId,
+          toHex(options.permit.deadline),
+          options.permit.v,
+          options.permit.r,
+          options.permit.s,
+        ]),
+      )
     }
     // remove liquidity
-    calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('decreaseLiquidity', [{
-      tokenId: tokenId,
-      liquidity: toHex(partialPosition.liquidity),
-      amount0Min: toHex(amount0Min),
-      amount1Min: toHex(amount1Min),
-      deadline: deadline
-    }]));
+    calldatas.push(
+      NonfungiblePositionManager.INTERFACE.encodeFunctionData('decreaseLiquidity', [
+        {
+          tokenId: tokenId,
+          liquidity: toHex(partialPosition.liquidity),
+          amount0Min: toHex(amount0Min),
+          amount1Min: toHex(amount1Min),
+          deadline: deadline,
+        },
+      ]),
+    )
     var _options$collectOptio = options.collectOptions,
       expectedCurrencyOwed0 = _options$collectOptio.expectedCurrencyOwed0,
       expectedCurrencyOwed1 = _options$collectOptio.expectedCurrencyOwed1,
-      rest = _objectWithoutPropertiesLoose(_options$collectOptio, _excluded);
-    calldatas.push.apply(calldatas, NonfungiblePositionManager.encodeCollect(_extends({
-      tokenId: toHex(options.tokenId),
-      // add the underlying value to the expected currency already owed
-      expectedCurrencyOwed0: expectedCurrencyOwed0.add(sdkCore.CurrencyAmount.fromRawAmount(expectedCurrencyOwed0.currency, amount0Min)),
-      expectedCurrencyOwed1: expectedCurrencyOwed1.add(sdkCore.CurrencyAmount.fromRawAmount(expectedCurrencyOwed1.currency, amount1Min))
-    }, rest)));
+      rest = _objectWithoutPropertiesLoose(_options$collectOptio, _excluded)
+    calldatas.push.apply(
+      calldatas,
+      NonfungiblePositionManager.encodeCollect(
+        _extends(
+          {
+            tokenId: toHex(options.tokenId),
+            // add the underlying value to the expected currency already owed
+            expectedCurrencyOwed0: expectedCurrencyOwed0.add(
+              sdkCore.CurrencyAmount.fromRawAmount(expectedCurrencyOwed0.currency, amount0Min),
+            ),
+            expectedCurrencyOwed1: expectedCurrencyOwed1.add(
+              sdkCore.CurrencyAmount.fromRawAmount(expectedCurrencyOwed1.currency, amount1Min),
+            ),
+          },
+          rest,
+        ),
+      ),
+    )
     if (options.liquidityPercentage.equalTo(ONE)) {
       if (options.burnToken) {
-        calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('burn', [tokenId]));
+        calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('burn', [tokenId]))
       }
     } else {
-      !(options.burnToken !== true) ?  invariant(false, 'CANNOT_BURN')  : void 0;
+      !(options.burnToken !== true) ? invariant(false, 'CANNOT_BURN') : void 0
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
-  };
+      value: toHex(0),
+    }
+  }
   NonfungiblePositionManager.safeTransferFromParameters = function safeTransferFromParameters(options) {
-    var recipient = sdkCore.validateAndParseAddress(options.recipient);
-    var sender = sdkCore.validateAndParseAddress(options.sender);
-    var calldata;
+    var recipient = sdkCore.validateAndParseAddress(options.recipient)
+    var sender = sdkCore.validateAndParseAddress(options.sender)
+    var calldata
     if (options.data) {
-      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256,bytes)', [sender, recipient, toHex(options.tokenId), options.data]);
+      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData(
+        'safeTransferFrom(address,address,uint256,bytes)',
+        [sender, recipient, toHex(options.tokenId), options.data],
+      )
     } else {
-      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256)', [sender, recipient, toHex(options.tokenId)]);
+      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256)', [
+        sender,
+        recipient,
+        toHex(options.tokenId),
+      ])
     }
     return {
       calldata: calldata,
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   // Prepare the params for an EIP712 signTypedData request
-  ;
   NonfungiblePositionManager.getPermitData = function getPermitData(permit, positionManagerAddress, chainId) {
     return {
       domain: {
         name: 'Uniswap V3 Positions NFT-V1',
         chainId: chainId,
         version: '1',
-        verifyingContract: positionManagerAddress
+        verifyingContract: positionManagerAddress,
       },
       types: NFT_PERMIT_TYPES,
-      values: permit
-    };
-  };
-  return NonfungiblePositionManager;
-}();
-NonfungiblePositionManager.INTERFACE = /*#__PURE__*/new abi.Interface(INonfungiblePositionManager.abi);
+      values: permit,
+    }
+  }
+  return NonfungiblePositionManager
+})()
+NonfungiblePositionManager.INTERFACE = /*#__PURE__*/ new abi.Interface(INonfungiblePositionManager.abi)
 
 /**
  * Represents the Uniswap V3 QuoterV1 contract with a method for returning the formatted
  * calldata needed to call the quoter contract.
  */
-var SwapQuoter = /*#__PURE__*/function () {
+var SwapQuoter = /*#__PURE__*/ (function () {
   function SwapQuoter() {}
   /**
    * Produces the on-chain method name of the appropriate function within QuoterV2,
@@ -2934,46 +3760,68 @@ var SwapQuoter = /*#__PURE__*/function () {
    */
   SwapQuoter.quoteCallParameters = function quoteCallParameters(route, amount, tradeType, options) {
     if (options === void 0) {
-      options = {};
+      options = {}
     }
-    var singleHop = route.pools.length === 1;
-    var quoteAmount = toHex(amount.quotient);
-    var calldata;
-    var swapInterface = options.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE;
+    var singleHop = route.pools.length === 1
+    var quoteAmount = toHex(amount.quotient)
+    var calldata
+    var swapInterface = options.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE
     if (singleHop) {
-      var _options$sqrtPriceLim, _options;
+      var _options$sqrtPriceLim, _options
       var baseQuoteParams = {
         tokenIn: route.tokenPath[0].address,
         tokenOut: route.tokenPath[1].address,
         fee: route.pools[0].fee,
-        sqrtPriceLimitX96: toHex((_options$sqrtPriceLim = (_options = options) == null ? void 0 : _options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
-      };
-      var v2QuoteParams = _extends({}, baseQuoteParams, tradeType === sdkCore.TradeType.EXACT_INPUT ? {
-        amountIn: quoteAmount
-      } : {
-        amount: quoteAmount
-      });
-      var v1QuoteParams = [baseQuoteParams.tokenIn, baseQuoteParams.tokenOut, baseQuoteParams.fee, quoteAmount, baseQuoteParams.sqrtPriceLimitX96];
-      var tradeTypeFunctionName = tradeType === sdkCore.TradeType.EXACT_INPUT ? 'quoteExactInputSingle' : 'quoteExactOutputSingle';
-      calldata = swapInterface.encodeFunctionData(tradeTypeFunctionName, options.useQuoterV2 ? [v2QuoteParams] : v1QuoteParams);
+        sqrtPriceLimitX96: toHex(
+          (_options$sqrtPriceLim = (_options = options) == null ? void 0 : _options.sqrtPriceLimitX96) != null
+            ? _options$sqrtPriceLim
+            : 0,
+        ),
+      }
+      var v2QuoteParams = _extends(
+        {},
+        baseQuoteParams,
+        tradeType === sdkCore.TradeType.EXACT_INPUT
+          ? {
+              amountIn: quoteAmount,
+            }
+          : {
+              amount: quoteAmount,
+            },
+      )
+      var v1QuoteParams = [
+        baseQuoteParams.tokenIn,
+        baseQuoteParams.tokenOut,
+        baseQuoteParams.fee,
+        quoteAmount,
+        baseQuoteParams.sqrtPriceLimitX96,
+      ]
+      var tradeTypeFunctionName =
+        tradeType === sdkCore.TradeType.EXACT_INPUT ? 'quoteExactInputSingle' : 'quoteExactOutputSingle'
+      calldata = swapInterface.encodeFunctionData(
+        tradeTypeFunctionName,
+        options.useQuoterV2 ? [v2QuoteParams] : v1QuoteParams,
+      )
     } else {
-      var _options2;
-      !(((_options2 = options) == null ? void 0 : _options2.sqrtPriceLimitX96) === undefined) ?  invariant(false, 'MULTIHOP_PRICE_LIMIT')  : void 0;
-      var path = encodeRouteToPath(route, tradeType === sdkCore.TradeType.EXACT_OUTPUT);
-      var _tradeTypeFunctionName = tradeType === sdkCore.TradeType.EXACT_INPUT ? 'quoteExactInput' : 'quoteExactOutput';
-      calldata = swapInterface.encodeFunctionData(_tradeTypeFunctionName, [path, quoteAmount]);
+      var _options2
+      !(((_options2 = options) == null ? void 0 : _options2.sqrtPriceLimitX96) === undefined)
+        ? invariant(false, 'MULTIHOP_PRICE_LIMIT')
+        : void 0
+      var path = encodeRouteToPath(route, tradeType === sdkCore.TradeType.EXACT_OUTPUT)
+      var _tradeTypeFunctionName = tradeType === sdkCore.TradeType.EXACT_INPUT ? 'quoteExactInput' : 'quoteExactOutput'
+      calldata = swapInterface.encodeFunctionData(_tradeTypeFunctionName, [path, quoteAmount])
     }
     return {
       calldata: calldata,
-      value: toHex(0)
-    };
-  };
-  return SwapQuoter;
-}();
-SwapQuoter.V1INTERFACE = /*#__PURE__*/new abi.Interface(IQuoter.abi);
-SwapQuoter.V2INTERFACE = /*#__PURE__*/new abi.Interface(IQuoterV2.abi);
+      value: toHex(0),
+    }
+  }
+  return SwapQuoter
+})()
+SwapQuoter.V1INTERFACE = /*#__PURE__*/ new abi.Interface(IQuoter.abi)
+SwapQuoter.V2INTERFACE = /*#__PURE__*/ new abi.Interface(IQuoterV2.abi)
 
-var Staker = /*#__PURE__*/function () {
+var Staker = /*#__PURE__*/ (function () {
   function Staker() {}
   /**
    *  To claim rewards, must unstake and then claim.
@@ -2982,13 +3830,20 @@ var Staker = /*#__PURE__*/function () {
    * @returns The calldatas for 'unstakeToken' and 'claimReward'.
    */
   Staker.encodeClaim = function encodeClaim(incentiveKey, options) {
-    var _options$amount;
-    var calldatas = [];
-    calldatas.push(Staker.INTERFACE.encodeFunctionData('unstakeToken', [this._encodeIncentiveKey(incentiveKey), toHex(options.tokenId)]));
-    var recipient = sdkCore.validateAndParseAddress(options.recipient);
-    var amount = (_options$amount = options.amount) != null ? _options$amount : 0;
-    calldatas.push(Staker.INTERFACE.encodeFunctionData('claimReward', [incentiveKey.rewardToken.address, recipient, toHex(amount)]));
-    return calldatas;
+    var _options$amount
+    var calldatas = []
+    calldatas.push(
+      Staker.INTERFACE.encodeFunctionData('unstakeToken', [
+        this._encodeIncentiveKey(incentiveKey),
+        toHex(options.tokenId),
+      ]),
+    )
+    var recipient = sdkCore.validateAndParseAddress(options.recipient)
+    var amount = (_options$amount = options.amount) != null ? _options$amount : 0
+    calldatas.push(
+      Staker.INTERFACE.encodeFunctionData('claimReward', [incentiveKey.rewardToken.address, recipient, toHex(amount)]),
+    )
+    return calldatas
   }
   /**
    *
@@ -2998,96 +3853,108 @@ var Staker = /*#__PURE__*/function () {
    * @param options ClaimOptions to specify tokenId, recipient, and amount wanting to collect.
    * Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once.
    * @returns
-   */;
+   */
   Staker.collectRewards = function collectRewards(incentiveKeys, options) {
-    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
-    var calldatas = [];
+    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys]
+    var calldatas = []
     for (var i = 0; i < incentiveKeys.length; i++) {
       // the unique program tokenId is staked in
-      var incentiveKey = incentiveKeys[i];
+      var incentiveKey = incentiveKeys[i]
       // unstakes and claims for the unique program
-      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options));
+      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options))
       // re-stakes the position for the unique program
-      calldatas.push(Staker.INTERFACE.encodeFunctionData('stakeToken', [this._encodeIncentiveKey(incentiveKey), toHex(options.tokenId)]));
+      calldatas.push(
+        Staker.INTERFACE.encodeFunctionData('stakeToken', [
+          this._encodeIncentiveKey(incentiveKey),
+          toHex(options.tokenId),
+        ]),
+      )
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   /**
    *
    * @param incentiveKeys A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in.
    * @param withdrawOptions Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`.
    * @returns Calldata for unstaking, claiming, and withdrawing.
-   */;
+   */
   Staker.withdrawToken = function withdrawToken(incentiveKeys, withdrawOptions) {
-    var calldatas = [];
-    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
+    var calldatas = []
+    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys]
     var claimOptions = {
       tokenId: withdrawOptions.tokenId,
       recipient: withdrawOptions.recipient,
-      amount: withdrawOptions.amount
-    };
+      amount: withdrawOptions.amount,
+    }
     for (var i = 0; i < incentiveKeys.length; i++) {
-      var incentiveKey = incentiveKeys[i];
-      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, claimOptions));
+      var incentiveKey = incentiveKeys[i]
+      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, claimOptions))
     }
-    var owner = sdkCore.validateAndParseAddress(withdrawOptions.owner);
-    calldatas.push(Staker.INTERFACE.encodeFunctionData('withdrawToken', [toHex(withdrawOptions.tokenId), owner, withdrawOptions.data ? withdrawOptions.data : toHex(0)]));
+    var owner = sdkCore.validateAndParseAddress(withdrawOptions.owner)
+    calldatas.push(
+      Staker.INTERFACE.encodeFunctionData('withdrawToken', [
+        toHex(withdrawOptions.tokenId),
+        owner,
+        withdrawOptions.data ? withdrawOptions.data : toHex(0),
+      ]),
+    )
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   /**
    *
    * @param incentiveKeys A single IncentiveKey or array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom`
    * @returns An IncentiveKey as a string
-   */;
+   */
   Staker.encodeDeposit = function encodeDeposit(incentiveKeys) {
-    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
-    var data;
+    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys]
+    var data
     if (incentiveKeys.length > 1) {
-      var keys = [];
+      var keys = []
       for (var i = 0; i < incentiveKeys.length; i++) {
-        var incentiveKey = incentiveKeys[i];
-        keys.push(this._encodeIncentiveKey(incentiveKey));
+        var incentiveKey = incentiveKeys[i]
+        keys.push(this._encodeIncentiveKey(incentiveKey))
       }
-      data = abi.defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI + "[]"], [keys]);
+      data = abi.defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI + '[]'], [keys])
     } else {
-      data = abi.defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(incentiveKeys[0])]);
+      data = abi.defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(incentiveKeys[0])])
     }
-    return data;
+    return data
   }
   /**
    *
    * @param incentiveKey An `IncentiveKey` which represents a unique staking program.
    * @returns An encoded IncentiveKey to be read by ethers
-   */;
+   */
   Staker._encodeIncentiveKey = function _encodeIncentiveKey(incentiveKey) {
     var _incentiveKey$pool = incentiveKey.pool,
       token0 = _incentiveKey$pool.token0,
       token1 = _incentiveKey$pool.token1,
-      fee = _incentiveKey$pool.fee;
-    var refundee = sdkCore.validateAndParseAddress(incentiveKey.refundee);
+      fee = _incentiveKey$pool.fee
+    var refundee = sdkCore.validateAndParseAddress(incentiveKey.refundee)
     return {
       rewardToken: incentiveKey.rewardToken.address,
       pool: Pool.getAddress(token0, token1, fee),
       startTime: toHex(incentiveKey.startTime),
       endTime: toHex(incentiveKey.endTime),
-      refundee: refundee
-    };
-  };
-  return Staker;
-}();
-Staker.INTERFACE = /*#__PURE__*/new abi.Interface(IUniswapV3Staker.abi);
-Staker.INCENTIVE_KEY_ABI = 'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)';
+      refundee: refundee,
+    }
+  }
+  return Staker
+})()
+Staker.INTERFACE = /*#__PURE__*/ new abi.Interface(IUniswapV3Staker.abi)
+Staker.INCENTIVE_KEY_ABI =
+  'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)'
 
 /**
  * Represents the Uniswap V3 SwapRouter, and has static methods for helping execute trades.
  */
-var SwapRouter = /*#__PURE__*/function () {
+var SwapRouter = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
@@ -3099,54 +3966,61 @@ var SwapRouter = /*#__PURE__*/function () {
    */
   SwapRouter.swapCallParameters = function swapCallParameters(trades, options) {
     if (!Array.isArray(trades)) {
-      trades = [trades];
+      trades = [trades]
     }
-    var sampleTrade = trades[0];
-    var tokenIn = sampleTrade.inputAmount.currency.wrapped;
-    var tokenOut = sampleTrade.outputAmount.currency.wrapped;
+    var sampleTrade = trades[0]
+    var tokenIn = sampleTrade.inputAmount.currency.wrapped
+    var tokenOut = sampleTrade.outputAmount.currency.wrapped
     // All trades should have the same starting and ending token.
     !trades.every(function (trade) {
-      return trade.inputAmount.currency.wrapped.equals(tokenIn);
-    }) ?  invariant(false, 'TOKEN_IN_DIFF')  : void 0;
+      return trade.inputAmount.currency.wrapped.equals(tokenIn)
+    })
+      ? invariant(false, 'TOKEN_IN_DIFF')
+      : void 0
     !trades.every(function (trade) {
-      return trade.outputAmount.currency.wrapped.equals(tokenOut);
-    }) ?  invariant(false, 'TOKEN_OUT_DIFF')  : void 0;
-    var calldatas = [];
-    var ZERO_IN = sdkCore.CurrencyAmount.fromRawAmount(trades[0].inputAmount.currency, 0);
-    var ZERO_OUT = sdkCore.CurrencyAmount.fromRawAmount(trades[0].outputAmount.currency, 0);
+      return trade.outputAmount.currency.wrapped.equals(tokenOut)
+    })
+      ? invariant(false, 'TOKEN_OUT_DIFF')
+      : void 0
+    var calldatas = []
+    var ZERO_IN = sdkCore.CurrencyAmount.fromRawAmount(trades[0].inputAmount.currency, 0)
+    var ZERO_OUT = sdkCore.CurrencyAmount.fromRawAmount(trades[0].outputAmount.currency, 0)
     var totalAmountOut = trades.reduce(function (sum, trade) {
-      return sum.add(trade.minimumAmountOut(options.slippageTolerance));
-    }, ZERO_OUT);
+      return sum.add(trade.minimumAmountOut(options.slippageTolerance))
+    }, ZERO_OUT)
     // flag for whether a refund needs to happen
-    var mustRefund = sampleTrade.inputAmount.currency.isNative && sampleTrade.tradeType === sdkCore.TradeType.EXACT_OUTPUT;
-    var inputIsNative = sampleTrade.inputAmount.currency.isNative;
+    var mustRefund =
+      sampleTrade.inputAmount.currency.isNative && sampleTrade.tradeType === sdkCore.TradeType.EXACT_OUTPUT
+    var inputIsNative = sampleTrade.inputAmount.currency.isNative
     // flags for whether funds should be send first to the router
-    var outputIsNative = sampleTrade.outputAmount.currency.isNative;
-    var routerMustCustody = outputIsNative || !!options.fee;
-    var totalValue = inputIsNative ? trades.reduce(function (sum, trade) {
-      return sum.add(trade.maximumAmountIn(options.slippageTolerance));
-    }, ZERO_IN) : ZERO_IN;
+    var outputIsNative = sampleTrade.outputAmount.currency.isNative
+    var routerMustCustody = outputIsNative || !!options.fee
+    var totalValue = inputIsNative
+      ? trades.reduce(function (sum, trade) {
+          return sum.add(trade.maximumAmountIn(options.slippageTolerance))
+        }, ZERO_IN)
+      : ZERO_IN
     // encode permit if necessary
     if (options.inputTokenPermit) {
-      !sampleTrade.inputAmount.currency.isToken ?  invariant(false, 'NON_TOKEN_PERMIT')  : void 0;
-      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));
-    }
-    var recipient = sdkCore.validateAndParseAddress(options.recipient);
-    var deadline = toHex(options.deadline);
-    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done;) {
-      var trade = _step.value;
-      for (var _iterator2 = _createForOfIteratorHelperLoose(trade.swaps), _step2; !(_step2 = _iterator2()).done;) {
+      !sampleTrade.inputAmount.currency.isToken ? invariant(false, 'NON_TOKEN_PERMIT') : void 0
+      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))
+    }
+    var recipient = sdkCore.validateAndParseAddress(options.recipient)
+    var deadline = toHex(options.deadline)
+    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done; ) {
+      var trade = _step.value
+      for (var _iterator2 = _createForOfIteratorHelperLoose(trade.swaps), _step2; !(_step2 = _iterator2()).done; ) {
         var _step2$value = _step2.value,
           route = _step2$value.route,
           inputAmount = _step2$value.inputAmount,
-          outputAmount = _step2$value.outputAmount;
-        var amountIn = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);
-        var amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient);
+          outputAmount = _step2$value.outputAmount
+        var amountIn = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)
+        var amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)
         // flag for whether the trade is single hop or not
-        var singleHop = route.pools.length === 1;
+        var singleHop = route.pools.length === 1
         if (singleHop) {
           if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {
-            var _options$sqrtPriceLim;
+            var _options$sqrtPriceLim
             var exactInputSingleParams = {
               tokenIn: route.tokenPath[0].address,
               tokenOut: route.tokenPath[1].address,
@@ -3155,11 +4029,13 @@ var SwapRouter = /*#__PURE__*/function () {
               deadline: deadline,
               amountIn: amountIn,
               amountOutMinimum: amountOut,
-              sqrtPriceLimitX96: toHex((_options$sqrtPriceLim = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]));
+              sqrtPriceLimitX96: toHex(
+                (_options$sqrtPriceLim = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0,
+              ),
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))
           } else {
-            var _options$sqrtPriceLim2;
+            var _options$sqrtPriceLim2
             var exactOutputSingleParams = {
               tokenIn: route.tokenPath[0].address,
               tokenOut: route.tokenPath[1].address,
@@ -3168,31 +4044,33 @@ var SwapRouter = /*#__PURE__*/function () {
               deadline: deadline,
               amountOut: amountOut,
               amountInMaximum: amountIn,
-              sqrtPriceLimitX96: toHex((_options$sqrtPriceLim2 = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim2 : 0)
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]));
+              sqrtPriceLimitX96: toHex(
+                (_options$sqrtPriceLim2 = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim2 : 0,
+              ),
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))
           }
         } else {
-          !(options.sqrtPriceLimitX96 === undefined) ?  invariant(false, 'MULTIHOP_PRICE_LIMIT')  : void 0;
-          var path = encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);
+          !(options.sqrtPriceLimitX96 === undefined) ? invariant(false, 'MULTIHOP_PRICE_LIMIT') : void 0
+          var path = encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT)
           if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {
             var exactInputParams = {
               path: path,
               recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
               deadline: deadline,
               amountIn: amountIn,
-              amountOutMinimum: amountOut
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]));
+              amountOutMinimum: amountOut,
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))
           } else {
             var exactOutputParams = {
               path: path,
               recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
               deadline: deadline,
               amountOut: amountOut,
-              amountInMaximum: amountIn
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]));
+              amountInMaximum: amountIn,
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))
           }
         }
       }
@@ -3201,65 +4079,72 @@ var SwapRouter = /*#__PURE__*/function () {
     if (routerMustCustody) {
       if (!!options.fee) {
         if (outputIsNative) {
-          calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient, options.fee));
+          calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient, options.fee))
         } else {
-          calldatas.push(Payments.encodeSweepToken(sampleTrade.outputAmount.currency.wrapped, totalAmountOut.quotient, recipient, options.fee));
+          calldatas.push(
+            Payments.encodeSweepToken(
+              sampleTrade.outputAmount.currency.wrapped,
+              totalAmountOut.quotient,
+              recipient,
+              options.fee,
+            ),
+          )
         }
       } else {
-        calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient));
+        calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient))
       }
     }
     // refund
     if (mustRefund) {
-      calldatas.push(Payments.encodeRefundETH());
+      calldatas.push(Payments.encodeRefundETH())
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(totalValue.quotient)
-    };
-  };
-  return SwapRouter;
-}();
-SwapRouter.INTERFACE = /*#__PURE__*/new abi.Interface(ISwapRouter.abi);
+      value: toHex(totalValue.quotient),
+    }
+  }
+  return SwapRouter
+})()
+SwapRouter.INTERFACE = /*#__PURE__*/ new abi.Interface(ISwapRouter.abi)
 
-exports.ADDRESS_ZERO = ADDRESS_ZERO;
-exports.FACTORY_ADDRESS = FACTORY_ADDRESS;
-exports.FullMath = FullMath;
-exports.LiquidityMath = LiquidityMath;
-exports.Multicall = Multicall;
-exports.NoTickDataProvider = NoTickDataProvider;
-exports.NonfungiblePositionManager = NonfungiblePositionManager;
-exports.POOL_INIT_CODE_HASH = POOL_INIT_CODE_HASH;
-exports.Payments = Payments;
-exports.Pool = Pool;
-exports.Position = Position;
-exports.PositionLibrary = PositionLibrary;
-exports.Route = Route;
-exports.SelfPermit = SelfPermit;
-exports.SqrtPriceMath = SqrtPriceMath;
-exports.Staker = Staker;
-exports.SwapMath = SwapMath;
-exports.SwapQuoter = SwapQuoter;
-exports.SwapRouter = SwapRouter;
-exports.TICK_SPACINGS = TICK_SPACINGS;
-exports.Tick = Tick;
-exports.TickLibrary = TickLibrary;
-exports.TickList = TickList;
-exports.TickListDataProvider = TickListDataProvider;
-exports.TickMath = TickMath;
-exports.Trade = Trade;
-exports.computePoolAddress = computePoolAddress;
-exports.encodeRouteToPath = encodeRouteToPath;
-exports.encodeSqrtRatioX96 = encodeSqrtRatioX96;
-exports.isSorted = isSorted;
-exports.maxLiquidityForAmounts = maxLiquidityForAmounts;
-exports.mostSignificantBit = mostSignificantBit;
-exports.nearestUsableTick = nearestUsableTick;
-exports.poolInitCodeHash = poolInitCodeHash;
-exports.priceToClosestTick = priceToClosestTick;
-exports.subIn256 = subIn256;
-exports.tickToPrice = tickToPrice;
-exports.toHex = toHex;
-exports.tradeComparator = tradeComparator;
-exports.v3Swap = v3Swap;
+exports.ADDRESS_ZERO = ADDRESS_ZERO
+exports.FACTORY_ADDRESS = FACTORY_ADDRESS
+exports.FullMath = FullMath
+exports.LiquidityMath = LiquidityMath
+exports.Multicall = Multicall
+exports.NoTickDataProvider = NoTickDataProvider
+exports.NonfungiblePositionManager = NonfungiblePositionManager
+exports.POOL_INIT_CODE_HASH = POOL_INIT_CODE_HASH
+exports.Payments = Payments
+exports.Pool = Pool
+exports.Position = Position
+exports.PositionLibrary = PositionLibrary
+exports.Route = Route
+exports.SelfPermit = SelfPermit
+exports.SqrtPriceMath = SqrtPriceMath
+exports.Staker = Staker
+exports.SwapMath = SwapMath
+exports.SwapQuoter = SwapQuoter
+exports.SwapRouter = SwapRouter
+exports.TICK_SPACINGS = TICK_SPACINGS
+exports.Tick = Tick
+exports.TickLibrary = TickLibrary
+exports.TickList = TickList
+exports.TickListDataProvider = TickListDataProvider
+exports.TickMath = TickMath
+exports.Trade = Trade
+exports.computePoolAddress = computePoolAddress
+exports.encodeRouteToPath = encodeRouteToPath
+exports.encodeSqrtRatioX96 = encodeSqrtRatioX96
+exports.isSorted = isSorted
+exports.maxLiquidityForAmounts = maxLiquidityForAmounts
+exports.mostSignificantBit = mostSignificantBit
+exports.nearestUsableTick = nearestUsableTick
+exports.poolInitCodeHash = poolInitCodeHash
+exports.priceToClosestTick = priceToClosestTick
+exports.subIn256 = subIn256
+exports.tickToPrice = tickToPrice
+exports.toHex = toHex
+exports.tradeComparator = tradeComparator
+exports.v3Swap = v3Swap
 //# sourceMappingURL=v3-sdk.cjs.development.js.map
diff --git a/dist/v3-sdk.cjs.production.min.js b/dist/v3-sdk.cjs.production.min.js
index 7765333b2537808347334f7c0177640bf1a6ee65..0a856fdf98656edaf4c9f58b4ac347b90fd007ca 100644
--- a/dist/v3-sdk.cjs.production.min.js
+++ b/dist/v3-sdk.cjs.production.min.js
@@ -1,2 +1,2576 @@
-"use strict";function t(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var e,n=require("@uniswap/sdk-core"),r=t(require("jsbi")),i=t(require("tiny-invariant")),o=require("@ethersproject/abi"),a=require("@ethersproject/address"),u=require("@ethersproject/solidity"),c=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json")),s=t(require("@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json")),p=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json")),l=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json")),d=t(require("@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json")),f=t(require("@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json")),m=t(require("@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json")),h=t(require("@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json"));function v(){v=function(){return e};var t,e={},n=Object.prototype,r=n.hasOwnProperty,i=Object.defineProperty||function(t,e,n){t[e]=n.value},o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",u=o.asyncIterator||"@@asyncIterator",c=o.toStringTag||"@@toStringTag";function s(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,n){return t[e]=n}}function p(t,e,n,r){var o=Object.create((e&&e.prototype instanceof y?e:y).prototype),a=new C(r||[]);return i(o,"_invoke",{value:b(t,n,a)}),o}function l(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(t){return{type:"throw",arg:t}}}e.wrap=p;var d="suspendedStart",f="executing",m="completed",h={};function y(){}function k(){}function g(){}var A={};s(A,a,(function(){return this}));var T=Object.getPrototypeOf,w=T&&T(T(O([])));w&&w!==n&&r.call(w,a)&&(A=w);var x=g.prototype=y.prototype=Object.create(A);function I(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function q(t,e){function n(i,o,a,u){var c=l(t[i],t,o);if("throw"!==c.type){var s=c.arg,p=s.value;return p&&"object"==typeof p&&r.call(p,"__await")?e.resolve(p.__await).then((function(t){n("next",t,a,u)}),(function(t){n("throw",t,a,u)})):e.resolve(p).then((function(t){s.value=t,a(s)}),(function(t){return n("throw",t,a,u)}))}u(c.arg)}var o;i(this,"_invoke",{value:function(t,r){function i(){return new e((function(e,i){n(t,r,e,i)}))}return o=o?o.then(i,i):i()}})}function b(e,n,r){var i=d;return function(o,a){if(i===f)throw new Error("Generator is already running");if(i===m){if("throw"===o)throw a;return{value:t,done:!0}}for(r.method=o,r.arg=a;;){var u=r.delegate;if(u){var c=R(u,r);if(c){if(c===h)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(i===d)throw i=m,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);i=f;var s=l(e,n,r);if("normal"===s.type){if(i=r.done?m:"suspendedYield",s.arg===h)continue;return{value:s.arg,done:r.done}}"throw"===s.type&&(i=m,r.method="throw",r.arg=s.arg)}}}function R(e,n){var r=n.method,i=e.iterator[r];if(i===t)return n.delegate=null,"throw"===r&&e.iterator.return&&(n.method="return",n.arg=t,R(e,n),"throw"===n.method)||"return"!==r&&(n.method="throw",n.arg=new TypeError("The iterator does not provide a '"+r+"' method")),h;var o=l(i,e.iterator,n.arg);if("throw"===o.type)return n.method="throw",n.arg=o.arg,n.delegate=null,h;var a=o.arg;return a?a.done?(n[e.resultName]=a.value,n.next=e.nextLoc,"return"!==n.method&&(n.method="next",n.arg=t),n.delegate=null,h):a:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,h)}function E(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function P(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function C(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(E,this),this.reset(!0)}function O(e){if(e||""===e){var n=e[a];if(n)return n.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function n(){for(;++i<e.length;)if(r.call(e,i))return n.value=e[i],n.done=!1,n;return n.value=t,n.done=!0,n};return o.next=o}}throw new TypeError(typeof e+" is not iterable")}return k.prototype=g,i(x,"constructor",{value:g,configurable:!0}),i(g,"constructor",{value:k,configurable:!0}),k.displayName=s(g,c,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===k||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,g):(t.__proto__=g,s(t,c,"GeneratorFunction")),t.prototype=Object.create(x),t},e.awrap=function(t){return{__await:t}},I(q.prototype),s(q.prototype,u,(function(){return this})),e.AsyncIterator=q,e.async=function(t,n,r,i,o){void 0===o&&(o=Promise);var a=new q(p(t,n,r,i),o);return e.isGeneratorFunction(n)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},I(x),s(x,c,"Generator"),s(x,a,(function(){return this})),s(x,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),n=[];for(var r in e)n.push(r);return n.reverse(),function t(){for(;n.length;){var r=n.pop();if(r in e)return t.value=r,t.done=!1,t}return t.done=!0,t}},e.values=O,C.prototype={constructor:C,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(P),!e)for(var n in this)"t"===n.charAt(0)&&r.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function i(r,i){return u.type="throw",u.arg=e,n.next=r,i&&(n.method="next",n.arg=t),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],u=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var c=r.call(a,"catchLoc"),s=r.call(a,"finallyLoc");if(c&&s){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,h):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),h},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),P(n),h}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var r=n.completion;if("throw"===r.type){var i=r.arg;P(n)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,n,r){return this.delegate={iterator:O(e),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=t),h}},e}function y(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,"string");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==typeof e?e:String(e)}function k(t,e,n,r,i,o,a){try{var u=t[o](a),c=u.value}catch(t){return void n(t)}u.done?e(c):Promise.resolve(c).then(r,i)}function g(t){return function(){var e=this,n=arguments;return new Promise((function(r,i){var o=t.apply(e,n);function a(t){k(o,r,i,a,u,"next",t)}function u(t){k(o,r,i,a,u,"throw",t)}a(void 0)}))}}function A(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,y(r.key),r)}}function T(t,e,n){return e&&A(t.prototype,e),n&&A(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function w(){return(w=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}function x(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function I(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(n)return(n=n.call(t)).next.bind(n);if(Array.isArray(t)||(n=function(t,e){if(t){if("string"==typeof t)return x(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?x(t,void 0):void 0}}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var q,b="0x0000000000000000000000000000000000000000",R="0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54";function E(t){switch(t){case n.ChainId.ZKSYNC:return"0x010013f177ea1fcbc4520f9a3ca7cd2d1d77959e05aa66484027cb38e712aeed";default:return R}}(q=exports.FeeAmount||(exports.FeeAmount={}))[q.LOWEST=100]="LOWEST",q[q.LOW_200=200]="LOW_200",q[q.LOW_300=300]="LOW_300",q[q.LOW_400=400]="LOW_400",q[q.LOW=500]="LOW",q[q.MEDIUM=3e3]="MEDIUM",q[q.HIGH=1e4]="HIGH";var P=((e={})[exports.FeeAmount.LOWEST]=1,e[exports.FeeAmount.LOW_200]=4,e[exports.FeeAmount.LOW_300]=6,e[exports.FeeAmount.LOW_400]=8,e[exports.FeeAmount.LOW]=10,e[exports.FeeAmount.MEDIUM]=60,e[exports.FeeAmount.HIGH]=200,e),C=r.BigInt(-1),O=r.BigInt(0),S=r.BigInt(1),N=r.exponentiate(r.BigInt(2),r.BigInt(96)),_=r.exponentiate(N,r.BigInt(2));function F(t){var e=t.factoryAddress,r=t.tokenA,i=t.tokenB,c=t.fee,s=t.initCodeHashManualOverride,p=t.chainId,l=r.sortsBefore(i)?[r,i]:[i,r],d=u.keccak256(["bytes"],[o.defaultAbiCoder.encode(["address","address","uint24"],[l[0].address,l[1].address,c])]),f=null!=s?s:E(p);switch(p){case n.ChainId.ZKSYNC:return n.computeZksyncCreate2Address(e,f,d);default:return a.getCreate2Address(e,d,f)}}var L=function(){function t(){}return t.mulDivRoundingUp=function(t,e,n){var i=r.multiply(t,e),o=r.divide(i,n);return r.notEqual(r.remainder(i,n),O)&&(o=r.add(o,S)),o},t}(),X=r.subtract(r.exponentiate(r.BigInt(2),r.BigInt(160)),S);function U(t,e){var i=r.multiply(t,e);return r.bitwiseAnd(i,n.MaxUint256)}var M=function(){function t(){}return t.getAmount0Delta=function(t,e,n,i){if(r.greaterThan(t,e)){var o=[e,t];t=o[0],e=o[1]}var a=r.leftShift(n,r.BigInt(96)),u=r.subtract(e,t);return i?L.mulDivRoundingUp(L.mulDivRoundingUp(a,u,e),S,t):r.divide(r.divide(r.multiply(a,u),e),t)},t.getAmount1Delta=function(t,e,n,i){if(r.greaterThan(t,e)){var o=[e,t];t=o[0],e=o[1]}return i?L.mulDivRoundingUp(n,r.subtract(e,t),N):r.divide(r.multiply(n,r.subtract(e,t)),N)},t.getNextSqrtPriceFromInput=function(t,e,n,o){return r.greaterThan(t,O)||i(!1),r.greaterThan(e,O)||i(!1),o?this.getNextSqrtPriceFromAmount0RoundingUp(t,e,n,!0):this.getNextSqrtPriceFromAmount1RoundingDown(t,e,n,!0)},t.getNextSqrtPriceFromOutput=function(t,e,n,o){return r.greaterThan(t,O)||i(!1),r.greaterThan(e,O)||i(!1),o?this.getNextSqrtPriceFromAmount1RoundingDown(t,e,n,!1):this.getNextSqrtPriceFromAmount0RoundingUp(t,e,n,!1)},t.getNextSqrtPriceFromAmount0RoundingUp=function(t,e,o,a){if(r.equal(o,O))return t;var u=r.leftShift(e,r.BigInt(96));if(a){var c=U(o,t);if(r.equal(r.divide(c,o),t)){var s=(l=r.add(u,c),r.bitwiseAnd(l,n.MaxUint256));if(r.greaterThanOrEqual(s,u))return L.mulDivRoundingUp(u,t,s)}return L.mulDivRoundingUp(u,S,r.add(r.divide(u,t),o))}var p=U(o,t);r.equal(r.divide(p,o),t)||i(!1),r.greaterThan(u,p)||i(!1);var l,d=r.subtract(u,p);return L.mulDivRoundingUp(u,t,d)},t.getNextSqrtPriceFromAmount1RoundingDown=function(t,e,n,o){if(o){var a=r.lessThanOrEqual(n,X)?r.divide(r.leftShift(n,r.BigInt(96)),e):r.divide(r.multiply(n,N),e);return r.add(t,a)}var u=L.mulDivRoundingUp(n,N,e);return r.greaterThan(t,u)||i(!1),r.subtract(t,u)},t}(),B=r.exponentiate(r.BigInt(10),r.BigInt(6)),D=function(){function t(){}return t.computeSwapStep=function(t,e,n,i,o){var a={};o=r.BigInt(o);var u=r.greaterThanOrEqual(t,e),c=r.greaterThanOrEqual(i,O);if(c){var s=r.divide(r.multiply(i,r.subtract(B,o)),B);a.amountIn=u?M.getAmount0Delta(e,t,n,!0):M.getAmount1Delta(t,e,n,!0),a.sqrtRatioNextX96=r.greaterThanOrEqual(s,a.amountIn)?e:M.getNextSqrtPriceFromInput(t,n,s,u)}else a.amountOut=u?M.getAmount1Delta(e,t,n,!1):M.getAmount0Delta(t,e,n,!1),a.sqrtRatioNextX96=r.greaterThanOrEqual(r.multiply(i,C),a.amountOut)?e:M.getNextSqrtPriceFromOutput(t,n,r.multiply(i,C),u);var p=r.equal(e,a.sqrtRatioNextX96);return u?(a.amountIn=p&&c?a.amountIn:M.getAmount0Delta(a.sqrtRatioNextX96,t,n,!0),a.amountOut=p&&!c?a.amountOut:M.getAmount1Delta(a.sqrtRatioNextX96,t,n,!1)):(a.amountIn=p&&c?a.amountIn:M.getAmount1Delta(t,a.sqrtRatioNextX96,n,!0),a.amountOut=p&&!c?a.amountOut:M.getAmount0Delta(t,a.sqrtRatioNextX96,n,!1)),!c&&r.greaterThan(a.amountOut,r.multiply(i,C))&&(a.amountOut=r.multiply(i,C)),a.feeAmount=c&&r.notEqual(a.sqrtRatioNextX96,e)?r.subtract(i,a.amountIn):L.mulDivRoundingUp(a.amountIn,o,r.subtract(B,o)),[a.sqrtRatioNextX96,a.amountIn,a.amountOut,a.feeAmount]},t}(),W=function(){function t(){}return t.addDelta=function(t,e){return r.lessThan(e,O)?r.subtract(t,r.multiply(e,C)):r.add(t,e)},t}(),j=r.BigInt(2),K=[128,64,32,16,8,4,2,1].map((function(t){return[t,r.exponentiate(j,r.BigInt(t))]}));function G(t){r.greaterThan(t,O)||i(!1),r.lessThanOrEqual(t,n.MaxUint256)||i(!1);for(var e,o=0,a=I(K);!(e=a()).done;){var u=e.value,c=u[0];r.greaterThanOrEqual(t,u[1])&&(t=r.signedRightShift(t,r.BigInt(c)),o+=c)}return o}function H(t,e){return r.signedRightShift(r.multiply(t,r.BigInt(e)),r.BigInt(128))}var Q=r.exponentiate(r.BigInt(2),r.BigInt(32)),V=function(){function t(){}return t.getSqrtRatioAtTick=function(e){e>=t.MIN_TICK&&e<=t.MAX_TICK&&Number.isInteger(e)||i(!1);var o=e<0?-1*e:e,a=r.BigInt(0!=(1&o)?"0xfffcb933bd6fad37aa2d162d1a594001":"0x100000000000000000000000000000000");return 0!=(2&o)&&(a=H(a,"0xfff97272373d413259a46990580e213a")),0!=(4&o)&&(a=H(a,"0xfff2e50f5f656932ef12357cf3c7fdcc")),0!=(8&o)&&(a=H(a,"0xffe5caca7e10e4e61c3624eaa0941cd0")),0!=(16&o)&&(a=H(a,"0xffcb9843d60f6159c9db58835c926644")),0!=(32&o)&&(a=H(a,"0xff973b41fa98c081472e6896dfb254c0")),0!=(64&o)&&(a=H(a,"0xff2ea16466c96a3843ec78b326b52861")),0!=(128&o)&&(a=H(a,"0xfe5dee046a99a2a811c461f1969c3053")),0!=(256&o)&&(a=H(a,"0xfcbe86c7900a88aedcffc83b479aa3a4")),0!=(512&o)&&(a=H(a,"0xf987a7253ac413176f2b074cf7815e54")),0!=(1024&o)&&(a=H(a,"0xf3392b0822b70005940c7a398e4b70f3")),0!=(2048&o)&&(a=H(a,"0xe7159475a2c29b7443b29c7fa6e889d9")),0!=(4096&o)&&(a=H(a,"0xd097f3bdfd2022b8845ad8f792aa5825")),0!=(8192&o)&&(a=H(a,"0xa9f746462d870fdf8a65dc1f90e061e5")),0!=(16384&o)&&(a=H(a,"0x70d869a156d2a1b890bb3df62baf32f7")),0!=(32768&o)&&(a=H(a,"0x31be135f97d08fd981231505542fcfa6")),0!=(65536&o)&&(a=H(a,"0x9aa508b5b7a84e1c677de54f3e99bc9")),0!=(131072&o)&&(a=H(a,"0x5d6af8dedb81196699c329225ee604")),0!=(262144&o)&&(a=H(a,"0x2216e584f5fa1ea926041bedfe98")),0!=(524288&o)&&(a=H(a,"0x48a170391f7dc42444e8fa2")),e>0&&(a=r.divide(n.MaxUint256,a)),r.greaterThan(r.remainder(a,Q),O)?r.add(r.divide(a,Q),S):r.divide(a,Q)},t.getTickAtSqrtRatio=function(e){r.greaterThanOrEqual(e,t.MIN_SQRT_RATIO)&&r.lessThan(e,t.MAX_SQRT_RATIO)||i(!1);var n,o=r.leftShift(e,r.BigInt(32)),a=G(o);n=r.greaterThanOrEqual(r.BigInt(a),r.BigInt(128))?r.signedRightShift(o,r.BigInt(a-127)):r.leftShift(o,r.BigInt(127-a));for(var u=r.leftShift(r.subtract(r.BigInt(a),r.BigInt(128)),r.BigInt(64)),c=0;c<14;c++){n=r.signedRightShift(r.multiply(n,n),r.BigInt(127));var s=r.signedRightShift(n,r.BigInt(128));u=r.bitwiseOr(u,r.leftShift(s,r.BigInt(63-c))),n=r.signedRightShift(n,s)}var p=r.multiply(u,r.BigInt("255738958999603826347141")),l=r.toNumber(r.signedRightShift(r.subtract(p,r.BigInt("3402992956809132418596140100660247210")),r.BigInt(128))),d=r.toNumber(r.signedRightShift(r.add(p,r.BigInt("291339464771989622907027621153398088495")),r.BigInt(128)));return l===d?l:r.lessThanOrEqual(t.getSqrtRatioAtTick(d),e)?d:l},t}();function z(t,e,n,r,i,o,a,u,c){return Y.apply(this,arguments)}function Y(){return(Y=g(v().mark((function t(e,n,o,a,u,c,s,p,l){var d,f,m,h,y,k;return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:l||(l=s?r.add(V.MIN_SQRT_RATIO,S):r.subtract(V.MAX_SQRT_RATIO,S)),s?(r.greaterThan(l,V.MIN_SQRT_RATIO)||i(!1),r.lessThan(l,n)||i(!1)):(r.lessThan(l,V.MAX_SQRT_RATIO)||i(!1),r.greaterThan(l,n)||i(!1)),d=r.greaterThanOrEqual(p,O),f={amountSpecifiedRemaining:p,amountCalculated:O,sqrtPriceX96:n,tick:o,liquidity:a};case 4:if(!r.notEqual(f.amountSpecifiedRemaining,O)||f.sqrtPriceX96===l){t.next=35;break}return(m={}).sqrtPriceStartX96=f.sqrtPriceX96,t.next=9,c.nextInitializedTickWithinOneWord(f.tick,s,u);case 9:if(m.tickNext=(h=t.sent)[0],m.initialized=h[1],m.tickNext<V.MIN_TICK?m.tickNext=V.MIN_TICK:m.tickNext>V.MAX_TICK&&(m.tickNext=V.MAX_TICK),m.sqrtPriceNextX96=V.getSqrtRatioAtTick(m.tickNext),y=D.computeSwapStep(f.sqrtPriceX96,(s?r.lessThan(m.sqrtPriceNextX96,l):r.greaterThan(m.sqrtPriceNextX96,l))?l:m.sqrtPriceNextX96,f.liquidity,f.amountSpecifiedRemaining,e),f.sqrtPriceX96=y[0],m.amountIn=y[1],m.amountOut=y[2],m.feeAmount=y[3],d?(f.amountSpecifiedRemaining=r.subtract(f.amountSpecifiedRemaining,r.add(m.amountIn,m.feeAmount)),f.amountCalculated=r.subtract(f.amountCalculated,m.amountOut)):(f.amountSpecifiedRemaining=r.add(f.amountSpecifiedRemaining,m.amountOut),f.amountCalculated=r.add(f.amountCalculated,r.add(m.amountIn,m.feeAmount))),!r.equal(f.sqrtPriceX96,m.sqrtPriceNextX96)){t.next=32;break}if(!m.initialized){t.next=29;break}return t.t0=r,t.next=25,c.getTick(m.tickNext);case 25:t.t1=t.sent.liquidityNet,k=t.t0.BigInt.call(t.t0,t.t1),s&&(k=r.multiply(k,C)),f.liquidity=W.addDelta(f.liquidity,k);case 29:f.tick=s?m.tickNext-1:m.tickNext,t.next=33;break;case 32:r.notEqual(f.sqrtPriceX96,m.sqrtPriceStartX96)&&(f.tick=V.getTickAtSqrtRatio(f.sqrtPriceX96));case 33:t.next=4;break;case 35:return t.abrupt("return",{amountCalculated:f.amountCalculated,sqrtRatioX96:f.sqrtPriceX96,liquidity:f.liquidity,tickCurrent:f.tick});case 36:case"end":return t.stop()}}),t)})))).apply(this,arguments)}V.MIN_TICK=-887272,V.MAX_TICK=-V.MIN_TICK,V.MIN_SQRT_RATIO=r.BigInt("4295128739"),V.MAX_SQRT_RATIO=r.BigInt("1461446703485210103287273052203988822378723970342");var Z=function(){function t(){}var e=t.prototype;return e.getTick=function(){var e=g(v().mark((function e(n){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error(t.ERROR_MESSAGE);case 1:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),e.nextInitializedTickWithinOneWord=function(){var e=g(v().mark((function e(n,r,i){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error(t.ERROR_MESSAGE);case 1:case"end":return e.stop()}}),e)})));return function(t,n,r){return e.apply(this,arguments)}}(),t}();function $(t,e){for(var n=0;n<t.length-1;n++)if(e(t[n],t[n+1])>0)return!1;return!0}function J(t,e){return t.index-e.index}Z.ERROR_MESSAGE="No tick data provider was given";var tt=function(){function t(){}return t.validateList=function(t,e){e>0||i(!1),t.every((function(t){return t.index%e==0}))||i(!1),r.equal(t.reduce((function(t,e){return r.add(t,e.liquidityNet)}),O),O)||i(!1),$(t,J)||i(!1)},t.isBelowSmallest=function(t,e){return t.length>0||i(!1),e<t[0].index},t.isAtOrAboveLargest=function(t,e){return t.length>0||i(!1),e>=t[t.length-1].index},t.getTick=function(t,e){var n=t[this.binarySearch(t,e)];return n.index!==e&&i(!1),n},t.binarySearch=function(t,e){this.isBelowSmallest(t,e)&&i(!1);for(var n,r=0,o=t.length-1;;){if(t[n=Math.floor((r+o)/2)].index<=e&&(n===t.length-1||t[n+1].index>e))return n;t[n].index<e?r=n+1:o=n-1}},t.nextInitializedTick=function(e,n,r){return r?(t.isBelowSmallest(e,n)&&i(!1),t.isAtOrAboveLargest(e,n)?e[e.length-1]:e[this.binarySearch(e,n)]):(this.isAtOrAboveLargest(e,n)&&i(!1),this.isBelowSmallest(e,n)?e[0]:e[this.binarySearch(e,n)+1])},t.nextInitializedTickWithinOneWord=function(e,n,r,i){var o=Math.floor(n/i);if(r){var a=(o>>8<<8)*i;if(t.isBelowSmallest(e,n))return[a,!1];var u=t.nextInitializedTick(e,n,r).index,c=Math.max(a,u);return[c,c===u]}var s=((1+(o+1>>8)<<8)-1)*i;if(this.isAtOrAboveLargest(e,n))return[s,!1];var p=this.nextInitializedTick(e,n,r).index,l=Math.min(s,p);return[l,l===p]},t}();function et(t){var e=r.BigInt(t).toString(16);return e.length%2!=0&&(e="0"+e),"0x"+e}function nt(t,e){var n=t.pools.reduce((function(t,e,n){var r=t.inputToken,i=t.path,o=t.types,a=e.token0.equals(r)?e.token1:e.token0;return 0===n?{inputToken:a,types:["address","uint24","address"],path:[r.address,e.fee,a.address]}:{inputToken:a,types:[].concat(o,["uint24","address"]),path:[].concat(i,[e.fee,a.address])}}),{inputToken:t.input.wrapped,path:[],types:[]}),r=n.path,i=n.types;return e?u.pack(i.reverse(),r.reverse()):u.pack(i,r)}function rt(t,e){var i=r.leftShift(r.BigInt(t),r.BigInt(192)),o=r.BigInt(e),a=r.divide(i,o);return n.sqrt(a)}function it(t,e,n){if(r.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}var o=r.divide(r.multiply(t,e),N);return r.divide(r.multiply(r.BigInt(n),o),r.subtract(e,t))}function ot(t,e,n){if(r.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}var o=r.multiply(r.multiply(r.BigInt(n),t),e),a=r.multiply(N,r.subtract(e,t));return r.divide(o,a)}function at(t,e,n){if(r.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}return r.divide(r.multiply(r.BigInt(n),N),r.subtract(e,t))}function ut(t,e,n,i,o,a){if(r.greaterThan(e,n)){var u=[n,e];e=u[0],n=u[1]}var c=a?ot:it;if(r.lessThanOrEqual(t,e))return c(e,n,i);if(r.lessThan(t,n)){var s=c(t,n,i),p=at(e,t,o);return r.lessThan(s,p)?s:p}return at(e,n,o)}var ct=r.exponentiate(r.BigInt(2),r.BigInt(128)),st=function(){function t(){}return t.getTokensOwed=function(t,e,n,i,o){return[r.divide(r.multiply(dt(i,t),n),ct),r.divide(r.multiply(dt(o,e),n),ct)]},t}();function pt(t,e,i){var o=V.getSqrtRatioAtTick(i),a=r.multiply(o,o);return t.sortsBefore(e)?new n.Price(t,e,_,a):new n.Price(t,e,a,_)}var lt=r.exponentiate(r.BigInt(2),r.BigInt(256));function dt(t,e){var n=r.subtract(t,e);return r.lessThan(n,O)?r.add(lt,n):n}var ft=function(){function t(){}return t.getFeeGrowthInside=function(t,e,n,r,i,o,a){var u,c,s,p;return i>=n?(u=t.feeGrowthOutside0X128,c=t.feeGrowthOutside1X128):(u=dt(o,t.feeGrowthOutside0X128),c=dt(a,t.feeGrowthOutside1X128)),i<r?(s=e.feeGrowthOutside0X128,p=e.feeGrowthOutside1X128):(s=dt(o,e.feeGrowthOutside0X128),p=dt(a,e.feeGrowthOutside1X128)),[dt(dt(o,u),s),dt(dt(a,c),p)]},t}(),mt=function(t){var e=t.index,n=t.liquidityGross,o=t.liquidityNet;e>=V.MIN_TICK&&e<=V.MAX_TICK||i(!1),this.index=e,this.liquidityGross=r.BigInt(n),this.liquidityNet=r.BigInt(o)},ht=function(){function t(t,e){var n=t.map((function(t){return t instanceof mt?t:new mt(t)}));tt.validateList(n,e),this.ticks=n}var e=t.prototype;return e.getTick=function(){var t=g(v().mark((function t(e){return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",tt.getTick(this.ticks,e));case 1:case"end":return t.stop()}}),t,this)})));return function(e){return t.apply(this,arguments)}}(),e.nextInitializedTickWithinOneWord=function(){var t=g(v().mark((function t(e,n,r){return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",tt.nextInitializedTickWithinOneWord(this.ticks,e,n,r));case 1:case"end":return t.stop()}}),t,this)})));return function(e,n,r){return t.apply(this,arguments)}}(),t}(),vt=new Z,yt=function(){function t(t,e,n,o,a,u,c){void 0===c&&(c=vt),Number.isInteger(n)&&n<1e6||i(!1);var s=V.getSqrtRatioAtTick(u),p=V.getSqrtRatioAtTick(u+1);r.greaterThanOrEqual(r.BigInt(o),s)&&r.lessThanOrEqual(r.BigInt(o),p)||i(!1);var l=t.sortsBefore(e)?[t,e]:[e,t];this.token0=l[0],this.token1=l[1],this.fee=n,this.sqrtRatioX96=r.BigInt(o),this.liquidity=r.BigInt(a),this.tickCurrent=u,this.tickDataProvider=Array.isArray(c)?new ht(c,P[n]):c}t.getAddress=function(t,e,n,r,i){return F({factoryAddress:null!=i?i:"0x1F98431c8aD98523631AE4a59f267346ea31F984",fee:n,tokenA:t,tokenB:e,initCodeHashManualOverride:r})};var e=t.prototype;return e.involvesToken=function(t){return t.equals(this.token0)||t.equals(this.token1)},e.priceOf=function(t){return this.involvesToken(t)||i(!1),t.equals(this.token0)?this.token0Price:this.token1Price},e.getOutputAmount=function(){var e=g(v().mark((function e(o,a){var u,c,s,p,l;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return this.involvesToken(o.currency)||i(!1),u=o.currency.equals(this.token0),e.next=4,this.swap(u,o.quotient,a);case 4:return s=(c=e.sent).sqrtRatioX96,p=c.liquidity,l=c.tickCurrent,e.abrupt("return",[n.CurrencyAmount.fromRawAmount(u?this.token1:this.token0,r.multiply(c.amountCalculated,C)),new t(this.token0,this.token1,this.fee,s,p,l,this.tickDataProvider)]);case 11:case"end":return e.stop()}}),e,this)})));return function(t,n){return e.apply(this,arguments)}}(),e.getInputAmount=function(){var e=g(v().mark((function e(o,a){var u,c,s,p,l;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o.currency.isToken&&this.involvesToken(o.currency)||i(!1),u=o.currency.equals(this.token1),e.next=4,this.swap(u,r.multiply(o.quotient,C),a);case 4:return s=(c=e.sent).sqrtRatioX96,p=c.liquidity,l=c.tickCurrent,e.abrupt("return",[n.CurrencyAmount.fromRawAmount(u?this.token0:this.token1,c.amountCalculated),new t(this.token0,this.token1,this.fee,s,p,l,this.tickDataProvider)]);case 11:case"end":return e.stop()}}),e,this)})));return function(t,n){return e.apply(this,arguments)}}(),e.swap=function(){var t=g(v().mark((function t(e,n,i){return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",z(r.BigInt(this.fee),this.sqrtRatioX96,this.tickCurrent,this.liquidity,this.tickSpacing,this.tickDataProvider,e,n,i));case 1:case"end":return t.stop()}}),t,this)})));return function(e,n,r){return t.apply(this,arguments)}}(),T(t,[{key:"token0Price",get:function(){var t;return null!=(t=this._token0Price)?t:this._token0Price=new n.Price(this.token0,this.token1,_,r.multiply(this.sqrtRatioX96,this.sqrtRatioX96))}},{key:"token1Price",get:function(){var t;return null!=(t=this._token1Price)?t:this._token1Price=new n.Price(this.token1,this.token0,r.multiply(this.sqrtRatioX96,this.sqrtRatioX96),_)}},{key:"chainId",get:function(){return this.token0.chainId}},{key:"tickSpacing",get:function(){return P[this.fee]}}]),t}(),kt=function(){function t(t){var e=t.pool,n=t.liquidity,o=t.tickLower,a=t.tickUpper;this._token0Amount=null,this._token1Amount=null,this._mintAmounts=null,o<a||i(!1),o>=V.MIN_TICK&&o%e.tickSpacing==0||i(!1),a<=V.MAX_TICK&&a%e.tickSpacing==0||i(!1),this.pool=e,this.tickLower=o,this.tickUpper=a,this.liquidity=r.BigInt(n)}var e=t.prototype;return e.ratiosAfterSlippage=function(t){var e=this.pool.token0Price.asFraction.multiply(new n.Percent(1).subtract(t)),i=this.pool.token0Price.asFraction.multiply(t.add(1)),o=rt(e.numerator,e.denominator);r.lessThanOrEqual(o,V.MIN_SQRT_RATIO)&&(o=r.add(V.MIN_SQRT_RATIO,r.BigInt(1)));var a=rt(i.numerator,i.denominator);return r.greaterThanOrEqual(a,V.MAX_SQRT_RATIO)&&(a=r.subtract(V.MAX_SQRT_RATIO,r.BigInt(1))),{sqrtRatioX96Lower:o,sqrtRatioX96Upper:a}},e.mintAmountsWithSlippage=function(e){var n=this.ratiosAfterSlippage(e),r=n.sqrtRatioX96Upper,i=n.sqrtRatioX96Lower,o=new yt(this.pool.token0,this.pool.token1,this.pool.fee,i,0,V.getTickAtSqrtRatio(i)),a=new yt(this.pool.token0,this.pool.token1,this.pool.fee,r,0,V.getTickAtSqrtRatio(r)),u=t.fromAmounts(w({pool:this.pool,tickLower:this.tickLower,tickUpper:this.tickUpper},this.mintAmounts,{useFullPrecision:!1}));return{amount0:new t({pool:a,liquidity:u.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).mintAmounts.amount0,amount1:new t({pool:o,liquidity:u.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).mintAmounts.amount1}},e.burnAmountsWithSlippage=function(e){var n=this.ratiosAfterSlippage(e),r=n.sqrtRatioX96Upper,i=n.sqrtRatioX96Lower,o=new yt(this.pool.token0,this.pool.token1,this.pool.fee,i,0,V.getTickAtSqrtRatio(i)),a=new t({pool:new yt(this.pool.token0,this.pool.token1,this.pool.fee,r,0,V.getTickAtSqrtRatio(r)),liquidity:this.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).amount0,u=new t({pool:o,liquidity:this.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).amount1;return{amount0:a.quotient,amount1:u.quotient}},t.fromAmounts=function(e){var n=e.pool,r=e.tickLower,i=e.tickUpper,o=e.amount0,a=e.amount1,u=e.useFullPrecision,c=V.getSqrtRatioAtTick(r),s=V.getSqrtRatioAtTick(i);return new t({pool:n,tickLower:r,tickUpper:i,liquidity:ut(n.sqrtRatioX96,c,s,o,a,u)})},t.fromAmount0=function(e){return t.fromAmounts({pool:e.pool,tickLower:e.tickLower,tickUpper:e.tickUpper,amount0:e.amount0,amount1:n.MaxUint256,useFullPrecision:e.useFullPrecision})},t.fromAmount1=function(e){return t.fromAmounts({pool:e.pool,tickLower:e.tickLower,tickUpper:e.tickUpper,amount0:n.MaxUint256,amount1:e.amount1,useFullPrecision:!0})},T(t,[{key:"token0PriceLower",get:function(){return pt(this.pool.token0,this.pool.token1,this.tickLower)}},{key:"token0PriceUpper",get:function(){return pt(this.pool.token0,this.pool.token1,this.tickUpper)}},{key:"amount0",get:function(){return null===this._token0Amount&&(this._token0Amount=n.CurrencyAmount.fromRawAmount(this.pool.token0,this.pool.tickCurrent<this.tickLower?M.getAmount0Delta(V.getSqrtRatioAtTick(this.tickLower),V.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1):this.pool.tickCurrent<this.tickUpper?M.getAmount0Delta(this.pool.sqrtRatioX96,V.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1):O)),this._token0Amount}},{key:"amount1",get:function(){return null===this._token1Amount&&(this._token1Amount=n.CurrencyAmount.fromRawAmount(this.pool.token1,this.pool.tickCurrent<this.tickLower?O:M.getAmount1Delta(V.getSqrtRatioAtTick(this.tickLower),this.pool.tickCurrent<this.tickUpper?this.pool.sqrtRatioX96:V.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1))),this._token1Amount}},{key:"mintAmounts",get:function(){return null===this._mintAmounts?this.pool.tickCurrent<this.tickLower?{amount0:M.getAmount0Delta(V.getSqrtRatioAtTick(this.tickLower),V.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0),amount1:O}:this.pool.tickCurrent<this.tickUpper?{amount0:M.getAmount0Delta(this.pool.sqrtRatioX96,V.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0),amount1:M.getAmount1Delta(V.getSqrtRatioAtTick(this.tickLower),this.pool.sqrtRatioX96,this.liquidity,!0)}:{amount0:O,amount1:M.getAmount1Delta(V.getSqrtRatioAtTick(this.tickLower),V.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0)}:this._mintAmounts}}]),t}(),gt=function(){function t(t,e,n){this._midPrice=null,t.length>0||i(!1);var r=t[0].chainId;t.every((function(t){return t.chainId===r}))||i(!1);var o=e.wrapped;t[0].involvesToken(o)||i(!1),t[t.length-1].involvesToken(n.wrapped)||i(!1);for(var a,u=[o],c=I(t.entries());!(a=c()).done;){var s=a.value,p=s[1],l=u[s[0]];l.equals(p.token0)||l.equals(p.token1)||i(!1);var d=l.equals(p.token0)?p.token1:p.token0;u.push(d)}this.pools=t,this.tokenPath=u,this.input=e,this.output=null!=n?n:u[u.length-1]}return T(t,[{key:"chainId",get:function(){return this.pools[0].chainId}},{key:"midPrice",get:function(){if(null!==this._midPrice)return this._midPrice;var t=this.pools.slice(1).reduce((function(t,e){var n=t.price;return t.nextInput.equals(e.token0)?{nextInput:e.token1,price:n.multiply(e.token0Price)}:{nextInput:e.token0,price:n.multiply(e.token1Price)}}),this.pools[0].token0.equals(this.input.wrapped)?{nextInput:this.pools[0].token1,price:this.pools[0].token0Price}:{nextInput:this.pools[0].token0,price:this.pools[0].token1Price}).price;return this._midPrice=new n.Price(this.input,this.output,t.denominator,t.numerator)}}]),t}();function At(t,e){return t.inputAmount.currency.equals(e.inputAmount.currency)||i(!1),t.outputAmount.currency.equals(e.outputAmount.currency)||i(!1),t.outputAmount.equalTo(e.outputAmount)?t.inputAmount.equalTo(e.inputAmount)?t.swaps.reduce((function(t,e){return t+e.route.tokenPath.length}),0)-e.swaps.reduce((function(t,e){return t+e.route.tokenPath.length}),0):t.inputAmount.lessThan(e.inputAmount)?-1:1:t.outputAmount.lessThan(e.outputAmount)?1:-1}var Tt=function(){function t(t){var e=t.routes,n=t.tradeType,r=e[0].inputAmount.currency,o=e[0].outputAmount.currency;e.every((function(t){return r.wrapped.equals(t.route.input.wrapped)}))||i(!1),e.every((function(t){return o.wrapped.equals(t.route.output.wrapped)}))||i(!1);for(var a,u=e.map((function(t){return t.route.pools.length})).reduce((function(t,e){return t+e}),0),c=new Set,s=I(e);!(a=s()).done;)for(var p,l=I(a.value.route.pools);!(p=l()).done;){var d=p.value;c.add(yt.getAddress(d.token0,d.token1,d.fee))}u!==c.size&&i(!1),this.swaps=e,this.tradeType=n}t.exactIn=function(){var e=g(v().mark((function e(r,i){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",t.fromRoute(r,i,n.TradeType.EXACT_INPUT));case 1:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}(),t.exactOut=function(){var e=g(v().mark((function e(r,i){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",t.fromRoute(r,i,n.TradeType.EXACT_OUTPUT));case 1:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}(),t.fromRoute=function(){var e=g(v().mark((function e(r,o,a){var u,c,s,p,l,d,f;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(u=new Array(r.tokenPath.length),a!==n.TradeType.EXACT_INPUT){e.next=19;break}o.currency.equals(r.input)||i(!1),u[0]=o.wrapped,p=0;case 5:if(!(p<r.tokenPath.length-1)){e.next=15;break}return l=r.pools[p],e.next=9,l.getOutputAmount(u[p]);case 9:u[p+1]=e.sent[0];case 12:p++,e.next=5;break;case 15:c=n.CurrencyAmount.fromFractionalAmount(r.input,o.numerator,o.denominator),s=n.CurrencyAmount.fromFractionalAmount(r.output,u[u.length-1].numerator,u[u.length-1].denominator),e.next=34;break;case 19:o.currency.equals(r.output)||i(!1),u[u.length-1]=o.wrapped,d=r.tokenPath.length-1;case 22:if(!(d>0)){e.next=32;break}return f=r.pools[d-1],e.next=26,f.getInputAmount(u[d]);case 26:u[d-1]=e.sent[0];case 29:d--,e.next=22;break;case 32:c=n.CurrencyAmount.fromFractionalAmount(r.input,u[0].numerator,u[0].denominator),s=n.CurrencyAmount.fromFractionalAmount(r.output,o.numerator,o.denominator);case 34:return e.abrupt("return",new t({routes:[{inputAmount:c,outputAmount:s,route:r}],tradeType:a}));case 35:case"end":return e.stop()}}),e)})));return function(t,n,r){return e.apply(this,arguments)}}(),t.fromRoutes=function(){var e=g(v().mark((function e(r,o){var a,u,c,s,p,l,d,f,m,h,y,k,g;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:a=[],u=I(r);case 2:if((c=u()).done){e.next=43;break}if(p=(s=c.value).route,l=s.amount,d=new Array(p.tokenPath.length),f=void 0,m=void 0,o!==n.TradeType.EXACT_INPUT){e.next=25;break}l.currency.equals(p.input)||i(!1),f=n.CurrencyAmount.fromFractionalAmount(p.input,l.numerator,l.denominator),d[0]=n.CurrencyAmount.fromFractionalAmount(p.input.wrapped,l.numerator,l.denominator),h=0;case 12:if(!(h<p.tokenPath.length-1)){e.next=22;break}return y=p.pools[h],e.next=16,y.getOutputAmount(d[h]);case 16:d[h+1]=e.sent[0];case 19:h++,e.next=12;break;case 22:m=n.CurrencyAmount.fromFractionalAmount(p.output,d[d.length-1].numerator,d[d.length-1].denominator),e.next=40;break;case 25:l.currency.equals(p.output)||i(!1),m=n.CurrencyAmount.fromFractionalAmount(p.output,l.numerator,l.denominator),d[d.length-1]=n.CurrencyAmount.fromFractionalAmount(p.output.wrapped,l.numerator,l.denominator),k=p.tokenPath.length-1;case 29:if(!(k>0)){e.next=39;break}return g=p.pools[k-1],e.next=33,g.getInputAmount(d[k]);case 33:d[k-1]=e.sent[0];case 36:k--,e.next=29;break;case 39:f=n.CurrencyAmount.fromFractionalAmount(p.input,d[0].numerator,d[0].denominator);case 40:a.push({route:p,inputAmount:f,outputAmount:m});case 41:e.next=2;break;case 43:return e.abrupt("return",new t({routes:a,tradeType:o}));case 44:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}(),t.createUncheckedTrade=function(e){return new t(w({},e,{routes:[{inputAmount:e.inputAmount,outputAmount:e.outputAmount,route:e.route}]}))},t.createUncheckedTradeWithMultipleRoutes=function(e){return new t(e)};var e=t.prototype;return e.minimumAmountOut=function(t,e){if(void 0===e&&(e=this.outputAmount),t.lessThan(O)&&i(!1),this.tradeType===n.TradeType.EXACT_OUTPUT)return e;var r=new n.Fraction(S).add(t).invert().multiply(e.quotient).quotient;return n.CurrencyAmount.fromRawAmount(e.currency,r)},e.maximumAmountIn=function(t,e){if(void 0===e&&(e=this.inputAmount),t.lessThan(O)&&i(!1),this.tradeType===n.TradeType.EXACT_INPUT)return e;var r=new n.Fraction(S).add(t).multiply(e.quotient).quotient;return n.CurrencyAmount.fromRawAmount(e.currency,r)},e.worstExecutionPrice=function(t){return new n.Price(this.inputAmount.currency,this.outputAmount.currency,this.maximumAmountIn(t).quotient,this.minimumAmountOut(t).quotient)},t.bestTradeExactIn=function(){var e=g(v().mark((function e(r,o,a,u,c,s,p){var l,d,f,m,h,y,k,g,A,T,w;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:f=void 0===(d=(l=void 0===u?{}:u).maxNumResults)?3:d,h=void 0===(m=l.maxHops)?3:m,void 0===c&&(c=[]),void 0===s&&(s=o),void 0===p&&(p=[]),r.length>0||i(!1),h>0||i(!1),o===s||c.length>0||i(!1),y=s.wrapped,k=a.wrapped,g=0;case 10:if(!(g<r.length)){e.next=46;break}if((A=r[g]).token0.equals(y.currency)||A.token1.equals(y.currency)){e.next=14;break}return e.abrupt("continue",43);case 14:return T=void 0,e.prev=15,e.next=19,A.getOutputAmount(y);case 19:T=e.sent[0],e.next=28;break;case 23:if(e.prev=23,e.t0=e.catch(15),!e.t0.isInsufficientInputAmountError){e.next=27;break}return e.abrupt("continue",43);case 27:throw e.t0;case 28:if(!T.currency.isToken||!T.currency.equals(k)){e.next=39;break}return e.t1=n.sortedInsert,e.t2=p,e.next=33,t.fromRoute(new gt([].concat(c,[A]),o.currency,a),o,n.TradeType.EXACT_INPUT);case 33:e.t3=e.sent,e.t4=f,e.t5=At,(0,e.t1)(e.t2,e.t3,e.t4,e.t5),e.next=43;break;case 39:if(!(h>1&&r.length>1)){e.next=43;break}return w=r.slice(0,g).concat(r.slice(g+1,r.length)),e.next=43,t.bestTradeExactIn(w,o,a,{maxNumResults:f,maxHops:h-1},[].concat(c,[A]),T,p);case 43:g++,e.next=10;break;case 46:return e.abrupt("return",p);case 47:case"end":return e.stop()}}),e,null,[[15,23]])})));return function(t,n,r,i,o,a,u){return e.apply(this,arguments)}}(),t.bestTradeExactOut=function(){var e=g(v().mark((function e(r,o,a,u,c,s,p){var l,d,f,m,h,y,k,g,A,T,w;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:f=void 0===(d=(l=void 0===u?{}:u).maxNumResults)?3:d,h=void 0===(m=l.maxHops)?3:m,void 0===c&&(c=[]),void 0===s&&(s=a),void 0===p&&(p=[]),r.length>0||i(!1),h>0||i(!1),a===s||c.length>0||i(!1),y=s.wrapped,k=o.wrapped,g=0;case 10:if(!(g<r.length)){e.next=46;break}if((A=r[g]).token0.equals(y.currency)||A.token1.equals(y.currency)){e.next=14;break}return e.abrupt("continue",43);case 14:return T=void 0,e.prev=15,e.next=19,A.getInputAmount(y);case 19:T=e.sent[0],e.next=28;break;case 23:if(e.prev=23,e.t0=e.catch(15),!e.t0.isInsufficientReservesError){e.next=27;break}return e.abrupt("continue",43);case 27:throw e.t0;case 28:if(!T.currency.equals(k)){e.next=39;break}return e.t1=n.sortedInsert,e.t2=p,e.next=33,t.fromRoute(new gt([A].concat(c),o,a.currency),a,n.TradeType.EXACT_OUTPUT);case 33:e.t3=e.sent,e.t4=f,e.t5=At,(0,e.t1)(e.t2,e.t3,e.t4,e.t5),e.next=43;break;case 39:if(!(h>1&&r.length>1)){e.next=43;break}return w=r.slice(0,g).concat(r.slice(g+1,r.length)),e.next=43,t.bestTradeExactOut(w,o,a,{maxNumResults:f,maxHops:h-1},[A].concat(c),T,p);case 43:g++,e.next=10;break;case 46:return e.abrupt("return",p);case 47:case"end":return e.stop()}}),e,null,[[15,23]])})));return function(t,n,r,i,o,a,u){return e.apply(this,arguments)}}(),T(t,[{key:"route",get:function(){return 1!==this.swaps.length&&i(!1),this.swaps[0].route}},{key:"inputAmount",get:function(){if(this._inputAmount)return this._inputAmount;var t=this.swaps[0].inputAmount.currency,e=this.swaps.map((function(t){return t.inputAmount})).reduce((function(t,e){return t.add(e)}),n.CurrencyAmount.fromRawAmount(t,0));return this._inputAmount=e,this._inputAmount}},{key:"outputAmount",get:function(){if(this._outputAmount)return this._outputAmount;var t=this.swaps[0].outputAmount.currency,e=this.swaps.map((function(t){return t.outputAmount})).reduce((function(t,e){return t.add(e)}),n.CurrencyAmount.fromRawAmount(t,0));return this._outputAmount=e,this._outputAmount}},{key:"executionPrice",get:function(){var t;return null!=(t=this._executionPrice)?t:this._executionPrice=new n.Price(this.inputAmount.currency,this.outputAmount.currency,this.inputAmount.quotient,this.outputAmount.quotient)}},{key:"priceImpact",get:function(){if(this._priceImpact)return this._priceImpact;for(var t,e=n.CurrencyAmount.fromRawAmount(this.outputAmount.currency,0),r=I(this.swaps);!(t=r()).done;){var i=t.value;e=e.add(i.route.midPrice.quote(i.inputAmount))}var o=e.subtract(this.outputAmount).divide(e);return this._priceImpact=new n.Percent(o.numerator,o.denominator),this._priceImpact}}]),t}(),wt=function(){function t(){}return t.encodeMulticall=function(e){return Array.isArray(e)||(e=[e]),1===e.length?e[0]:t.INTERFACE.encodeFunctionData("multicall",[e])},t.decodeMulticall=function(e){return t.INTERFACE.decodeFunctionData("multicall",e).data},t}();wt.INTERFACE=new o.Interface(c.abi);var xt=function(){function t(){}return t.encodePermit=function(e,n){return"nonce"in n?t.INTERFACE.encodeFunctionData("selfPermitAllowed",[e.address,et(n.nonce),et(n.expiry),n.v,n.r,n.s]):t.INTERFACE.encodeFunctionData("selfPermit",[e.address,et(n.amount),et(n.deadline),n.v,n.r,n.s])},t}();xt.INTERFACE=new o.Interface(p.abi);var It=function(){function t(){}return t.encodeFeeBips=function(t){return et(t.multiply(1e4).quotient)},t.encodeUnwrapWETH9=function(e,r,i){if(r=n.validateAndParseAddress(r),i){var o=this.encodeFeeBips(i.fee),a=n.validateAndParseAddress(i.recipient);return t.INTERFACE.encodeFunctionData("unwrapWETH9WithFee",[et(e),r,o,a])}return t.INTERFACE.encodeFunctionData("unwrapWETH9",[et(e),r])},t.encodeSweepToken=function(e,r,i,o){if(i=n.validateAndParseAddress(i),o){var a=this.encodeFeeBips(o.fee),u=n.validateAndParseAddress(o.recipient);return t.INTERFACE.encodeFunctionData("sweepTokenWithFee",[e.address,et(r),i,a,u])}return t.INTERFACE.encodeFunctionData("sweepToken",[e.address,et(r),i])},t.encodeRefundETH=function(){return t.INTERFACE.encodeFunctionData("refundETH")},t}();It.INTERFACE=new o.Interface(l.abi);var qt=["expectedCurrencyOwed0","expectedCurrencyOwed1"],bt=et(r.subtract(r.exponentiate(r.BigInt(2),r.BigInt(128)),r.BigInt(1)));function Rt(t){return Object.keys(t).some((function(t){return"recipient"===t}))}var Et={Permit:[{name:"spender",type:"address"},{name:"tokenId",type:"uint256"},{name:"nonce",type:"uint256"},{name:"deadline",type:"uint256"}]},Pt=function(){function t(){}return t.encodeCreate=function(e){return t.INTERFACE.encodeFunctionData("createAndInitializePoolIfNecessary",[e.token0.address,e.token1.address,e.fee,et(e.sqrtRatioX96)])},t.createCallParameters=function(t){return{calldata:this.encodeCreate(t),value:et(0)}},t.addCallParameters=function(e,o){r.greaterThan(e.liquidity,O)||i(!1);var a=[],u=e.mintAmounts,c=u.amount0,s=u.amount1,p=e.mintAmountsWithSlippage(o.slippageTolerance),l=et(p.amount0),d=et(p.amount1),f=et(o.deadline);if(Rt(o)&&o.createPool&&a.push(this.encodeCreate(e.pool)),o.token0Permit&&a.push(xt.encodePermit(e.pool.token0,o.token0Permit)),o.token1Permit&&a.push(xt.encodePermit(e.pool.token1,o.token1Permit)),Rt(o)){var m=n.validateAndParseAddress(o.recipient);a.push(t.INTERFACE.encodeFunctionData("mint",[{token0:e.pool.token0.address,token1:e.pool.token1.address,fee:e.pool.fee,tickLower:e.tickLower,tickUpper:e.tickUpper,amount0Desired:et(c),amount1Desired:et(s),amount0Min:l,amount1Min:d,recipient:m,deadline:f}]))}else a.push(t.INTERFACE.encodeFunctionData("increaseLiquidity",[{tokenId:et(o.tokenId),amount0Desired:et(c),amount1Desired:et(s),amount0Min:l,amount1Min:d,deadline:f}]));var h=et(0);if(o.useNative){var v=o.useNative.wrapped;e.pool.token0.equals(v)||e.pool.token1.equals(v)||i(!1);var y=e.pool.token0.equals(v)?c:s;r.greaterThan(y,O)&&a.push(It.encodeRefundETH()),h=et(y)}return{calldata:wt.encodeMulticall(a),value:h}},t.encodeCollect=function(e){var r=[],i=et(e.tokenId),o=e.expectedCurrencyOwed0.currency.isNative||e.expectedCurrencyOwed1.currency.isNative,a=n.validateAndParseAddress(e.recipient);if(r.push(t.INTERFACE.encodeFunctionData("collect",[{tokenId:i,recipient:o?b:a,amount0Max:bt,amount1Max:bt}])),o){var u=e.expectedCurrencyOwed0.currency.isNative?e.expectedCurrencyOwed1.currency:e.expectedCurrencyOwed0.currency,c=e.expectedCurrencyOwed0.currency.isNative?e.expectedCurrencyOwed1.quotient:e.expectedCurrencyOwed0.quotient;r.push(It.encodeUnwrapWETH9(e.expectedCurrencyOwed0.currency.isNative?e.expectedCurrencyOwed0.quotient:e.expectedCurrencyOwed1.quotient,a)),r.push(It.encodeSweepToken(u,c,a))}return r},t.collectCallParameters=function(e){var n=t.encodeCollect(e);return{calldata:wt.encodeMulticall(n),value:et(0)}},t.removeCallParameters=function(e,o){var a=[],u=et(o.deadline),c=et(o.tokenId),s=new kt({pool:e.pool,liquidity:o.liquidityPercentage.multiply(e.liquidity).quotient,tickLower:e.tickLower,tickUpper:e.tickUpper});r.greaterThan(s.liquidity,O)||i(!1);var p=s.burnAmountsWithSlippage(o.slippageTolerance),l=p.amount0,d=p.amount1;o.permit&&a.push(t.INTERFACE.encodeFunctionData("permit",[n.validateAndParseAddress(o.permit.spender),c,et(o.permit.deadline),o.permit.v,o.permit.r,o.permit.s])),a.push(t.INTERFACE.encodeFunctionData("decreaseLiquidity",[{tokenId:c,liquidity:et(s.liquidity),amount0Min:et(l),amount1Min:et(d),deadline:u}]));var f=o.collectOptions,m=f.expectedCurrencyOwed0,h=f.expectedCurrencyOwed1,v=function(t,e){if(null==t)return{};var n,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e.indexOf(n=o[r])>=0||(i[n]=t[n]);return i}(f,qt);return a.push.apply(a,t.encodeCollect(w({tokenId:et(o.tokenId),expectedCurrencyOwed0:m.add(n.CurrencyAmount.fromRawAmount(m.currency,l)),expectedCurrencyOwed1:h.add(n.CurrencyAmount.fromRawAmount(h.currency,d))},v))),o.liquidityPercentage.equalTo(S)?o.burnToken&&a.push(t.INTERFACE.encodeFunctionData("burn",[c])):!0===o.burnToken&&i(!1),{calldata:wt.encodeMulticall(a),value:et(0)}},t.safeTransferFromParameters=function(e){var r=n.validateAndParseAddress(e.recipient),i=n.validateAndParseAddress(e.sender);return{calldata:e.data?t.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256,bytes)",[i,r,et(e.tokenId),e.data]):t.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256)",[i,r,et(e.tokenId)]),value:et(0)}},t.getPermitData=function(t,e,n){return{domain:{name:"Uniswap V3 Positions NFT-V1",chainId:n,version:"1",verifyingContract:e},types:Et,values:t}},t}();Pt.INTERFACE=new o.Interface(s.abi);var Ct=function(){function t(){}return t.quoteCallParameters=function(t,e,r,o){void 0===o&&(o={});var a,u=1===t.pools.length,c=et(e.quotient),s=o.useQuoterV2?this.V2INTERFACE:this.V1INTERFACE;if(u){var p,l,d={tokenIn:t.tokenPath[0].address,tokenOut:t.tokenPath[1].address,fee:t.pools[0].fee,sqrtPriceLimitX96:et(null!=(p=null==(l=o)?void 0:l.sqrtPriceLimitX96)?p:0)},f=w({},d,r===n.TradeType.EXACT_INPUT?{amountIn:c}:{amount:c});a=s.encodeFunctionData(r===n.TradeType.EXACT_INPUT?"quoteExactInputSingle":"quoteExactOutputSingle",o.useQuoterV2?[f]:[d.tokenIn,d.tokenOut,d.fee,c,d.sqrtPriceLimitX96])}else{var m;void 0!==(null==(m=o)?void 0:m.sqrtPriceLimitX96)&&i(!1);var h=nt(t,r===n.TradeType.EXACT_OUTPUT);a=s.encodeFunctionData(r===n.TradeType.EXACT_INPUT?"quoteExactInput":"quoteExactOutput",[h,c])}return{calldata:a,value:et(0)}},t}();Ct.V1INTERFACE=new o.Interface(d.abi),Ct.V2INTERFACE=new o.Interface(f.abi);var Ot=function(){function t(){}return t.encodeClaim=function(e,r){var i,o=[];o.push(t.INTERFACE.encodeFunctionData("unstakeToken",[this._encodeIncentiveKey(e),et(r.tokenId)]));var a=n.validateAndParseAddress(r.recipient),u=null!=(i=r.amount)?i:0;return o.push(t.INTERFACE.encodeFunctionData("claimReward",[e.rewardToken.address,a,et(u)])),o},t.collectRewards=function(e,n){e=Array.isArray(e)?e:[e];for(var r=[],i=0;i<e.length;i++){var o=e[i];(r=r.concat(this.encodeClaim(o,n))).push(t.INTERFACE.encodeFunctionData("stakeToken",[this._encodeIncentiveKey(o),et(n.tokenId)]))}return{calldata:wt.encodeMulticall(r),value:et(0)}},t.withdrawToken=function(e,r){var i=[];e=Array.isArray(e)?e:[e];for(var o={tokenId:r.tokenId,recipient:r.recipient,amount:r.amount},a=0;a<e.length;a++)i=i.concat(this.encodeClaim(e[a],o));var u=n.validateAndParseAddress(r.owner);return i.push(t.INTERFACE.encodeFunctionData("withdrawToken",[et(r.tokenId),u,r.data?r.data:et(0)])),{calldata:wt.encodeMulticall(i),value:et(0)}},t.encodeDeposit=function(e){var n;if((e=Array.isArray(e)?e:[e]).length>1){for(var r=[],i=0;i<e.length;i++)r.push(this._encodeIncentiveKey(e[i]));n=o.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI+"[]"],[r])}else n=o.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI],[this._encodeIncentiveKey(e[0])]);return n},t._encodeIncentiveKey=function(t){var e=t.pool,r=e.token0,i=e.token1,o=e.fee,a=n.validateAndParseAddress(t.refundee);return{rewardToken:t.rewardToken.address,pool:yt.getAddress(r,i,o),startTime:et(t.startTime),endTime:et(t.endTime),refundee:a}},t}();Ot.INTERFACE=new o.Interface(m.abi),Ot.INCENTIVE_KEY_ABI="tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)";var St=function(){function t(){}return t.swapCallParameters=function(e,r){Array.isArray(e)||(e=[e]);var o=e[0],a=o.inputAmount.currency.wrapped,u=o.outputAmount.currency.wrapped;e.every((function(t){return t.inputAmount.currency.wrapped.equals(a)}))||i(!1),e.every((function(t){return t.outputAmount.currency.wrapped.equals(u)}))||i(!1);var c=[],s=n.CurrencyAmount.fromRawAmount(e[0].inputAmount.currency,0),p=n.CurrencyAmount.fromRawAmount(e[0].outputAmount.currency,0),l=e.reduce((function(t,e){return t.add(e.minimumAmountOut(r.slippageTolerance))}),p),d=o.inputAmount.currency.isNative&&o.tradeType===n.TradeType.EXACT_OUTPUT,f=o.outputAmount.currency.isNative,m=f||!!r.fee,h=o.inputAmount.currency.isNative?e.reduce((function(t,e){return t.add(e.maximumAmountIn(r.slippageTolerance))}),s):s;r.inputTokenPermit&&(o.inputAmount.currency.isToken||i(!1),c.push(xt.encodePermit(o.inputAmount.currency,r.inputTokenPermit)));for(var v,y=n.validateAndParseAddress(r.recipient),k=et(r.deadline),g=I(e);!(v=g()).done;)for(var A,T=v.value,w=I(T.swaps);!(A=w()).done;){var x=A.value,q=x.route,R=x.outputAmount,E=et(T.maximumAmountIn(r.slippageTolerance,x.inputAmount).quotient),P=et(T.minimumAmountOut(r.slippageTolerance,R).quotient);if(1===q.pools.length)if(T.tradeType===n.TradeType.EXACT_INPUT){var C,O={tokenIn:q.tokenPath[0].address,tokenOut:q.tokenPath[1].address,fee:q.pools[0].fee,recipient:m?b:y,deadline:k,amountIn:E,amountOutMinimum:P,sqrtPriceLimitX96:et(null!=(C=r.sqrtPriceLimitX96)?C:0)};c.push(t.INTERFACE.encodeFunctionData("exactInputSingle",[O]))}else{var S,N={tokenIn:q.tokenPath[0].address,tokenOut:q.tokenPath[1].address,fee:q.pools[0].fee,recipient:m?b:y,deadline:k,amountOut:P,amountInMaximum:E,sqrtPriceLimitX96:et(null!=(S=r.sqrtPriceLimitX96)?S:0)};c.push(t.INTERFACE.encodeFunctionData("exactOutputSingle",[N]))}else{void 0!==r.sqrtPriceLimitX96&&i(!1);var _=nt(q,T.tradeType===n.TradeType.EXACT_OUTPUT);c.push(T.tradeType===n.TradeType.EXACT_INPUT?t.INTERFACE.encodeFunctionData("exactInput",[{path:_,recipient:m?b:y,deadline:k,amountIn:E,amountOutMinimum:P}]):t.INTERFACE.encodeFunctionData("exactOutput",[{path:_,recipient:m?b:y,deadline:k,amountOut:P,amountInMaximum:E}]))}}return m&&c.push(r.fee?f?It.encodeUnwrapWETH9(l.quotient,y,r.fee):It.encodeSweepToken(o.outputAmount.currency.wrapped,l.quotient,y,r.fee):It.encodeUnwrapWETH9(l.quotient,y)),d&&c.push(It.encodeRefundETH()),{calldata:wt.encodeMulticall(c),value:et(h.quotient)}},t}();St.INTERFACE=new o.Interface(h.abi),exports.ADDRESS_ZERO=b,exports.FACTORY_ADDRESS="0x1F98431c8aD98523631AE4a59f267346ea31F984",exports.FullMath=L,exports.LiquidityMath=W,exports.Multicall=wt,exports.NoTickDataProvider=Z,exports.NonfungiblePositionManager=Pt,exports.POOL_INIT_CODE_HASH=R,exports.Payments=It,exports.Pool=yt,exports.Position=kt,exports.PositionLibrary=st,exports.Route=gt,exports.SelfPermit=xt,exports.SqrtPriceMath=M,exports.Staker=Ot,exports.SwapMath=D,exports.SwapQuoter=Ct,exports.SwapRouter=St,exports.TICK_SPACINGS=P,exports.Tick=mt,exports.TickLibrary=ft,exports.TickList=tt,exports.TickListDataProvider=ht,exports.TickMath=V,exports.Trade=Tt,exports.computePoolAddress=F,exports.encodeRouteToPath=nt,exports.encodeSqrtRatioX96=rt,exports.isSorted=$,exports.maxLiquidityForAmounts=ut,exports.mostSignificantBit=G,exports.nearestUsableTick=function(t,e){Number.isInteger(t)&&Number.isInteger(e)||i(!1),e>0||i(!1),t>=V.MIN_TICK&&t<=V.MAX_TICK||i(!1);var n=Math.round(t/e)*e;return n<V.MIN_TICK?n+e:n>V.MAX_TICK?n-e:n},exports.poolInitCodeHash=E,exports.priceToClosestTick=function(t){var e=t.baseCurrency.sortsBefore(t.quoteCurrency),n=e?rt(t.numerator,t.denominator):rt(t.denominator,t.numerator),r=V.getTickAtSqrtRatio(n),i=pt(t.baseCurrency,t.quoteCurrency,r+1);return e?t.lessThan(i)||r++:t.greaterThan(i)||r++,r},exports.subIn256=dt,exports.tickToPrice=pt,exports.toHex=et,exports.tradeComparator=At,exports.v3Swap=z;
+'use strict'
+function t(t) {
+  return t && 'object' == typeof t && 'default' in t ? t.default : t
+}
+Object.defineProperty(exports, '__esModule', { value: !0 })
+var e,
+  n = require('@uniswap/sdk-core'),
+  r = t(require('jsbi')),
+  i = t(require('tiny-invariant')),
+  o = require('@ethersproject/abi'),
+  a = require('@ethersproject/address'),
+  u = require('@ethersproject/solidity'),
+  c = t(require('@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json')),
+  s = t(
+    require('@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'),
+  ),
+  p = t(require('@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json')),
+  l = t(
+    require('@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json'),
+  ),
+  d = t(require('@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json')),
+  f = t(require('@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json')),
+  m = t(require('@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json')),
+  h = t(require('@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'))
+function v() {
+  v = function () {
+    return e
+  }
+  var t,
+    e = {},
+    n = Object.prototype,
+    r = n.hasOwnProperty,
+    i =
+      Object.defineProperty ||
+      function (t, e, n) {
+        t[e] = n.value
+      },
+    o = 'function' == typeof Symbol ? Symbol : {},
+    a = o.iterator || '@@iterator',
+    u = o.asyncIterator || '@@asyncIterator',
+    c = o.toStringTag || '@@toStringTag'
+  function s(t, e, n) {
+    return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }), t[e]
+  }
+  try {
+    s({}, '')
+  } catch (t) {
+    s = function (t, e, n) {
+      return (t[e] = n)
+    }
+  }
+  function p(t, e, n, r) {
+    var o = Object.create((e && e.prototype instanceof y ? e : y).prototype),
+      a = new C(r || [])
+    return i(o, '_invoke', { value: b(t, n, a) }), o
+  }
+  function l(t, e, n) {
+    try {
+      return { type: 'normal', arg: t.call(e, n) }
+    } catch (t) {
+      return { type: 'throw', arg: t }
+    }
+  }
+  e.wrap = p
+  var d = 'suspendedStart',
+    f = 'executing',
+    m = 'completed',
+    h = {}
+  function y() {}
+  function k() {}
+  function g() {}
+  var A = {}
+  s(A, a, function () {
+    return this
+  })
+  var T = Object.getPrototypeOf,
+    w = T && T(T(O([])))
+  w && w !== n && r.call(w, a) && (A = w)
+  var x = (g.prototype = y.prototype = Object.create(A))
+  function I(t) {
+    ;['next', 'throw', 'return'].forEach(function (e) {
+      s(t, e, function (t) {
+        return this._invoke(e, t)
+      })
+    })
+  }
+  function q(t, e) {
+    function n(i, o, a, u) {
+      var c = l(t[i], t, o)
+      if ('throw' !== c.type) {
+        var s = c.arg,
+          p = s.value
+        return p && 'object' == typeof p && r.call(p, '__await')
+          ? e.resolve(p.__await).then(
+              function (t) {
+                n('next', t, a, u)
+              },
+              function (t) {
+                n('throw', t, a, u)
+              },
+            )
+          : e.resolve(p).then(
+              function (t) {
+                ;(s.value = t), a(s)
+              },
+              function (t) {
+                return n('throw', t, a, u)
+              },
+            )
+      }
+      u(c.arg)
+    }
+    var o
+    i(this, '_invoke', {
+      value: function (t, r) {
+        function i() {
+          return new e(function (e, i) {
+            n(t, r, e, i)
+          })
+        }
+        return (o = o ? o.then(i, i) : i())
+      },
+    })
+  }
+  function b(e, n, r) {
+    var i = d
+    return function (o, a) {
+      if (i === f) throw new Error('Generator is already running')
+      if (i === m) {
+        if ('throw' === o) throw a
+        return { value: t, done: !0 }
+      }
+      for (r.method = o, r.arg = a; ; ) {
+        var u = r.delegate
+        if (u) {
+          var c = R(u, r)
+          if (c) {
+            if (c === h) continue
+            return c
+          }
+        }
+        if ('next' === r.method) r.sent = r._sent = r.arg
+        else if ('throw' === r.method) {
+          if (i === d) throw ((i = m), r.arg)
+          r.dispatchException(r.arg)
+        } else 'return' === r.method && r.abrupt('return', r.arg)
+        i = f
+        var s = l(e, n, r)
+        if ('normal' === s.type) {
+          if (((i = r.done ? m : 'suspendedYield'), s.arg === h)) continue
+          return { value: s.arg, done: r.done }
+        }
+        'throw' === s.type && ((i = m), (r.method = 'throw'), (r.arg = s.arg))
+      }
+    }
+  }
+  function R(e, n) {
+    var r = n.method,
+      i = e.iterator[r]
+    if (i === t)
+      return (
+        (n.delegate = null),
+        ('throw' === r && e.iterator.return && ((n.method = 'return'), (n.arg = t), R(e, n), 'throw' === n.method)) ||
+          ('return' !== r &&
+            ((n.method = 'throw'), (n.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
+        h
+      )
+    var o = l(i, e.iterator, n.arg)
+    if ('throw' === o.type) return (n.method = 'throw'), (n.arg = o.arg), (n.delegate = null), h
+    var a = o.arg
+    return a
+      ? a.done
+        ? ((n[e.resultName] = a.value),
+          (n.next = e.nextLoc),
+          'return' !== n.method && ((n.method = 'next'), (n.arg = t)),
+          (n.delegate = null),
+          h)
+        : a
+      : ((n.method = 'throw'), (n.arg = new TypeError('iterator result is not an object')), (n.delegate = null), h)
+  }
+  function E(t) {
+    var e = { tryLoc: t[0] }
+    1 in t && (e.catchLoc = t[1]), 2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])), this.tryEntries.push(e)
+  }
+  function P(t) {
+    var e = t.completion || {}
+    ;(e.type = 'normal'), delete e.arg, (t.completion = e)
+  }
+  function C(t) {
+    ;(this.tryEntries = [{ tryLoc: 'root' }]), t.forEach(E, this), this.reset(!0)
+  }
+  function O(e) {
+    if (e || '' === e) {
+      var n = e[a]
+      if (n) return n.call(e)
+      if ('function' == typeof e.next) return e
+      if (!isNaN(e.length)) {
+        var i = -1,
+          o = function n() {
+            for (; ++i < e.length; ) if (r.call(e, i)) return (n.value = e[i]), (n.done = !1), n
+            return (n.value = t), (n.done = !0), n
+          }
+        return (o.next = o)
+      }
+    }
+    throw new TypeError(typeof e + ' is not iterable')
+  }
+  return (
+    (k.prototype = g),
+    i(x, 'constructor', { value: g, configurable: !0 }),
+    i(g, 'constructor', { value: k, configurable: !0 }),
+    (k.displayName = s(g, c, 'GeneratorFunction')),
+    (e.isGeneratorFunction = function (t) {
+      var e = 'function' == typeof t && t.constructor
+      return !!e && (e === k || 'GeneratorFunction' === (e.displayName || e.name))
+    }),
+    (e.mark = function (t) {
+      return (
+        Object.setPrototypeOf ? Object.setPrototypeOf(t, g) : ((t.__proto__ = g), s(t, c, 'GeneratorFunction')),
+        (t.prototype = Object.create(x)),
+        t
+      )
+    }),
+    (e.awrap = function (t) {
+      return { __await: t }
+    }),
+    I(q.prototype),
+    s(q.prototype, u, function () {
+      return this
+    }),
+    (e.AsyncIterator = q),
+    (e.async = function (t, n, r, i, o) {
+      void 0 === o && (o = Promise)
+      var a = new q(p(t, n, r, i), o)
+      return e.isGeneratorFunction(n)
+        ? a
+        : a.next().then(function (t) {
+            return t.done ? t.value : a.next()
+          })
+    }),
+    I(x),
+    s(x, c, 'Generator'),
+    s(x, a, function () {
+      return this
+    }),
+    s(x, 'toString', function () {
+      return '[object Generator]'
+    }),
+    (e.keys = function (t) {
+      var e = Object(t),
+        n = []
+      for (var r in e) n.push(r)
+      return (
+        n.reverse(),
+        function t() {
+          for (; n.length; ) {
+            var r = n.pop()
+            if (r in e) return (t.value = r), (t.done = !1), t
+          }
+          return (t.done = !0), t
+        }
+      )
+    }),
+    (e.values = O),
+    (C.prototype = {
+      constructor: C,
+      reset: function (e) {
+        if (
+          ((this.prev = 0),
+          (this.next = 0),
+          (this.sent = this._sent = t),
+          (this.done = !1),
+          (this.delegate = null),
+          (this.method = 'next'),
+          (this.arg = t),
+          this.tryEntries.forEach(P),
+          !e)
+        )
+          for (var n in this) 't' === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
+      },
+      stop: function () {
+        this.done = !0
+        var t = this.tryEntries[0].completion
+        if ('throw' === t.type) throw t.arg
+        return this.rval
+      },
+      dispatchException: function (e) {
+        if (this.done) throw e
+        var n = this
+        function i(r, i) {
+          return (u.type = 'throw'), (u.arg = e), (n.next = r), i && ((n.method = 'next'), (n.arg = t)), !!i
+        }
+        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
+          var a = this.tryEntries[o],
+            u = a.completion
+          if ('root' === a.tryLoc) return i('end')
+          if (a.tryLoc <= this.prev) {
+            var c = r.call(a, 'catchLoc'),
+              s = r.call(a, 'finallyLoc')
+            if (c && s) {
+              if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
+              if (this.prev < a.finallyLoc) return i(a.finallyLoc)
+            } else if (c) {
+              if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
+            } else {
+              if (!s) throw new Error('try statement without catch or finally')
+              if (this.prev < a.finallyLoc) return i(a.finallyLoc)
+            }
+          }
+        }
+      },
+      abrupt: function (t, e) {
+        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
+          var i = this.tryEntries[n]
+          if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) {
+            var o = i
+            break
+          }
+        }
+        o && ('break' === t || 'continue' === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null)
+        var a = o ? o.completion : {}
+        return (a.type = t), (a.arg = e), o ? ((this.method = 'next'), (this.next = o.finallyLoc), h) : this.complete(a)
+      },
+      complete: function (t, e) {
+        if ('throw' === t.type) throw t.arg
+        return (
+          'break' === t.type || 'continue' === t.type
+            ? (this.next = t.arg)
+            : 'return' === t.type
+              ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
+              : 'normal' === t.type && e && (this.next = e),
+          h
+        )
+      },
+      finish: function (t) {
+        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+          var n = this.tryEntries[e]
+          if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), P(n), h
+        }
+      },
+      catch: function (t) {
+        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+          var n = this.tryEntries[e]
+          if (n.tryLoc === t) {
+            var r = n.completion
+            if ('throw' === r.type) {
+              var i = r.arg
+              P(n)
+            }
+            return i
+          }
+        }
+        throw new Error('illegal catch attempt')
+      },
+      delegateYield: function (e, n, r) {
+        return (
+          (this.delegate = { iterator: O(e), resultName: n, nextLoc: r }), 'next' === this.method && (this.arg = t), h
+        )
+      },
+    }),
+    e
+  )
+}
+function y(t) {
+  var e = (function (t, e) {
+    if ('object' != typeof t || !t) return t
+    var n = t[Symbol.toPrimitive]
+    if (void 0 !== n) {
+      var r = n.call(t, 'string')
+      if ('object' != typeof r) return r
+      throw new TypeError('@@toPrimitive must return a primitive value.')
+    }
+    return String(t)
+  })(t)
+  return 'symbol' == typeof e ? e : String(e)
+}
+function k(t, e, n, r, i, o, a) {
+  try {
+    var u = t[o](a),
+      c = u.value
+  } catch (t) {
+    return void n(t)
+  }
+  u.done ? e(c) : Promise.resolve(c).then(r, i)
+}
+function g(t) {
+  return function () {
+    var e = this,
+      n = arguments
+    return new Promise(function (r, i) {
+      var o = t.apply(e, n)
+      function a(t) {
+        k(o, r, i, a, u, 'next', t)
+      }
+      function u(t) {
+        k(o, r, i, a, u, 'throw', t)
+      }
+      a(void 0)
+    })
+  }
+}
+function A(t, e) {
+  for (var n = 0; n < e.length; n++) {
+    var r = e[n]
+    ;(r.enumerable = r.enumerable || !1),
+      (r.configurable = !0),
+      'value' in r && (r.writable = !0),
+      Object.defineProperty(t, y(r.key), r)
+  }
+}
+function T(t, e, n) {
+  return e && A(t.prototype, e), n && A(t, n), Object.defineProperty(t, 'prototype', { writable: !1 }), t
+}
+function w() {
+  return (w = Object.assign
+    ? Object.assign.bind()
+    : function (t) {
+        for (var e = 1; e < arguments.length; e++) {
+          var n = arguments[e]
+          for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
+        }
+        return t
+      }).apply(this, arguments)
+}
+function x(t, e) {
+  ;(null == e || e > t.length) && (e = t.length)
+  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
+  return r
+}
+function I(t, e) {
+  var n = ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator']
+  if (n) return (n = n.call(t)).next.bind(n)
+  if (
+    Array.isArray(t) ||
+    (n = (function (t, e) {
+      if (t) {
+        if ('string' == typeof t) return x(t, void 0)
+        var n = Object.prototype.toString.call(t).slice(8, -1)
+        return (
+          'Object' === n && t.constructor && (n = t.constructor.name),
+          'Map' === n || 'Set' === n
+            ? Array.from(t)
+            : 'Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
+              ? x(t, void 0)
+              : void 0
+        )
+      }
+    })(t)) ||
+    (e && t && 'number' == typeof t.length)
+  ) {
+    n && (t = n)
+    var r = 0
+    return function () {
+      return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] }
+    }
+  }
+  throw new TypeError(
+    'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
+  )
+}
+var q,
+  b = '0x0000000000000000000000000000000000000000',
+  R = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'
+function E(t) {
+  switch (t) {
+    case n.ChainId.ZKSYNC:
+      return '0x010013f177ea1fcbc4520f9a3ca7cd2d1d77959e05aa66484027cb38e712aeed'
+    default:
+      return R
+  }
+}
+;((q = exports.FeeAmount || (exports.FeeAmount = {}))[(q.LOWEST = 100)] = 'LOWEST'),
+  (q[(q.LOW_200 = 200)] = 'LOW_200'),
+  (q[(q.LOW_300 = 300)] = 'LOW_300'),
+  (q[(q.LOW_400 = 400)] = 'LOW_400'),
+  (q[(q.LOW = 500)] = 'LOW'),
+  (q[(q.MEDIUM = 3e3)] = 'MEDIUM'),
+  (q[(q.HIGH = 1e4)] = 'HIGH'),
+  (q[(q.LOWEST_SWAPMODE = 80)] = 'LOWEST_SWAPMODE'),
+  (q[(q.LOW_SWAPMODE = 350)] = 'LOW_SWAPMODE'),
+  (q[(q.LOW_SWAPMODE_450 = 450)] = 'LOW_SWAPMODE_450'),
+  (q[(q.MEDIUM_SWAPMODE = 2500)] = 'MEDIUM_SWAPMODE')
+
+var P =
+    (((e = {})[exports.FeeAmount.LOWEST] = 1),
+    (e[exports.FeeAmount.LOW_200] = 4),
+    (e[exports.FeeAmount.LOW_300] = 6),
+    (e[exports.FeeAmount.LOW_400] = 8),
+    (e[exports.FeeAmount.LOW] = 10),
+    (e[exports.FeeAmount.MEDIUM] = 60),
+    (e[exports.FeeAmount.HIGH] = 200),
+    (e[exports.FeeAmount.LOWEST_SWAPMODE] = 1),
+    (e[exports.FeeAmount.LOW_SWAPMODE] = 10),
+    (e[exports.FeeAmount.LOW_SWAPMODE_450] = 10),
+    (e[exports.FeeAmount.MEDIUM_SWAPMODE] = 60),
+    e),
+  C = r.BigInt(-1),
+  O = r.BigInt(0),
+  S = r.BigInt(1),
+  N = r.exponentiate(r.BigInt(2), r.BigInt(96)),
+  _ = r.exponentiate(N, r.BigInt(2))
+function F(t) {
+  var e = t.factoryAddress,
+    r = t.tokenA,
+    i = t.tokenB,
+    c = t.fee,
+    s = t.initCodeHashManualOverride,
+    p = t.chainId,
+    l = r.sortsBefore(i) ? [r, i] : [i, r],
+    d = u.keccak256(
+      ['bytes'],
+      [o.defaultAbiCoder.encode(['address', 'address', 'uint24'], [l[0].address, l[1].address, c])],
+    ),
+    f = null != s ? s : E(p)
+  switch (p) {
+    case n.ChainId.ZKSYNC:
+      return n.computeZksyncCreate2Address(e, f, d)
+    default:
+      return a.getCreate2Address(e, d, f)
+  }
+}
+var L = (function () {
+    function t() {}
+    return (
+      (t.mulDivRoundingUp = function (t, e, n) {
+        var i = r.multiply(t, e),
+          o = r.divide(i, n)
+        return r.notEqual(r.remainder(i, n), O) && (o = r.add(o, S)), o
+      }),
+      t
+    )
+  })(),
+  X = r.subtract(r.exponentiate(r.BigInt(2), r.BigInt(160)), S)
+function U(t, e) {
+  var i = r.multiply(t, e)
+  return r.bitwiseAnd(i, n.MaxUint256)
+}
+var M = (function () {
+    function t() {}
+    return (
+      (t.getAmount0Delta = function (t, e, n, i) {
+        if (r.greaterThan(t, e)) {
+          var o = [e, t]
+          ;(t = o[0]), (e = o[1])
+        }
+        var a = r.leftShift(n, r.BigInt(96)),
+          u = r.subtract(e, t)
+        return i ? L.mulDivRoundingUp(L.mulDivRoundingUp(a, u, e), S, t) : r.divide(r.divide(r.multiply(a, u), e), t)
+      }),
+      (t.getAmount1Delta = function (t, e, n, i) {
+        if (r.greaterThan(t, e)) {
+          var o = [e, t]
+          ;(t = o[0]), (e = o[1])
+        }
+        return i ? L.mulDivRoundingUp(n, r.subtract(e, t), N) : r.divide(r.multiply(n, r.subtract(e, t)), N)
+      }),
+      (t.getNextSqrtPriceFromInput = function (t, e, n, o) {
+        return (
+          r.greaterThan(t, O) || i(!1),
+          r.greaterThan(e, O) || i(!1),
+          o
+            ? this.getNextSqrtPriceFromAmount0RoundingUp(t, e, n, !0)
+            : this.getNextSqrtPriceFromAmount1RoundingDown(t, e, n, !0)
+        )
+      }),
+      (t.getNextSqrtPriceFromOutput = function (t, e, n, o) {
+        return (
+          r.greaterThan(t, O) || i(!1),
+          r.greaterThan(e, O) || i(!1),
+          o
+            ? this.getNextSqrtPriceFromAmount1RoundingDown(t, e, n, !1)
+            : this.getNextSqrtPriceFromAmount0RoundingUp(t, e, n, !1)
+        )
+      }),
+      (t.getNextSqrtPriceFromAmount0RoundingUp = function (t, e, o, a) {
+        if (r.equal(o, O)) return t
+        var u = r.leftShift(e, r.BigInt(96))
+        if (a) {
+          var c = U(o, t)
+          if (r.equal(r.divide(c, o), t)) {
+            var s = ((l = r.add(u, c)), r.bitwiseAnd(l, n.MaxUint256))
+            if (r.greaterThanOrEqual(s, u)) return L.mulDivRoundingUp(u, t, s)
+          }
+          return L.mulDivRoundingUp(u, S, r.add(r.divide(u, t), o))
+        }
+        var p = U(o, t)
+        r.equal(r.divide(p, o), t) || i(!1), r.greaterThan(u, p) || i(!1)
+        var l,
+          d = r.subtract(u, p)
+        return L.mulDivRoundingUp(u, t, d)
+      }),
+      (t.getNextSqrtPriceFromAmount1RoundingDown = function (t, e, n, o) {
+        if (o) {
+          var a = r.lessThanOrEqual(n, X) ? r.divide(r.leftShift(n, r.BigInt(96)), e) : r.divide(r.multiply(n, N), e)
+          return r.add(t, a)
+        }
+        var u = L.mulDivRoundingUp(n, N, e)
+        return r.greaterThan(t, u) || i(!1), r.subtract(t, u)
+      }),
+      t
+    )
+  })(),
+  B = r.exponentiate(r.BigInt(10), r.BigInt(6)),
+  D = (function () {
+    function t() {}
+    return (
+      (t.computeSwapStep = function (t, e, n, i, o) {
+        var a = {}
+        o = r.BigInt(o)
+        var u = r.greaterThanOrEqual(t, e),
+          c = r.greaterThanOrEqual(i, O)
+        if (c) {
+          var s = r.divide(r.multiply(i, r.subtract(B, o)), B)
+          ;(a.amountIn = u ? M.getAmount0Delta(e, t, n, !0) : M.getAmount1Delta(t, e, n, !0)),
+            (a.sqrtRatioNextX96 = r.greaterThanOrEqual(s, a.amountIn) ? e : M.getNextSqrtPriceFromInput(t, n, s, u))
+        } else
+          (a.amountOut = u ? M.getAmount1Delta(e, t, n, !1) : M.getAmount0Delta(t, e, n, !1)),
+            (a.sqrtRatioNextX96 = r.greaterThanOrEqual(r.multiply(i, C), a.amountOut)
+              ? e
+              : M.getNextSqrtPriceFromOutput(t, n, r.multiply(i, C), u))
+        var p = r.equal(e, a.sqrtRatioNextX96)
+        return (
+          u
+            ? ((a.amountIn = p && c ? a.amountIn : M.getAmount0Delta(a.sqrtRatioNextX96, t, n, !0)),
+              (a.amountOut = p && !c ? a.amountOut : M.getAmount1Delta(a.sqrtRatioNextX96, t, n, !1)))
+            : ((a.amountIn = p && c ? a.amountIn : M.getAmount1Delta(t, a.sqrtRatioNextX96, n, !0)),
+              (a.amountOut = p && !c ? a.amountOut : M.getAmount0Delta(t, a.sqrtRatioNextX96, n, !1))),
+          !c && r.greaterThan(a.amountOut, r.multiply(i, C)) && (a.amountOut = r.multiply(i, C)),
+          (a.feeAmount =
+            c && r.notEqual(a.sqrtRatioNextX96, e)
+              ? r.subtract(i, a.amountIn)
+              : L.mulDivRoundingUp(a.amountIn, o, r.subtract(B, o))),
+          [a.sqrtRatioNextX96, a.amountIn, a.amountOut, a.feeAmount]
+        )
+      }),
+      t
+    )
+  })(),
+  W = (function () {
+    function t() {}
+    return (
+      (t.addDelta = function (t, e) {
+        return r.lessThan(e, O) ? r.subtract(t, r.multiply(e, C)) : r.add(t, e)
+      }),
+      t
+    )
+  })(),
+  j = r.BigInt(2),
+  K = [128, 64, 32, 16, 8, 4, 2, 1].map(function (t) {
+    return [t, r.exponentiate(j, r.BigInt(t))]
+  })
+function G(t) {
+  r.greaterThan(t, O) || i(!1), r.lessThanOrEqual(t, n.MaxUint256) || i(!1)
+  for (var e, o = 0, a = I(K); !(e = a()).done; ) {
+    var u = e.value,
+      c = u[0]
+    r.greaterThanOrEqual(t, u[1]) && ((t = r.signedRightShift(t, r.BigInt(c))), (o += c))
+  }
+  return o
+}
+function H(t, e) {
+  return r.signedRightShift(r.multiply(t, r.BigInt(e)), r.BigInt(128))
+}
+var Q = r.exponentiate(r.BigInt(2), r.BigInt(32)),
+  V = (function () {
+    function t() {}
+    return (
+      (t.getSqrtRatioAtTick = function (e) {
+        ;(e >= t.MIN_TICK && e <= t.MAX_TICK && Number.isInteger(e)) || i(!1)
+        var o = e < 0 ? -1 * e : e,
+          a = r.BigInt(0 != (1 & o) ? '0xfffcb933bd6fad37aa2d162d1a594001' : '0x100000000000000000000000000000000')
+        return (
+          0 != (2 & o) && (a = H(a, '0xfff97272373d413259a46990580e213a')),
+          0 != (4 & o) && (a = H(a, '0xfff2e50f5f656932ef12357cf3c7fdcc')),
+          0 != (8 & o) && (a = H(a, '0xffe5caca7e10e4e61c3624eaa0941cd0')),
+          0 != (16 & o) && (a = H(a, '0xffcb9843d60f6159c9db58835c926644')),
+          0 != (32 & o) && (a = H(a, '0xff973b41fa98c081472e6896dfb254c0')),
+          0 != (64 & o) && (a = H(a, '0xff2ea16466c96a3843ec78b326b52861')),
+          0 != (128 & o) && (a = H(a, '0xfe5dee046a99a2a811c461f1969c3053')),
+          0 != (256 & o) && (a = H(a, '0xfcbe86c7900a88aedcffc83b479aa3a4')),
+          0 != (512 & o) && (a = H(a, '0xf987a7253ac413176f2b074cf7815e54')),
+          0 != (1024 & o) && (a = H(a, '0xf3392b0822b70005940c7a398e4b70f3')),
+          0 != (2048 & o) && (a = H(a, '0xe7159475a2c29b7443b29c7fa6e889d9')),
+          0 != (4096 & o) && (a = H(a, '0xd097f3bdfd2022b8845ad8f792aa5825')),
+          0 != (8192 & o) && (a = H(a, '0xa9f746462d870fdf8a65dc1f90e061e5')),
+          0 != (16384 & o) && (a = H(a, '0x70d869a156d2a1b890bb3df62baf32f7')),
+          0 != (32768 & o) && (a = H(a, '0x31be135f97d08fd981231505542fcfa6')),
+          0 != (65536 & o) && (a = H(a, '0x9aa508b5b7a84e1c677de54f3e99bc9')),
+          0 != (131072 & o) && (a = H(a, '0x5d6af8dedb81196699c329225ee604')),
+          0 != (262144 & o) && (a = H(a, '0x2216e584f5fa1ea926041bedfe98')),
+          0 != (524288 & o) && (a = H(a, '0x48a170391f7dc42444e8fa2')),
+          e > 0 && (a = r.divide(n.MaxUint256, a)),
+          r.greaterThan(r.remainder(a, Q), O) ? r.add(r.divide(a, Q), S) : r.divide(a, Q)
+        )
+      }),
+      (t.getTickAtSqrtRatio = function (e) {
+        ;(r.greaterThanOrEqual(e, t.MIN_SQRT_RATIO) && r.lessThan(e, t.MAX_SQRT_RATIO)) || i(!1)
+        var n,
+          o = r.leftShift(e, r.BigInt(32)),
+          a = G(o)
+        n = r.greaterThanOrEqual(r.BigInt(a), r.BigInt(128))
+          ? r.signedRightShift(o, r.BigInt(a - 127))
+          : r.leftShift(o, r.BigInt(127 - a))
+        for (var u = r.leftShift(r.subtract(r.BigInt(a), r.BigInt(128)), r.BigInt(64)), c = 0; c < 14; c++) {
+          n = r.signedRightShift(r.multiply(n, n), r.BigInt(127))
+          var s = r.signedRightShift(n, r.BigInt(128))
+          ;(u = r.bitwiseOr(u, r.leftShift(s, r.BigInt(63 - c)))), (n = r.signedRightShift(n, s))
+        }
+        var p = r.multiply(u, r.BigInt('255738958999603826347141')),
+          l = r.toNumber(
+            r.signedRightShift(r.subtract(p, r.BigInt('3402992956809132418596140100660247210')), r.BigInt(128)),
+          ),
+          d = r.toNumber(
+            r.signedRightShift(r.add(p, r.BigInt('291339464771989622907027621153398088495')), r.BigInt(128)),
+          )
+        return l === d ? l : r.lessThanOrEqual(t.getSqrtRatioAtTick(d), e) ? d : l
+      }),
+      t
+    )
+  })()
+function z(t, e, n, r, i, o, a, u, c) {
+  return Y.apply(this, arguments)
+}
+function Y() {
+  return (Y = g(
+    v().mark(function t(e, n, o, a, u, c, s, p, l) {
+      var d, f, m, h, y, k
+      return v().wrap(function (t) {
+        for (;;)
+          switch ((t.prev = t.next)) {
+            case 0:
+              l || (l = s ? r.add(V.MIN_SQRT_RATIO, S) : r.subtract(V.MAX_SQRT_RATIO, S)),
+                s
+                  ? (r.greaterThan(l, V.MIN_SQRT_RATIO) || i(!1), r.lessThan(l, n) || i(!1))
+                  : (r.lessThan(l, V.MAX_SQRT_RATIO) || i(!1), r.greaterThan(l, n) || i(!1)),
+                (d = r.greaterThanOrEqual(p, O)),
+                (f = { amountSpecifiedRemaining: p, amountCalculated: O, sqrtPriceX96: n, tick: o, liquidity: a })
+            case 4:
+              if (!r.notEqual(f.amountSpecifiedRemaining, O) || f.sqrtPriceX96 === l) {
+                t.next = 35
+                break
+              }
+              return (
+                ((m = {}).sqrtPriceStartX96 = f.sqrtPriceX96),
+                (t.next = 9),
+                c.nextInitializedTickWithinOneWord(f.tick, s, u)
+              )
+            case 9:
+              if (
+                ((m.tickNext = (h = t.sent)[0]),
+                (m.initialized = h[1]),
+                m.tickNext < V.MIN_TICK
+                  ? (m.tickNext = V.MIN_TICK)
+                  : m.tickNext > V.MAX_TICK && (m.tickNext = V.MAX_TICK),
+                (m.sqrtPriceNextX96 = V.getSqrtRatioAtTick(m.tickNext)),
+                (y = D.computeSwapStep(
+                  f.sqrtPriceX96,
+                  (s ? r.lessThan(m.sqrtPriceNextX96, l) : r.greaterThan(m.sqrtPriceNextX96, l))
+                    ? l
+                    : m.sqrtPriceNextX96,
+                  f.liquidity,
+                  f.amountSpecifiedRemaining,
+                  e,
+                )),
+                (f.sqrtPriceX96 = y[0]),
+                (m.amountIn = y[1]),
+                (m.amountOut = y[2]),
+                (m.feeAmount = y[3]),
+                d
+                  ? ((f.amountSpecifiedRemaining = r.subtract(
+                      f.amountSpecifiedRemaining,
+                      r.add(m.amountIn, m.feeAmount),
+                    )),
+                    (f.amountCalculated = r.subtract(f.amountCalculated, m.amountOut)))
+                  : ((f.amountSpecifiedRemaining = r.add(f.amountSpecifiedRemaining, m.amountOut)),
+                    (f.amountCalculated = r.add(f.amountCalculated, r.add(m.amountIn, m.feeAmount)))),
+                !r.equal(f.sqrtPriceX96, m.sqrtPriceNextX96))
+              ) {
+                t.next = 32
+                break
+              }
+              if (!m.initialized) {
+                t.next = 29
+                break
+              }
+              return (t.t0 = r), (t.next = 25), c.getTick(m.tickNext)
+            case 25:
+              ;(t.t1 = t.sent.liquidityNet),
+                (k = t.t0.BigInt.call(t.t0, t.t1)),
+                s && (k = r.multiply(k, C)),
+                (f.liquidity = W.addDelta(f.liquidity, k))
+            case 29:
+              ;(f.tick = s ? m.tickNext - 1 : m.tickNext), (t.next = 33)
+              break
+            case 32:
+              r.notEqual(f.sqrtPriceX96, m.sqrtPriceStartX96) && (f.tick = V.getTickAtSqrtRatio(f.sqrtPriceX96))
+            case 33:
+              t.next = 4
+              break
+            case 35:
+              return t.abrupt('return', {
+                amountCalculated: f.amountCalculated,
+                sqrtRatioX96: f.sqrtPriceX96,
+                liquidity: f.liquidity,
+                tickCurrent: f.tick,
+              })
+            case 36:
+            case 'end':
+              return t.stop()
+          }
+      }, t)
+    }),
+  )).apply(this, arguments)
+}
+;(V.MIN_TICK = -887272),
+  (V.MAX_TICK = -V.MIN_TICK),
+  (V.MIN_SQRT_RATIO = r.BigInt('4295128739')),
+  (V.MAX_SQRT_RATIO = r.BigInt('1461446703485210103287273052203988822378723970342'))
+var Z = (function () {
+  function t() {}
+  var e = t.prototype
+  return (
+    (e.getTick = (function () {
+      var e = g(
+        v().mark(function e(n) {
+          return v().wrap(function (e) {
+            for (;;)
+              switch ((e.prev = e.next)) {
+                case 0:
+                  throw new Error(t.ERROR_MESSAGE)
+                case 1:
+                case 'end':
+                  return e.stop()
+              }
+          }, e)
+        }),
+      )
+      return function (t) {
+        return e.apply(this, arguments)
+      }
+    })()),
+    (e.nextInitializedTickWithinOneWord = (function () {
+      var e = g(
+        v().mark(function e(n, r, i) {
+          return v().wrap(function (e) {
+            for (;;)
+              switch ((e.prev = e.next)) {
+                case 0:
+                  throw new Error(t.ERROR_MESSAGE)
+                case 1:
+                case 'end':
+                  return e.stop()
+              }
+          }, e)
+        }),
+      )
+      return function (t, n, r) {
+        return e.apply(this, arguments)
+      }
+    })()),
+    t
+  )
+})()
+function $(t, e) {
+  for (var n = 0; n < t.length - 1; n++) if (e(t[n], t[n + 1]) > 0) return !1
+  return !0
+}
+function J(t, e) {
+  return t.index - e.index
+}
+Z.ERROR_MESSAGE = 'No tick data provider was given'
+var tt = (function () {
+  function t() {}
+  return (
+    (t.validateList = function (t, e) {
+      e > 0 || i(!1),
+        t.every(function (t) {
+          return t.index % e == 0
+        }) || i(!1),
+        r.equal(
+          t.reduce(function (t, e) {
+            return r.add(t, e.liquidityNet)
+          }, O),
+          O,
+        ) || i(!1),
+        $(t, J) || i(!1)
+    }),
+    (t.isBelowSmallest = function (t, e) {
+      return t.length > 0 || i(!1), e < t[0].index
+    }),
+    (t.isAtOrAboveLargest = function (t, e) {
+      return t.length > 0 || i(!1), e >= t[t.length - 1].index
+    }),
+    (t.getTick = function (t, e) {
+      var n = t[this.binarySearch(t, e)]
+      return n.index !== e && i(!1), n
+    }),
+    (t.binarySearch = function (t, e) {
+      this.isBelowSmallest(t, e) && i(!1)
+      for (var n, r = 0, o = t.length - 1; ; ) {
+        if (t[(n = Math.floor((r + o) / 2))].index <= e && (n === t.length - 1 || t[n + 1].index > e)) return n
+        t[n].index < e ? (r = n + 1) : (o = n - 1)
+      }
+    }),
+    (t.nextInitializedTick = function (e, n, r) {
+      return r
+        ? (t.isBelowSmallest(e, n) && i(!1), t.isAtOrAboveLargest(e, n) ? e[e.length - 1] : e[this.binarySearch(e, n)])
+        : (this.isAtOrAboveLargest(e, n) && i(!1), this.isBelowSmallest(e, n) ? e[0] : e[this.binarySearch(e, n) + 1])
+    }),
+    (t.nextInitializedTickWithinOneWord = function (e, n, r, i) {
+      var o = Math.floor(n / i)
+      if (r) {
+        var a = ((o >> 8) << 8) * i
+        if (t.isBelowSmallest(e, n)) return [a, !1]
+        var u = t.nextInitializedTick(e, n, r).index,
+          c = Math.max(a, u)
+        return [c, c === u]
+      }
+      var s = (((1 + ((o + 1) >> 8)) << 8) - 1) * i
+      if (this.isAtOrAboveLargest(e, n)) return [s, !1]
+      var p = this.nextInitializedTick(e, n, r).index,
+        l = Math.min(s, p)
+      return [l, l === p]
+    }),
+    t
+  )
+})()
+function et(t) {
+  var e = r.BigInt(t).toString(16)
+  return e.length % 2 != 0 && (e = '0' + e), '0x' + e
+}
+function nt(t, e) {
+  var n = t.pools.reduce(
+      function (t, e, n) {
+        var r = t.inputToken,
+          i = t.path,
+          o = t.types,
+          a = e.token0.equals(r) ? e.token1 : e.token0
+        return 0 === n
+          ? { inputToken: a, types: ['address', 'uint24', 'address'], path: [r.address, e.fee, a.address] }
+          : { inputToken: a, types: [].concat(o, ['uint24', 'address']), path: [].concat(i, [e.fee, a.address]) }
+      },
+      { inputToken: t.input.wrapped, path: [], types: [] },
+    ),
+    r = n.path,
+    i = n.types
+  return e ? u.pack(i.reverse(), r.reverse()) : u.pack(i, r)
+}
+function rt(t, e) {
+  var i = r.leftShift(r.BigInt(t), r.BigInt(192)),
+    o = r.BigInt(e),
+    a = r.divide(i, o)
+  return n.sqrt(a)
+}
+function it(t, e, n) {
+  if (r.greaterThan(t, e)) {
+    var i = [e, t]
+    ;(t = i[0]), (e = i[1])
+  }
+  var o = r.divide(r.multiply(t, e), N)
+  return r.divide(r.multiply(r.BigInt(n), o), r.subtract(e, t))
+}
+function ot(t, e, n) {
+  if (r.greaterThan(t, e)) {
+    var i = [e, t]
+    ;(t = i[0]), (e = i[1])
+  }
+  var o = r.multiply(r.multiply(r.BigInt(n), t), e),
+    a = r.multiply(N, r.subtract(e, t))
+  return r.divide(o, a)
+}
+function at(t, e, n) {
+  if (r.greaterThan(t, e)) {
+    var i = [e, t]
+    ;(t = i[0]), (e = i[1])
+  }
+  return r.divide(r.multiply(r.BigInt(n), N), r.subtract(e, t))
+}
+function ut(t, e, n, i, o, a) {
+  if (r.greaterThan(e, n)) {
+    var u = [n, e]
+    ;(e = u[0]), (n = u[1])
+  }
+  var c = a ? ot : it
+  if (r.lessThanOrEqual(t, e)) return c(e, n, i)
+  if (r.lessThan(t, n)) {
+    var s = c(t, n, i),
+      p = at(e, t, o)
+    return r.lessThan(s, p) ? s : p
+  }
+  return at(e, n, o)
+}
+var ct = r.exponentiate(r.BigInt(2), r.BigInt(128)),
+  st = (function () {
+    function t() {}
+    return (
+      (t.getTokensOwed = function (t, e, n, i, o) {
+        return [r.divide(r.multiply(dt(i, t), n), ct), r.divide(r.multiply(dt(o, e), n), ct)]
+      }),
+      t
+    )
+  })()
+function pt(t, e, i) {
+  var o = V.getSqrtRatioAtTick(i),
+    a = r.multiply(o, o)
+  return t.sortsBefore(e) ? new n.Price(t, e, _, a) : new n.Price(t, e, a, _)
+}
+var lt = r.exponentiate(r.BigInt(2), r.BigInt(256))
+function dt(t, e) {
+  var n = r.subtract(t, e)
+  return r.lessThan(n, O) ? r.add(lt, n) : n
+}
+var ft = (function () {
+    function t() {}
+    return (
+      (t.getFeeGrowthInside = function (t, e, n, r, i, o, a) {
+        var u, c, s, p
+        return (
+          i >= n
+            ? ((u = t.feeGrowthOutside0X128), (c = t.feeGrowthOutside1X128))
+            : ((u = dt(o, t.feeGrowthOutside0X128)), (c = dt(a, t.feeGrowthOutside1X128))),
+          i < r
+            ? ((s = e.feeGrowthOutside0X128), (p = e.feeGrowthOutside1X128))
+            : ((s = dt(o, e.feeGrowthOutside0X128)), (p = dt(a, e.feeGrowthOutside1X128))),
+          [dt(dt(o, u), s), dt(dt(a, c), p)]
+        )
+      }),
+      t
+    )
+  })(),
+  mt = function (t) {
+    var e = t.index,
+      n = t.liquidityGross,
+      o = t.liquidityNet
+    ;(e >= V.MIN_TICK && e <= V.MAX_TICK) || i(!1),
+      (this.index = e),
+      (this.liquidityGross = r.BigInt(n)),
+      (this.liquidityNet = r.BigInt(o))
+  },
+  ht = (function () {
+    function t(t, e) {
+      var n = t.map(function (t) {
+        return t instanceof mt ? t : new mt(t)
+      })
+      tt.validateList(n, e), (this.ticks = n)
+    }
+    var e = t.prototype
+    return (
+      (e.getTick = (function () {
+        var t = g(
+          v().mark(function t(e) {
+            return v().wrap(
+              function (t) {
+                for (;;)
+                  switch ((t.prev = t.next)) {
+                    case 0:
+                      return t.abrupt('return', tt.getTick(this.ticks, e))
+                    case 1:
+                    case 'end':
+                      return t.stop()
+                  }
+              },
+              t,
+              this,
+            )
+          }),
+        )
+        return function (e) {
+          return t.apply(this, arguments)
+        }
+      })()),
+      (e.nextInitializedTickWithinOneWord = (function () {
+        var t = g(
+          v().mark(function t(e, n, r) {
+            return v().wrap(
+              function (t) {
+                for (;;)
+                  switch ((t.prev = t.next)) {
+                    case 0:
+                      return t.abrupt('return', tt.nextInitializedTickWithinOneWord(this.ticks, e, n, r))
+                    case 1:
+                    case 'end':
+                      return t.stop()
+                  }
+              },
+              t,
+              this,
+            )
+          }),
+        )
+        return function (e, n, r) {
+          return t.apply(this, arguments)
+        }
+      })()),
+      t
+    )
+  })(),
+  vt = new Z(),
+  yt = (function () {
+    function t(t, e, n, o, a, u, c) {
+      void 0 === c && (c = vt), (Number.isInteger(n) && n < 1e6) || i(!1)
+      var s = V.getSqrtRatioAtTick(u),
+        p = V.getSqrtRatioAtTick(u + 1)
+      ;(r.greaterThanOrEqual(r.BigInt(o), s) && r.lessThanOrEqual(r.BigInt(o), p)) || i(!1)
+      var l = t.sortsBefore(e) ? [t, e] : [e, t]
+      ;(this.token0 = l[0]),
+        (this.token1 = l[1]),
+        (this.fee = n),
+        (this.sqrtRatioX96 = r.BigInt(o)),
+        (this.liquidity = r.BigInt(a)),
+        (this.tickCurrent = u),
+        (this.tickDataProvider = Array.isArray(c) ? new ht(c, P[n]) : c)
+    }
+    t.getAddress = function (t, e, n, r, i) {
+      return F({
+        factoryAddress: null != i ? i : '0x1F98431c8aD98523631AE4a59f267346ea31F984',
+        fee: n,
+        tokenA: t,
+        tokenB: e,
+        initCodeHashManualOverride: r,
+      })
+    }
+    var e = t.prototype
+    return (
+      (e.involvesToken = function (t) {
+        return t.equals(this.token0) || t.equals(this.token1)
+      }),
+      (e.priceOf = function (t) {
+        return this.involvesToken(t) || i(!1), t.equals(this.token0) ? this.token0Price : this.token1Price
+      }),
+      (e.getOutputAmount = (function () {
+        var e = g(
+          v().mark(function e(o, a) {
+            var u, c, s, p, l
+            return v().wrap(
+              function (e) {
+                for (;;)
+                  switch ((e.prev = e.next)) {
+                    case 0:
+                      return (
+                        this.involvesToken(o.currency) || i(!1),
+                        (u = o.currency.equals(this.token0)),
+                        (e.next = 4),
+                        this.swap(u, o.quotient, a)
+                      )
+                    case 4:
+                      return (
+                        (s = (c = e.sent).sqrtRatioX96),
+                        (p = c.liquidity),
+                        (l = c.tickCurrent),
+                        e.abrupt('return', [
+                          n.CurrencyAmount.fromRawAmount(
+                            u ? this.token1 : this.token0,
+                            r.multiply(c.amountCalculated, C),
+                          ),
+                          new t(this.token0, this.token1, this.fee, s, p, l, this.tickDataProvider),
+                        ])
+                      )
+                    case 11:
+                    case 'end':
+                      return e.stop()
+                  }
+              },
+              e,
+              this,
+            )
+          }),
+        )
+        return function (t, n) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      (e.getInputAmount = (function () {
+        var e = g(
+          v().mark(function e(o, a) {
+            var u, c, s, p, l
+            return v().wrap(
+              function (e) {
+                for (;;)
+                  switch ((e.prev = e.next)) {
+                    case 0:
+                      return (
+                        (o.currency.isToken && this.involvesToken(o.currency)) || i(!1),
+                        (u = o.currency.equals(this.token1)),
+                        (e.next = 4),
+                        this.swap(u, r.multiply(o.quotient, C), a)
+                      )
+                    case 4:
+                      return (
+                        (s = (c = e.sent).sqrtRatioX96),
+                        (p = c.liquidity),
+                        (l = c.tickCurrent),
+                        e.abrupt('return', [
+                          n.CurrencyAmount.fromRawAmount(u ? this.token0 : this.token1, c.amountCalculated),
+                          new t(this.token0, this.token1, this.fee, s, p, l, this.tickDataProvider),
+                        ])
+                      )
+                    case 11:
+                    case 'end':
+                      return e.stop()
+                  }
+              },
+              e,
+              this,
+            )
+          }),
+        )
+        return function (t, n) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      (e.swap = (function () {
+        var t = g(
+          v().mark(function t(e, n, i) {
+            return v().wrap(
+              function (t) {
+                for (;;)
+                  switch ((t.prev = t.next)) {
+                    case 0:
+                      return t.abrupt(
+                        'return',
+                        z(
+                          r.BigInt(this.fee),
+                          this.sqrtRatioX96,
+                          this.tickCurrent,
+                          this.liquidity,
+                          this.tickSpacing,
+                          this.tickDataProvider,
+                          e,
+                          n,
+                          i,
+                        ),
+                      )
+                    case 1:
+                    case 'end':
+                      return t.stop()
+                  }
+              },
+              t,
+              this,
+            )
+          }),
+        )
+        return function (e, n, r) {
+          return t.apply(this, arguments)
+        }
+      })()),
+      T(t, [
+        {
+          key: 'token0Price',
+          get: function () {
+            var t
+            return null != (t = this._token0Price)
+              ? t
+              : (this._token0Price = new n.Price(
+                  this.token0,
+                  this.token1,
+                  _,
+                  r.multiply(this.sqrtRatioX96, this.sqrtRatioX96),
+                ))
+          },
+        },
+        {
+          key: 'token1Price',
+          get: function () {
+            var t
+            return null != (t = this._token1Price)
+              ? t
+              : (this._token1Price = new n.Price(
+                  this.token1,
+                  this.token0,
+                  r.multiply(this.sqrtRatioX96, this.sqrtRatioX96),
+                  _,
+                ))
+          },
+        },
+        {
+          key: 'chainId',
+          get: function () {
+            return this.token0.chainId
+          },
+        },
+        {
+          key: 'tickSpacing',
+          get: function () {
+            return P[this.fee]
+          },
+        },
+      ]),
+      t
+    )
+  })(),
+  kt = (function () {
+    function t(t) {
+      var e = t.pool,
+        n = t.liquidity,
+        o = t.tickLower,
+        a = t.tickUpper
+      ;(this._token0Amount = null),
+        (this._token1Amount = null),
+        (this._mintAmounts = null),
+        o < a || i(!1),
+        (o >= V.MIN_TICK && o % e.tickSpacing == 0) || i(!1),
+        (a <= V.MAX_TICK && a % e.tickSpacing == 0) || i(!1),
+        (this.pool = e),
+        (this.tickLower = o),
+        (this.tickUpper = a),
+        (this.liquidity = r.BigInt(n))
+    }
+    var e = t.prototype
+    return (
+      (e.ratiosAfterSlippage = function (t) {
+        var e = this.pool.token0Price.asFraction.multiply(new n.Percent(1).subtract(t)),
+          i = this.pool.token0Price.asFraction.multiply(t.add(1)),
+          o = rt(e.numerator, e.denominator)
+        r.lessThanOrEqual(o, V.MIN_SQRT_RATIO) && (o = r.add(V.MIN_SQRT_RATIO, r.BigInt(1)))
+        var a = rt(i.numerator, i.denominator)
+        return (
+          r.greaterThanOrEqual(a, V.MAX_SQRT_RATIO) && (a = r.subtract(V.MAX_SQRT_RATIO, r.BigInt(1))),
+          { sqrtRatioX96Lower: o, sqrtRatioX96Upper: a }
+        )
+      }),
+      (e.mintAmountsWithSlippage = function (e) {
+        var n = this.ratiosAfterSlippage(e),
+          r = n.sqrtRatioX96Upper,
+          i = n.sqrtRatioX96Lower,
+          o = new yt(this.pool.token0, this.pool.token1, this.pool.fee, i, 0, V.getTickAtSqrtRatio(i)),
+          a = new yt(this.pool.token0, this.pool.token1, this.pool.fee, r, 0, V.getTickAtSqrtRatio(r)),
+          u = t.fromAmounts(
+            w({ pool: this.pool, tickLower: this.tickLower, tickUpper: this.tickUpper }, this.mintAmounts, {
+              useFullPrecision: !1,
+            }),
+          )
+        return {
+          amount0: new t({ pool: a, liquidity: u.liquidity, tickLower: this.tickLower, tickUpper: this.tickUpper })
+            .mintAmounts.amount0,
+          amount1: new t({ pool: o, liquidity: u.liquidity, tickLower: this.tickLower, tickUpper: this.tickUpper })
+            .mintAmounts.amount1,
+        }
+      }),
+      (e.burnAmountsWithSlippage = function (e) {
+        var n = this.ratiosAfterSlippage(e),
+          r = n.sqrtRatioX96Upper,
+          i = n.sqrtRatioX96Lower,
+          o = new yt(this.pool.token0, this.pool.token1, this.pool.fee, i, 0, V.getTickAtSqrtRatio(i)),
+          a = new t({
+            pool: new yt(this.pool.token0, this.pool.token1, this.pool.fee, r, 0, V.getTickAtSqrtRatio(r)),
+            liquidity: this.liquidity,
+            tickLower: this.tickLower,
+            tickUpper: this.tickUpper,
+          }).amount0,
+          u = new t({ pool: o, liquidity: this.liquidity, tickLower: this.tickLower, tickUpper: this.tickUpper })
+            .amount1
+        return { amount0: a.quotient, amount1: u.quotient }
+      }),
+      (t.fromAmounts = function (e) {
+        var n = e.pool,
+          r = e.tickLower,
+          i = e.tickUpper,
+          o = e.amount0,
+          a = e.amount1,
+          u = e.useFullPrecision,
+          c = V.getSqrtRatioAtTick(r),
+          s = V.getSqrtRatioAtTick(i)
+        return new t({ pool: n, tickLower: r, tickUpper: i, liquidity: ut(n.sqrtRatioX96, c, s, o, a, u) })
+      }),
+      (t.fromAmount0 = function (e) {
+        return t.fromAmounts({
+          pool: e.pool,
+          tickLower: e.tickLower,
+          tickUpper: e.tickUpper,
+          amount0: e.amount0,
+          amount1: n.MaxUint256,
+          useFullPrecision: e.useFullPrecision,
+        })
+      }),
+      (t.fromAmount1 = function (e) {
+        return t.fromAmounts({
+          pool: e.pool,
+          tickLower: e.tickLower,
+          tickUpper: e.tickUpper,
+          amount0: n.MaxUint256,
+          amount1: e.amount1,
+          useFullPrecision: !0,
+        })
+      }),
+      T(t, [
+        {
+          key: 'token0PriceLower',
+          get: function () {
+            return pt(this.pool.token0, this.pool.token1, this.tickLower)
+          },
+        },
+        {
+          key: 'token0PriceUpper',
+          get: function () {
+            return pt(this.pool.token0, this.pool.token1, this.tickUpper)
+          },
+        },
+        {
+          key: 'amount0',
+          get: function () {
+            return (
+              null === this._token0Amount &&
+                (this._token0Amount = n.CurrencyAmount.fromRawAmount(
+                  this.pool.token0,
+                  this.pool.tickCurrent < this.tickLower
+                    ? M.getAmount0Delta(
+                        V.getSqrtRatioAtTick(this.tickLower),
+                        V.getSqrtRatioAtTick(this.tickUpper),
+                        this.liquidity,
+                        !1,
+                      )
+                    : this.pool.tickCurrent < this.tickUpper
+                      ? M.getAmount0Delta(
+                          this.pool.sqrtRatioX96,
+                          V.getSqrtRatioAtTick(this.tickUpper),
+                          this.liquidity,
+                          !1,
+                        )
+                      : O,
+                )),
+              this._token0Amount
+            )
+          },
+        },
+        {
+          key: 'amount1',
+          get: function () {
+            return (
+              null === this._token1Amount &&
+                (this._token1Amount = n.CurrencyAmount.fromRawAmount(
+                  this.pool.token1,
+                  this.pool.tickCurrent < this.tickLower
+                    ? O
+                    : M.getAmount1Delta(
+                        V.getSqrtRatioAtTick(this.tickLower),
+                        this.pool.tickCurrent < this.tickUpper
+                          ? this.pool.sqrtRatioX96
+                          : V.getSqrtRatioAtTick(this.tickUpper),
+                        this.liquidity,
+                        !1,
+                      ),
+                )),
+              this._token1Amount
+            )
+          },
+        },
+        {
+          key: 'mintAmounts',
+          get: function () {
+            return null === this._mintAmounts
+              ? this.pool.tickCurrent < this.tickLower
+                ? {
+                    amount0: M.getAmount0Delta(
+                      V.getSqrtRatioAtTick(this.tickLower),
+                      V.getSqrtRatioAtTick(this.tickUpper),
+                      this.liquidity,
+                      !0,
+                    ),
+                    amount1: O,
+                  }
+                : this.pool.tickCurrent < this.tickUpper
+                  ? {
+                      amount0: M.getAmount0Delta(
+                        this.pool.sqrtRatioX96,
+                        V.getSqrtRatioAtTick(this.tickUpper),
+                        this.liquidity,
+                        !0,
+                      ),
+                      amount1: M.getAmount1Delta(
+                        V.getSqrtRatioAtTick(this.tickLower),
+                        this.pool.sqrtRatioX96,
+                        this.liquidity,
+                        !0,
+                      ),
+                    }
+                  : {
+                      amount0: O,
+                      amount1: M.getAmount1Delta(
+                        V.getSqrtRatioAtTick(this.tickLower),
+                        V.getSqrtRatioAtTick(this.tickUpper),
+                        this.liquidity,
+                        !0,
+                      ),
+                    }
+              : this._mintAmounts
+          },
+        },
+      ]),
+      t
+    )
+  })(),
+  gt = (function () {
+    function t(t, e, n) {
+      ;(this._midPrice = null), t.length > 0 || i(!1)
+      var r = t[0].chainId
+      t.every(function (t) {
+        return t.chainId === r
+      }) || i(!1)
+      var o = e.wrapped
+      t[0].involvesToken(o) || i(!1), t[t.length - 1].involvesToken(n.wrapped) || i(!1)
+      for (var a, u = [o], c = I(t.entries()); !(a = c()).done; ) {
+        var s = a.value,
+          p = s[1],
+          l = u[s[0]]
+        l.equals(p.token0) || l.equals(p.token1) || i(!1)
+        var d = l.equals(p.token0) ? p.token1 : p.token0
+        u.push(d)
+      }
+      ;(this.pools = t), (this.tokenPath = u), (this.input = e), (this.output = null != n ? n : u[u.length - 1])
+    }
+    return (
+      T(t, [
+        {
+          key: 'chainId',
+          get: function () {
+            return this.pools[0].chainId
+          },
+        },
+        {
+          key: 'midPrice',
+          get: function () {
+            if (null !== this._midPrice) return this._midPrice
+            var t = this.pools.slice(1).reduce(
+              function (t, e) {
+                var n = t.price
+                return t.nextInput.equals(e.token0)
+                  ? { nextInput: e.token1, price: n.multiply(e.token0Price) }
+                  : { nextInput: e.token0, price: n.multiply(e.token1Price) }
+              },
+              this.pools[0].token0.equals(this.input.wrapped)
+                ? { nextInput: this.pools[0].token1, price: this.pools[0].token0Price }
+                : { nextInput: this.pools[0].token0, price: this.pools[0].token1Price },
+            ).price
+            return (this._midPrice = new n.Price(this.input, this.output, t.denominator, t.numerator))
+          },
+        },
+      ]),
+      t
+    )
+  })()
+function At(t, e) {
+  return (
+    t.inputAmount.currency.equals(e.inputAmount.currency) || i(!1),
+    t.outputAmount.currency.equals(e.outputAmount.currency) || i(!1),
+    t.outputAmount.equalTo(e.outputAmount)
+      ? t.inputAmount.equalTo(e.inputAmount)
+        ? t.swaps.reduce(function (t, e) {
+            return t + e.route.tokenPath.length
+          }, 0) -
+          e.swaps.reduce(function (t, e) {
+            return t + e.route.tokenPath.length
+          }, 0)
+        : t.inputAmount.lessThan(e.inputAmount)
+          ? -1
+          : 1
+      : t.outputAmount.lessThan(e.outputAmount)
+        ? 1
+        : -1
+  )
+}
+var Tt = (function () {
+    function t(t) {
+      var e = t.routes,
+        n = t.tradeType,
+        r = e[0].inputAmount.currency,
+        o = e[0].outputAmount.currency
+      e.every(function (t) {
+        return r.wrapped.equals(t.route.input.wrapped)
+      }) || i(!1),
+        e.every(function (t) {
+          return o.wrapped.equals(t.route.output.wrapped)
+        }) || i(!1)
+      for (
+        var a,
+          u = e
+            .map(function (t) {
+              return t.route.pools.length
+            })
+            .reduce(function (t, e) {
+              return t + e
+            }, 0),
+          c = new Set(),
+          s = I(e);
+        !(a = s()).done;
+
+      )
+        for (var p, l = I(a.value.route.pools); !(p = l()).done; ) {
+          var d = p.value
+          c.add(yt.getAddress(d.token0, d.token1, d.fee))
+        }
+      u !== c.size && i(!1), (this.swaps = e), (this.tradeType = n)
+    }
+    ;(t.exactIn = (function () {
+      var e = g(
+        v().mark(function e(r, i) {
+          return v().wrap(function (e) {
+            for (;;)
+              switch ((e.prev = e.next)) {
+                case 0:
+                  return e.abrupt('return', t.fromRoute(r, i, n.TradeType.EXACT_INPUT))
+                case 1:
+                case 'end':
+                  return e.stop()
+              }
+          }, e)
+        }),
+      )
+      return function (t, n) {
+        return e.apply(this, arguments)
+      }
+    })()),
+      (t.exactOut = (function () {
+        var e = g(
+          v().mark(function e(r, i) {
+            return v().wrap(function (e) {
+              for (;;)
+                switch ((e.prev = e.next)) {
+                  case 0:
+                    return e.abrupt('return', t.fromRoute(r, i, n.TradeType.EXACT_OUTPUT))
+                  case 1:
+                  case 'end':
+                    return e.stop()
+                }
+            }, e)
+          }),
+        )
+        return function (t, n) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      (t.fromRoute = (function () {
+        var e = g(
+          v().mark(function e(r, o, a) {
+            var u, c, s, p, l, d, f
+            return v().wrap(function (e) {
+              for (;;)
+                switch ((e.prev = e.next)) {
+                  case 0:
+                    if (((u = new Array(r.tokenPath.length)), a !== n.TradeType.EXACT_INPUT)) {
+                      e.next = 19
+                      break
+                    }
+                    o.currency.equals(r.input) || i(!1), (u[0] = o.wrapped), (p = 0)
+                  case 5:
+                    if (!(p < r.tokenPath.length - 1)) {
+                      e.next = 15
+                      break
+                    }
+                    return (l = r.pools[p]), (e.next = 9), l.getOutputAmount(u[p])
+                  case 9:
+                    u[p + 1] = e.sent[0]
+                  case 12:
+                    p++, (e.next = 5)
+                    break
+                  case 15:
+                    ;(c = n.CurrencyAmount.fromFractionalAmount(r.input, o.numerator, o.denominator)),
+                      (s = n.CurrencyAmount.fromFractionalAmount(
+                        r.output,
+                        u[u.length - 1].numerator,
+                        u[u.length - 1].denominator,
+                      )),
+                      (e.next = 34)
+                    break
+                  case 19:
+                    o.currency.equals(r.output) || i(!1), (u[u.length - 1] = o.wrapped), (d = r.tokenPath.length - 1)
+                  case 22:
+                    if (!(d > 0)) {
+                      e.next = 32
+                      break
+                    }
+                    return (f = r.pools[d - 1]), (e.next = 26), f.getInputAmount(u[d])
+                  case 26:
+                    u[d - 1] = e.sent[0]
+                  case 29:
+                    d--, (e.next = 22)
+                    break
+                  case 32:
+                    ;(c = n.CurrencyAmount.fromFractionalAmount(r.input, u[0].numerator, u[0].denominator)),
+                      (s = n.CurrencyAmount.fromFractionalAmount(r.output, o.numerator, o.denominator))
+                  case 34:
+                    return e.abrupt(
+                      'return',
+                      new t({ routes: [{ inputAmount: c, outputAmount: s, route: r }], tradeType: a }),
+                    )
+                  case 35:
+                  case 'end':
+                    return e.stop()
+                }
+            }, e)
+          }),
+        )
+        return function (t, n, r) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      (t.fromRoutes = (function () {
+        var e = g(
+          v().mark(function e(r, o) {
+            var a, u, c, s, p, l, d, f, m, h, y, k, g
+            return v().wrap(function (e) {
+              for (;;)
+                switch ((e.prev = e.next)) {
+                  case 0:
+                    ;(a = []), (u = I(r))
+                  case 2:
+                    if ((c = u()).done) {
+                      e.next = 43
+                      break
+                    }
+                    if (
+                      ((p = (s = c.value).route),
+                      (l = s.amount),
+                      (d = new Array(p.tokenPath.length)),
+                      (f = void 0),
+                      (m = void 0),
+                      o !== n.TradeType.EXACT_INPUT)
+                    ) {
+                      e.next = 25
+                      break
+                    }
+                    l.currency.equals(p.input) || i(!1),
+                      (f = n.CurrencyAmount.fromFractionalAmount(p.input, l.numerator, l.denominator)),
+                      (d[0] = n.CurrencyAmount.fromFractionalAmount(p.input.wrapped, l.numerator, l.denominator)),
+                      (h = 0)
+                  case 12:
+                    if (!(h < p.tokenPath.length - 1)) {
+                      e.next = 22
+                      break
+                    }
+                    return (y = p.pools[h]), (e.next = 16), y.getOutputAmount(d[h])
+                  case 16:
+                    d[h + 1] = e.sent[0]
+                  case 19:
+                    h++, (e.next = 12)
+                    break
+                  case 22:
+                    ;(m = n.CurrencyAmount.fromFractionalAmount(
+                      p.output,
+                      d[d.length - 1].numerator,
+                      d[d.length - 1].denominator,
+                    )),
+                      (e.next = 40)
+                    break
+                  case 25:
+                    l.currency.equals(p.output) || i(!1),
+                      (m = n.CurrencyAmount.fromFractionalAmount(p.output, l.numerator, l.denominator)),
+                      (d[d.length - 1] = n.CurrencyAmount.fromFractionalAmount(
+                        p.output.wrapped,
+                        l.numerator,
+                        l.denominator,
+                      )),
+                      (k = p.tokenPath.length - 1)
+                  case 29:
+                    if (!(k > 0)) {
+                      e.next = 39
+                      break
+                    }
+                    return (g = p.pools[k - 1]), (e.next = 33), g.getInputAmount(d[k])
+                  case 33:
+                    d[k - 1] = e.sent[0]
+                  case 36:
+                    k--, (e.next = 29)
+                    break
+                  case 39:
+                    f = n.CurrencyAmount.fromFractionalAmount(p.input, d[0].numerator, d[0].denominator)
+                  case 40:
+                    a.push({ route: p, inputAmount: f, outputAmount: m })
+                  case 41:
+                    e.next = 2
+                    break
+                  case 43:
+                    return e.abrupt('return', new t({ routes: a, tradeType: o }))
+                  case 44:
+                  case 'end':
+                    return e.stop()
+                }
+            }, e)
+          }),
+        )
+        return function (t, n) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      (t.createUncheckedTrade = function (e) {
+        return new t(
+          w({}, e, { routes: [{ inputAmount: e.inputAmount, outputAmount: e.outputAmount, route: e.route }] }),
+        )
+      }),
+      (t.createUncheckedTradeWithMultipleRoutes = function (e) {
+        return new t(e)
+      })
+    var e = t.prototype
+    return (
+      (e.minimumAmountOut = function (t, e) {
+        if (
+          (void 0 === e && (e = this.outputAmount), t.lessThan(O) && i(!1), this.tradeType === n.TradeType.EXACT_OUTPUT)
+        )
+          return e
+        var r = new n.Fraction(S).add(t).invert().multiply(e.quotient).quotient
+        return n.CurrencyAmount.fromRawAmount(e.currency, r)
+      }),
+      (e.maximumAmountIn = function (t, e) {
+        if (
+          (void 0 === e && (e = this.inputAmount), t.lessThan(O) && i(!1), this.tradeType === n.TradeType.EXACT_INPUT)
+        )
+          return e
+        var r = new n.Fraction(S).add(t).multiply(e.quotient).quotient
+        return n.CurrencyAmount.fromRawAmount(e.currency, r)
+      }),
+      (e.worstExecutionPrice = function (t) {
+        return new n.Price(
+          this.inputAmount.currency,
+          this.outputAmount.currency,
+          this.maximumAmountIn(t).quotient,
+          this.minimumAmountOut(t).quotient,
+        )
+      }),
+      (t.bestTradeExactIn = (function () {
+        var e = g(
+          v().mark(function e(r, o, a, u, c, s, p) {
+            var l, d, f, m, h, y, k, g, A, T, w
+            return v().wrap(
+              function (e) {
+                for (;;)
+                  switch ((e.prev = e.next)) {
+                    case 0:
+                      ;(f = void 0 === (d = (l = void 0 === u ? {} : u).maxNumResults) ? 3 : d),
+                        (h = void 0 === (m = l.maxHops) ? 3 : m),
+                        void 0 === c && (c = []),
+                        void 0 === s && (s = o),
+                        void 0 === p && (p = []),
+                        r.length > 0 || i(!1),
+                        h > 0 || i(!1),
+                        o === s || c.length > 0 || i(!1),
+                        (y = s.wrapped),
+                        (k = a.wrapped),
+                        (g = 0)
+                    case 10:
+                      if (!(g < r.length)) {
+                        e.next = 46
+                        break
+                      }
+                      if ((A = r[g]).token0.equals(y.currency) || A.token1.equals(y.currency)) {
+                        e.next = 14
+                        break
+                      }
+                      return e.abrupt('continue', 43)
+                    case 14:
+                      return (T = void 0), (e.prev = 15), (e.next = 19), A.getOutputAmount(y)
+                    case 19:
+                      ;(T = e.sent[0]), (e.next = 28)
+                      break
+                    case 23:
+                      if (((e.prev = 23), (e.t0 = e.catch(15)), !e.t0.isInsufficientInputAmountError)) {
+                        e.next = 27
+                        break
+                      }
+                      return e.abrupt('continue', 43)
+                    case 27:
+                      throw e.t0
+                    case 28:
+                      if (!T.currency.isToken || !T.currency.equals(k)) {
+                        e.next = 39
+                        break
+                      }
+                      return (
+                        (e.t1 = n.sortedInsert),
+                        (e.t2 = p),
+                        (e.next = 33),
+                        t.fromRoute(new gt([].concat(c, [A]), o.currency, a), o, n.TradeType.EXACT_INPUT)
+                      )
+                    case 33:
+                      ;(e.t3 = e.sent), (e.t4 = f), (e.t5 = At), (0, e.t1)(e.t2, e.t3, e.t4, e.t5), (e.next = 43)
+                      break
+                    case 39:
+                      if (!(h > 1 && r.length > 1)) {
+                        e.next = 43
+                        break
+                      }
+                      return (
+                        (w = r.slice(0, g).concat(r.slice(g + 1, r.length))),
+                        (e.next = 43),
+                        t.bestTradeExactIn(w, o, a, { maxNumResults: f, maxHops: h - 1 }, [].concat(c, [A]), T, p)
+                      )
+                    case 43:
+                      g++, (e.next = 10)
+                      break
+                    case 46:
+                      return e.abrupt('return', p)
+                    case 47:
+                    case 'end':
+                      return e.stop()
+                  }
+              },
+              e,
+              null,
+              [[15, 23]],
+            )
+          }),
+        )
+        return function (t, n, r, i, o, a, u) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      (t.bestTradeExactOut = (function () {
+        var e = g(
+          v().mark(function e(r, o, a, u, c, s, p) {
+            var l, d, f, m, h, y, k, g, A, T, w
+            return v().wrap(
+              function (e) {
+                for (;;)
+                  switch ((e.prev = e.next)) {
+                    case 0:
+                      ;(f = void 0 === (d = (l = void 0 === u ? {} : u).maxNumResults) ? 3 : d),
+                        (h = void 0 === (m = l.maxHops) ? 3 : m),
+                        void 0 === c && (c = []),
+                        void 0 === s && (s = a),
+                        void 0 === p && (p = []),
+                        r.length > 0 || i(!1),
+                        h > 0 || i(!1),
+                        a === s || c.length > 0 || i(!1),
+                        (y = s.wrapped),
+                        (k = o.wrapped),
+                        (g = 0)
+                    case 10:
+                      if (!(g < r.length)) {
+                        e.next = 46
+                        break
+                      }
+                      if ((A = r[g]).token0.equals(y.currency) || A.token1.equals(y.currency)) {
+                        e.next = 14
+                        break
+                      }
+                      return e.abrupt('continue', 43)
+                    case 14:
+                      return (T = void 0), (e.prev = 15), (e.next = 19), A.getInputAmount(y)
+                    case 19:
+                      ;(T = e.sent[0]), (e.next = 28)
+                      break
+                    case 23:
+                      if (((e.prev = 23), (e.t0 = e.catch(15)), !e.t0.isInsufficientReservesError)) {
+                        e.next = 27
+                        break
+                      }
+                      return e.abrupt('continue', 43)
+                    case 27:
+                      throw e.t0
+                    case 28:
+                      if (!T.currency.equals(k)) {
+                        e.next = 39
+                        break
+                      }
+                      return (
+                        (e.t1 = n.sortedInsert),
+                        (e.t2 = p),
+                        (e.next = 33),
+                        t.fromRoute(new gt([A].concat(c), o, a.currency), a, n.TradeType.EXACT_OUTPUT)
+                      )
+                    case 33:
+                      ;(e.t3 = e.sent), (e.t4 = f), (e.t5 = At), (0, e.t1)(e.t2, e.t3, e.t4, e.t5), (e.next = 43)
+                      break
+                    case 39:
+                      if (!(h > 1 && r.length > 1)) {
+                        e.next = 43
+                        break
+                      }
+                      return (
+                        (w = r.slice(0, g).concat(r.slice(g + 1, r.length))),
+                        (e.next = 43),
+                        t.bestTradeExactOut(w, o, a, { maxNumResults: f, maxHops: h - 1 }, [A].concat(c), T, p)
+                      )
+                    case 43:
+                      g++, (e.next = 10)
+                      break
+                    case 46:
+                      return e.abrupt('return', p)
+                    case 47:
+                    case 'end':
+                      return e.stop()
+                  }
+              },
+              e,
+              null,
+              [[15, 23]],
+            )
+          }),
+        )
+        return function (t, n, r, i, o, a, u) {
+          return e.apply(this, arguments)
+        }
+      })()),
+      T(t, [
+        {
+          key: 'route',
+          get: function () {
+            return 1 !== this.swaps.length && i(!1), this.swaps[0].route
+          },
+        },
+        {
+          key: 'inputAmount',
+          get: function () {
+            if (this._inputAmount) return this._inputAmount
+            var t = this.swaps[0].inputAmount.currency,
+              e = this.swaps
+                .map(function (t) {
+                  return t.inputAmount
+                })
+                .reduce(
+                  function (t, e) {
+                    return t.add(e)
+                  },
+                  n.CurrencyAmount.fromRawAmount(t, 0),
+                )
+            return (this._inputAmount = e), this._inputAmount
+          },
+        },
+        {
+          key: 'outputAmount',
+          get: function () {
+            if (this._outputAmount) return this._outputAmount
+            var t = this.swaps[0].outputAmount.currency,
+              e = this.swaps
+                .map(function (t) {
+                  return t.outputAmount
+                })
+                .reduce(
+                  function (t, e) {
+                    return t.add(e)
+                  },
+                  n.CurrencyAmount.fromRawAmount(t, 0),
+                )
+            return (this._outputAmount = e), this._outputAmount
+          },
+        },
+        {
+          key: 'executionPrice',
+          get: function () {
+            var t
+            return null != (t = this._executionPrice)
+              ? t
+              : (this._executionPrice = new n.Price(
+                  this.inputAmount.currency,
+                  this.outputAmount.currency,
+                  this.inputAmount.quotient,
+                  this.outputAmount.quotient,
+                ))
+          },
+        },
+        {
+          key: 'priceImpact',
+          get: function () {
+            if (this._priceImpact) return this._priceImpact
+            for (
+              var t, e = n.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0), r = I(this.swaps);
+              !(t = r()).done;
+
+            ) {
+              var i = t.value
+              e = e.add(i.route.midPrice.quote(i.inputAmount))
+            }
+            var o = e.subtract(this.outputAmount).divide(e)
+            return (this._priceImpact = new n.Percent(o.numerator, o.denominator)), this._priceImpact
+          },
+        },
+      ]),
+      t
+    )
+  })(),
+  wt = (function () {
+    function t() {}
+    return (
+      (t.encodeMulticall = function (e) {
+        return Array.isArray(e) || (e = [e]), 1 === e.length ? e[0] : t.INTERFACE.encodeFunctionData('multicall', [e])
+      }),
+      (t.decodeMulticall = function (e) {
+        return t.INTERFACE.decodeFunctionData('multicall', e).data
+      }),
+      t
+    )
+  })()
+wt.INTERFACE = new o.Interface(c.abi)
+var xt = (function () {
+  function t() {}
+  return (
+    (t.encodePermit = function (e, n) {
+      return 'nonce' in n
+        ? t.INTERFACE.encodeFunctionData('selfPermitAllowed', [e.address, et(n.nonce), et(n.expiry), n.v, n.r, n.s])
+        : t.INTERFACE.encodeFunctionData('selfPermit', [e.address, et(n.amount), et(n.deadline), n.v, n.r, n.s])
+    }),
+    t
+  )
+})()
+xt.INTERFACE = new o.Interface(p.abi)
+var It = (function () {
+  function t() {}
+  return (
+    (t.encodeFeeBips = function (t) {
+      return et(t.multiply(1e4).quotient)
+    }),
+    (t.encodeUnwrapWETH9 = function (e, r, i) {
+      if (((r = n.validateAndParseAddress(r)), i)) {
+        var o = this.encodeFeeBips(i.fee),
+          a = n.validateAndParseAddress(i.recipient)
+        return t.INTERFACE.encodeFunctionData('unwrapWETH9WithFee', [et(e), r, o, a])
+      }
+      return t.INTERFACE.encodeFunctionData('unwrapWETH9', [et(e), r])
+    }),
+    (t.encodeSweepToken = function (e, r, i, o) {
+      if (((i = n.validateAndParseAddress(i)), o)) {
+        var a = this.encodeFeeBips(o.fee),
+          u = n.validateAndParseAddress(o.recipient)
+        return t.INTERFACE.encodeFunctionData('sweepTokenWithFee', [e.address, et(r), i, a, u])
+      }
+      return t.INTERFACE.encodeFunctionData('sweepToken', [e.address, et(r), i])
+    }),
+    (t.encodeRefundETH = function () {
+      return t.INTERFACE.encodeFunctionData('refundETH')
+    }),
+    t
+  )
+})()
+It.INTERFACE = new o.Interface(l.abi)
+var qt = ['expectedCurrencyOwed0', 'expectedCurrencyOwed1'],
+  bt = et(r.subtract(r.exponentiate(r.BigInt(2), r.BigInt(128)), r.BigInt(1)))
+function Rt(t) {
+  return Object.keys(t).some(function (t) {
+    return 'recipient' === t
+  })
+}
+var Et = {
+    Permit: [
+      { name: 'spender', type: 'address' },
+      { name: 'tokenId', type: 'uint256' },
+      { name: 'nonce', type: 'uint256' },
+      { name: 'deadline', type: 'uint256' },
+    ],
+  },
+  Pt = (function () {
+    function t() {}
+    return (
+      (t.encodeCreate = function (e) {
+        return t.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [
+          e.token0.address,
+          e.token1.address,
+          e.fee,
+          et(e.sqrtRatioX96),
+        ])
+      }),
+      (t.createCallParameters = function (t) {
+        return { calldata: this.encodeCreate(t), value: et(0) }
+      }),
+      (t.addCallParameters = function (e, o) {
+        r.greaterThan(e.liquidity, O) || i(!1)
+        var a = [],
+          u = e.mintAmounts,
+          c = u.amount0,
+          s = u.amount1,
+          p = e.mintAmountsWithSlippage(o.slippageTolerance),
+          l = et(p.amount0),
+          d = et(p.amount1),
+          f = et(o.deadline)
+        if (
+          (Rt(o) && o.createPool && a.push(this.encodeCreate(e.pool)),
+          o.token0Permit && a.push(xt.encodePermit(e.pool.token0, o.token0Permit)),
+          o.token1Permit && a.push(xt.encodePermit(e.pool.token1, o.token1Permit)),
+          Rt(o))
+        ) {
+          var m = n.validateAndParseAddress(o.recipient)
+          a.push(
+            t.INTERFACE.encodeFunctionData('mint', [
+              {
+                token0: e.pool.token0.address,
+                token1: e.pool.token1.address,
+                fee: e.pool.fee,
+                tickLower: e.tickLower,
+                tickUpper: e.tickUpper,
+                amount0Desired: et(c),
+                amount1Desired: et(s),
+                amount0Min: l,
+                amount1Min: d,
+                recipient: m,
+                deadline: f,
+              },
+            ]),
+          )
+        } else
+          a.push(
+            t.INTERFACE.encodeFunctionData('increaseLiquidity', [
+              {
+                tokenId: et(o.tokenId),
+                amount0Desired: et(c),
+                amount1Desired: et(s),
+                amount0Min: l,
+                amount1Min: d,
+                deadline: f,
+              },
+            ]),
+          )
+        var h = et(0)
+        if (o.useNative) {
+          var v = o.useNative.wrapped
+          e.pool.token0.equals(v) || e.pool.token1.equals(v) || i(!1)
+          var y = e.pool.token0.equals(v) ? c : s
+          r.greaterThan(y, O) && a.push(It.encodeRefundETH()), (h = et(y))
+        }
+        return { calldata: wt.encodeMulticall(a), value: h }
+      }),
+      (t.encodeCollect = function (e) {
+        var r = [],
+          i = et(e.tokenId),
+          o = e.expectedCurrencyOwed0.currency.isNative || e.expectedCurrencyOwed1.currency.isNative,
+          a = n.validateAndParseAddress(e.recipient)
+        if (
+          (r.push(
+            t.INTERFACE.encodeFunctionData('collect', [
+              { tokenId: i, recipient: o ? b : a, amount0Max: bt, amount1Max: bt },
+            ]),
+          ),
+          o)
+        ) {
+          var u = e.expectedCurrencyOwed0.currency.isNative
+              ? e.expectedCurrencyOwed1.currency
+              : e.expectedCurrencyOwed0.currency,
+            c = e.expectedCurrencyOwed0.currency.isNative
+              ? e.expectedCurrencyOwed1.quotient
+              : e.expectedCurrencyOwed0.quotient
+          r.push(
+            It.encodeUnwrapWETH9(
+              e.expectedCurrencyOwed0.currency.isNative
+                ? e.expectedCurrencyOwed0.quotient
+                : e.expectedCurrencyOwed1.quotient,
+              a,
+            ),
+          ),
+            r.push(It.encodeSweepToken(u, c, a))
+        }
+        return r
+      }),
+      (t.collectCallParameters = function (e) {
+        var n = t.encodeCollect(e)
+        return { calldata: wt.encodeMulticall(n), value: et(0) }
+      }),
+      (t.removeCallParameters = function (e, o) {
+        var a = [],
+          u = et(o.deadline),
+          c = et(o.tokenId),
+          s = new kt({
+            pool: e.pool,
+            liquidity: o.liquidityPercentage.multiply(e.liquidity).quotient,
+            tickLower: e.tickLower,
+            tickUpper: e.tickUpper,
+          })
+        r.greaterThan(s.liquidity, O) || i(!1)
+        var p = s.burnAmountsWithSlippage(o.slippageTolerance),
+          l = p.amount0,
+          d = p.amount1
+        o.permit &&
+          a.push(
+            t.INTERFACE.encodeFunctionData('permit', [
+              n.validateAndParseAddress(o.permit.spender),
+              c,
+              et(o.permit.deadline),
+              o.permit.v,
+              o.permit.r,
+              o.permit.s,
+            ]),
+          ),
+          a.push(
+            t.INTERFACE.encodeFunctionData('decreaseLiquidity', [
+              { tokenId: c, liquidity: et(s.liquidity), amount0Min: et(l), amount1Min: et(d), deadline: u },
+            ]),
+          )
+        var f = o.collectOptions,
+          m = f.expectedCurrencyOwed0,
+          h = f.expectedCurrencyOwed1,
+          v = (function (t, e) {
+            if (null == t) return {}
+            var n,
+              r,
+              i = {},
+              o = Object.keys(t)
+            for (r = 0; r < o.length; r++) e.indexOf((n = o[r])) >= 0 || (i[n] = t[n])
+            return i
+          })(f, qt)
+        return (
+          a.push.apply(
+            a,
+            t.encodeCollect(
+              w(
+                {
+                  tokenId: et(o.tokenId),
+                  expectedCurrencyOwed0: m.add(n.CurrencyAmount.fromRawAmount(m.currency, l)),
+                  expectedCurrencyOwed1: h.add(n.CurrencyAmount.fromRawAmount(h.currency, d)),
+                },
+                v,
+              ),
+            ),
+          ),
+          o.liquidityPercentage.equalTo(S)
+            ? o.burnToken && a.push(t.INTERFACE.encodeFunctionData('burn', [c]))
+            : !0 === o.burnToken && i(!1),
+          { calldata: wt.encodeMulticall(a), value: et(0) }
+        )
+      }),
+      (t.safeTransferFromParameters = function (e) {
+        var r = n.validateAndParseAddress(e.recipient),
+          i = n.validateAndParseAddress(e.sender)
+        return {
+          calldata: e.data
+            ? t.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256,bytes)', [
+                i,
+                r,
+                et(e.tokenId),
+                e.data,
+              ])
+            : t.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256)', [i, r, et(e.tokenId)]),
+          value: et(0),
+        }
+      }),
+      (t.getPermitData = function (t, e, n) {
+        return {
+          domain: { name: 'Uniswap V3 Positions NFT-V1', chainId: n, version: '1', verifyingContract: e },
+          types: Et,
+          values: t,
+        }
+      }),
+      t
+    )
+  })()
+Pt.INTERFACE = new o.Interface(s.abi)
+var Ct = (function () {
+  function t() {}
+  return (
+    (t.quoteCallParameters = function (t, e, r, o) {
+      void 0 === o && (o = {})
+      var a,
+        u = 1 === t.pools.length,
+        c = et(e.quotient),
+        s = o.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE
+      if (u) {
+        var p,
+          l,
+          d = {
+            tokenIn: t.tokenPath[0].address,
+            tokenOut: t.tokenPath[1].address,
+            fee: t.pools[0].fee,
+            sqrtPriceLimitX96: et(null != (p = null == (l = o) ? void 0 : l.sqrtPriceLimitX96) ? p : 0),
+          },
+          f = w({}, d, r === n.TradeType.EXACT_INPUT ? { amountIn: c } : { amount: c })
+        a = s.encodeFunctionData(
+          r === n.TradeType.EXACT_INPUT ? 'quoteExactInputSingle' : 'quoteExactOutputSingle',
+          o.useQuoterV2 ? [f] : [d.tokenIn, d.tokenOut, d.fee, c, d.sqrtPriceLimitX96],
+        )
+      } else {
+        var m
+        void 0 !== (null == (m = o) ? void 0 : m.sqrtPriceLimitX96) && i(!1)
+        var h = nt(t, r === n.TradeType.EXACT_OUTPUT)
+        a = s.encodeFunctionData(r === n.TradeType.EXACT_INPUT ? 'quoteExactInput' : 'quoteExactOutput', [h, c])
+      }
+      return { calldata: a, value: et(0) }
+    }),
+    t
+  )
+})()
+;(Ct.V1INTERFACE = new o.Interface(d.abi)), (Ct.V2INTERFACE = new o.Interface(f.abi))
+var Ot = (function () {
+  function t() {}
+  return (
+    (t.encodeClaim = function (e, r) {
+      var i,
+        o = []
+      o.push(t.INTERFACE.encodeFunctionData('unstakeToken', [this._encodeIncentiveKey(e), et(r.tokenId)]))
+      var a = n.validateAndParseAddress(r.recipient),
+        u = null != (i = r.amount) ? i : 0
+      return o.push(t.INTERFACE.encodeFunctionData('claimReward', [e.rewardToken.address, a, et(u)])), o
+    }),
+    (t.collectRewards = function (e, n) {
+      e = Array.isArray(e) ? e : [e]
+      for (var r = [], i = 0; i < e.length; i++) {
+        var o = e[i]
+        ;(r = r.concat(this.encodeClaim(o, n))).push(
+          t.INTERFACE.encodeFunctionData('stakeToken', [this._encodeIncentiveKey(o), et(n.tokenId)]),
+        )
+      }
+      return { calldata: wt.encodeMulticall(r), value: et(0) }
+    }),
+    (t.withdrawToken = function (e, r) {
+      var i = []
+      e = Array.isArray(e) ? e : [e]
+      for (var o = { tokenId: r.tokenId, recipient: r.recipient, amount: r.amount }, a = 0; a < e.length; a++)
+        i = i.concat(this.encodeClaim(e[a], o))
+      var u = n.validateAndParseAddress(r.owner)
+      return (
+        i.push(t.INTERFACE.encodeFunctionData('withdrawToken', [et(r.tokenId), u, r.data ? r.data : et(0)])),
+        { calldata: wt.encodeMulticall(i), value: et(0) }
+      )
+    }),
+    (t.encodeDeposit = function (e) {
+      var n
+      if ((e = Array.isArray(e) ? e : [e]).length > 1) {
+        for (var r = [], i = 0; i < e.length; i++) r.push(this._encodeIncentiveKey(e[i]))
+        n = o.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI + '[]'], [r])
+      } else n = o.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(e[0])])
+      return n
+    }),
+    (t._encodeIncentiveKey = function (t) {
+      var e = t.pool,
+        r = e.token0,
+        i = e.token1,
+        o = e.fee,
+        a = n.validateAndParseAddress(t.refundee)
+      return {
+        rewardToken: t.rewardToken.address,
+        pool: yt.getAddress(r, i, o),
+        startTime: et(t.startTime),
+        endTime: et(t.endTime),
+        refundee: a,
+      }
+    }),
+    t
+  )
+})()
+;(Ot.INTERFACE = new o.Interface(m.abi)),
+  (Ot.INCENTIVE_KEY_ABI =
+    'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)')
+var St = (function () {
+  function t() {}
+  return (
+    (t.swapCallParameters = function (e, r) {
+      Array.isArray(e) || (e = [e])
+      var o = e[0],
+        a = o.inputAmount.currency.wrapped,
+        u = o.outputAmount.currency.wrapped
+      e.every(function (t) {
+        return t.inputAmount.currency.wrapped.equals(a)
+      }) || i(!1),
+        e.every(function (t) {
+          return t.outputAmount.currency.wrapped.equals(u)
+        }) || i(!1)
+      var c = [],
+        s = n.CurrencyAmount.fromRawAmount(e[0].inputAmount.currency, 0),
+        p = n.CurrencyAmount.fromRawAmount(e[0].outputAmount.currency, 0),
+        l = e.reduce(function (t, e) {
+          return t.add(e.minimumAmountOut(r.slippageTolerance))
+        }, p),
+        d = o.inputAmount.currency.isNative && o.tradeType === n.TradeType.EXACT_OUTPUT,
+        f = o.outputAmount.currency.isNative,
+        m = f || !!r.fee,
+        h = o.inputAmount.currency.isNative
+          ? e.reduce(function (t, e) {
+              return t.add(e.maximumAmountIn(r.slippageTolerance))
+            }, s)
+          : s
+      r.inputTokenPermit &&
+        (o.inputAmount.currency.isToken || i(!1), c.push(xt.encodePermit(o.inputAmount.currency, r.inputTokenPermit)))
+      for (var v, y = n.validateAndParseAddress(r.recipient), k = et(r.deadline), g = I(e); !(v = g()).done; )
+        for (var A, T = v.value, w = I(T.swaps); !(A = w()).done; ) {
+          var x = A.value,
+            q = x.route,
+            R = x.outputAmount,
+            E = et(T.maximumAmountIn(r.slippageTolerance, x.inputAmount).quotient),
+            P = et(T.minimumAmountOut(r.slippageTolerance, R).quotient)
+          if (1 === q.pools.length)
+            if (T.tradeType === n.TradeType.EXACT_INPUT) {
+              var C,
+                O = {
+                  tokenIn: q.tokenPath[0].address,
+                  tokenOut: q.tokenPath[1].address,
+                  fee: q.pools[0].fee,
+                  recipient: m ? b : y,
+                  deadline: k,
+                  amountIn: E,
+                  amountOutMinimum: P,
+                  sqrtPriceLimitX96: et(null != (C = r.sqrtPriceLimitX96) ? C : 0),
+                }
+              c.push(t.INTERFACE.encodeFunctionData('exactInputSingle', [O]))
+            } else {
+              var S,
+                N = {
+                  tokenIn: q.tokenPath[0].address,
+                  tokenOut: q.tokenPath[1].address,
+                  fee: q.pools[0].fee,
+                  recipient: m ? b : y,
+                  deadline: k,
+                  amountOut: P,
+                  amountInMaximum: E,
+                  sqrtPriceLimitX96: et(null != (S = r.sqrtPriceLimitX96) ? S : 0),
+                }
+              c.push(t.INTERFACE.encodeFunctionData('exactOutputSingle', [N]))
+            }
+          else {
+            void 0 !== r.sqrtPriceLimitX96 && i(!1)
+            var _ = nt(q, T.tradeType === n.TradeType.EXACT_OUTPUT)
+            c.push(
+              T.tradeType === n.TradeType.EXACT_INPUT
+                ? t.INTERFACE.encodeFunctionData('exactInput', [
+                    { path: _, recipient: m ? b : y, deadline: k, amountIn: E, amountOutMinimum: P },
+                  ])
+                : t.INTERFACE.encodeFunctionData('exactOutput', [
+                    { path: _, recipient: m ? b : y, deadline: k, amountOut: P, amountInMaximum: E },
+                  ]),
+            )
+          }
+        }
+      return (
+        m &&
+          c.push(
+            r.fee
+              ? f
+                ? It.encodeUnwrapWETH9(l.quotient, y, r.fee)
+                : It.encodeSweepToken(o.outputAmount.currency.wrapped, l.quotient, y, r.fee)
+              : It.encodeUnwrapWETH9(l.quotient, y),
+          ),
+        d && c.push(It.encodeRefundETH()),
+        { calldata: wt.encodeMulticall(c), value: et(h.quotient) }
+      )
+    }),
+    t
+  )
+})()
+;(St.INTERFACE = new o.Interface(h.abi)),
+  (exports.ADDRESS_ZERO = b),
+  (exports.FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984'),
+  (exports.FullMath = L),
+  (exports.LiquidityMath = W),
+  (exports.Multicall = wt),
+  (exports.NoTickDataProvider = Z),
+  (exports.NonfungiblePositionManager = Pt),
+  (exports.POOL_INIT_CODE_HASH = R),
+  (exports.Payments = It),
+  (exports.Pool = yt),
+  (exports.Position = kt),
+  (exports.PositionLibrary = st),
+  (exports.Route = gt),
+  (exports.SelfPermit = xt),
+  (exports.SqrtPriceMath = M),
+  (exports.Staker = Ot),
+  (exports.SwapMath = D),
+  (exports.SwapQuoter = Ct),
+  (exports.SwapRouter = St),
+  (exports.TICK_SPACINGS = P),
+  (exports.Tick = mt),
+  (exports.TickLibrary = ft),
+  (exports.TickList = tt),
+  (exports.TickListDataProvider = ht),
+  (exports.TickMath = V),
+  (exports.Trade = Tt),
+  (exports.computePoolAddress = F),
+  (exports.encodeRouteToPath = nt),
+  (exports.encodeSqrtRatioX96 = rt),
+  (exports.isSorted = $),
+  (exports.maxLiquidityForAmounts = ut),
+  (exports.mostSignificantBit = G),
+  (exports.nearestUsableTick = function (t, e) {
+    ;(Number.isInteger(t) && Number.isInteger(e)) || i(!1),
+      e > 0 || i(!1),
+      (t >= V.MIN_TICK && t <= V.MAX_TICK) || i(!1)
+    var n = Math.round(t / e) * e
+    return n < V.MIN_TICK ? n + e : n > V.MAX_TICK ? n - e : n
+  }),
+  (exports.poolInitCodeHash = E),
+  (exports.priceToClosestTick = function (t) {
+    var e = t.baseCurrency.sortsBefore(t.quoteCurrency),
+      n = e ? rt(t.numerator, t.denominator) : rt(t.denominator, t.numerator),
+      r = V.getTickAtSqrtRatio(n),
+      i = pt(t.baseCurrency, t.quoteCurrency, r + 1)
+    return e ? t.lessThan(i) || r++ : t.greaterThan(i) || r++, r
+  }),
+  (exports.subIn256 = dt),
+  (exports.tickToPrice = pt),
+  (exports.toHex = et),
+  (exports.tradeComparator = At),
+  (exports.v3Swap = z)
 //# sourceMappingURL=v3-sdk.cjs.production.min.js.map
diff --git a/dist/v3-sdk.esm.js b/dist/v3-sdk.esm.js
index 7e441b32b8b66b9c55cee81304eb8edd15b099c1..c04f0cf6de79988ba8c26cb835f7f531c9e2aecb 100644
--- a/dist/v3-sdk.esm.js
+++ b/dist/v3-sdk.esm.js
@@ -1,476 +1,605 @@
-import { ChainId, computeZksyncCreate2Address, MaxUint256, sqrt, Price, CurrencyAmount, Percent, TradeType, Fraction, sortedInsert, validateAndParseAddress } from '@uniswap/sdk-core';
-import JSBI from 'jsbi';
-import invariant from 'tiny-invariant';
-import { defaultAbiCoder, Interface } from '@ethersproject/abi';
-import { getCreate2Address } from '@ethersproject/address';
-import { keccak256, pack } from '@ethersproject/solidity';
-import IMulticall from '@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json';
-import INonfungiblePositionManager from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json';
-import ISelfPermit from '@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json';
-import IPeripheryPaymentsWithFee from '@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json';
-import IQuoter from '@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json';
-import IQuoterV2 from '@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json';
-import IUniswapV3Staker from '@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json';
-import ISwapRouter from '@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json';
+import {
+  ChainId,
+  computeZksyncCreate2Address,
+  MaxUint256,
+  sqrt,
+  Price,
+  CurrencyAmount,
+  Percent,
+  TradeType,
+  Fraction,
+  sortedInsert,
+  validateAndParseAddress,
+} from '@uniswap/sdk-core'
+import JSBI from 'jsbi'
+import invariant from 'tiny-invariant'
+import { defaultAbiCoder, Interface } from '@ethersproject/abi'
+import { getCreate2Address } from '@ethersproject/address'
+import { keccak256, pack } from '@ethersproject/solidity'
+import IMulticall from '@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json'
+import INonfungiblePositionManager from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'
+import ISelfPermit from '@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json'
+import IPeripheryPaymentsWithFee from '@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json'
+import IQuoter from '@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json'
+import IQuoterV2 from '@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json'
+import IUniswapV3Staker from '@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json'
+import ISwapRouter from '@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'
 
 function _regeneratorRuntime() {
   _regeneratorRuntime = function () {
-    return e;
-  };
+    return e
+  }
   var t,
     e = {},
     r = Object.prototype,
     n = r.hasOwnProperty,
-    o = Object.defineProperty || function (t, e, r) {
-      t[e] = r.value;
-    },
-    i = "function" == typeof Symbol ? Symbol : {},
-    a = i.iterator || "@@iterator",
-    c = i.asyncIterator || "@@asyncIterator",
-    u = i.toStringTag || "@@toStringTag";
+    o =
+      Object.defineProperty ||
+      function (t, e, r) {
+        t[e] = r.value
+      },
+    i = 'function' == typeof Symbol ? Symbol : {},
+    a = i.iterator || '@@iterator',
+    c = i.asyncIterator || '@@asyncIterator',
+    u = i.toStringTag || '@@toStringTag'
   function define(t, e, r) {
-    return Object.defineProperty(t, e, {
-      value: r,
-      enumerable: !0,
-      configurable: !0,
-      writable: !0
-    }), t[e];
+    return (
+      Object.defineProperty(t, e, {
+        value: r,
+        enumerable: !0,
+        configurable: !0,
+        writable: !0,
+      }),
+      t[e]
+    )
   }
   try {
-    define({}, "");
+    define({}, '')
   } catch (t) {
     define = function (t, e, r) {
-      return t[e] = r;
-    };
+      return (t[e] = r)
+    }
   }
   function wrap(t, e, r, n) {
     var i = e && e.prototype instanceof Generator ? e : Generator,
       a = Object.create(i.prototype),
-      c = new Context(n || []);
-    return o(a, "_invoke", {
-      value: makeInvokeMethod(t, r, c)
-    }), a;
+      c = new Context(n || [])
+    return (
+      o(a, '_invoke', {
+        value: makeInvokeMethod(t, r, c),
+      }),
+      a
+    )
   }
   function tryCatch(t, e, r) {
     try {
       return {
-        type: "normal",
-        arg: t.call(e, r)
-      };
+        type: 'normal',
+        arg: t.call(e, r),
+      }
     } catch (t) {
       return {
-        type: "throw",
-        arg: t
-      };
+        type: 'throw',
+        arg: t,
+      }
     }
   }
-  e.wrap = wrap;
-  var h = "suspendedStart",
-    l = "suspendedYield",
-    f = "executing",
-    s = "completed",
-    y = {};
+  e.wrap = wrap
+  var h = 'suspendedStart',
+    l = 'suspendedYield',
+    f = 'executing',
+    s = 'completed',
+    y = {}
   function Generator() {}
   function GeneratorFunction() {}
   function GeneratorFunctionPrototype() {}
-  var p = {};
+  var p = {}
   define(p, a, function () {
-    return this;
-  });
+    return this
+  })
   var d = Object.getPrototypeOf,
-    v = d && d(d(values([])));
-  v && v !== r && n.call(v, a) && (p = v);
-  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
+    v = d && d(d(values([])))
+  v && v !== r && n.call(v, a) && (p = v)
+  var g = (GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p))
   function defineIteratorMethods(t) {
-    ["next", "throw", "return"].forEach(function (e) {
+    ;['next', 'throw', 'return'].forEach(function (e) {
       define(t, e, function (t) {
-        return this._invoke(e, t);
-      });
-    });
+        return this._invoke(e, t)
+      })
+    })
   }
   function AsyncIterator(t, e) {
     function invoke(r, o, i, a) {
-      var c = tryCatch(t[r], t, o);
-      if ("throw" !== c.type) {
+      var c = tryCatch(t[r], t, o)
+      if ('throw' !== c.type) {
         var u = c.arg,
-          h = u.value;
-        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
-          invoke("next", t, i, a);
-        }, function (t) {
-          invoke("throw", t, i, a);
-        }) : e.resolve(h).then(function (t) {
-          u.value = t, i(u);
-        }, function (t) {
-          return invoke("throw", t, i, a);
-        });
+          h = u.value
+        return h && 'object' == typeof h && n.call(h, '__await')
+          ? e.resolve(h.__await).then(
+              function (t) {
+                invoke('next', t, i, a)
+              },
+              function (t) {
+                invoke('throw', t, i, a)
+              },
+            )
+          : e.resolve(h).then(
+              function (t) {
+                ;(u.value = t), i(u)
+              },
+              function (t) {
+                return invoke('throw', t, i, a)
+              },
+            )
       }
-      a(c.arg);
+      a(c.arg)
     }
-    var r;
-    o(this, "_invoke", {
+    var r
+    o(this, '_invoke', {
       value: function (t, n) {
         function callInvokeWithMethodAndArg() {
           return new e(function (e, r) {
-            invoke(t, n, e, r);
-          });
+            invoke(t, n, e, r)
+          })
         }
-        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
-      }
-    });
+        return (r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg())
+      },
+    })
   }
   function makeInvokeMethod(e, r, n) {
-    var o = h;
+    var o = h
     return function (i, a) {
-      if (o === f) throw new Error("Generator is already running");
+      if (o === f) throw new Error('Generator is already running')
       if (o === s) {
-        if ("throw" === i) throw a;
+        if ('throw' === i) throw a
         return {
           value: t,
-          done: !0
-        };
+          done: !0,
+        }
       }
-      for (n.method = i, n.arg = a;;) {
-        var c = n.delegate;
+      for (n.method = i, n.arg = a; ; ) {
+        var c = n.delegate
         if (c) {
-          var u = maybeInvokeDelegate(c, n);
+          var u = maybeInvokeDelegate(c, n)
           if (u) {
-            if (u === y) continue;
-            return u;
+            if (u === y) continue
+            return u
           }
         }
-        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
-          if (o === h) throw o = s, n.arg;
-          n.dispatchException(n.arg);
-        } else "return" === n.method && n.abrupt("return", n.arg);
-        o = f;
-        var p = tryCatch(e, r, n);
-        if ("normal" === p.type) {
-          if (o = n.done ? s : l, p.arg === y) continue;
+        if ('next' === n.method) n.sent = n._sent = n.arg
+        else if ('throw' === n.method) {
+          if (o === h) throw ((o = s), n.arg)
+          n.dispatchException(n.arg)
+        } else 'return' === n.method && n.abrupt('return', n.arg)
+        o = f
+        var p = tryCatch(e, r, n)
+        if ('normal' === p.type) {
+          if (((o = n.done ? s : l), p.arg === y)) continue
           return {
             value: p.arg,
-            done: n.done
-          };
+            done: n.done,
+          }
         }
-        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
+        'throw' === p.type && ((o = s), (n.method = 'throw'), (n.arg = p.arg))
       }
-    };
+    }
   }
   function maybeInvokeDelegate(e, r) {
     var n = r.method,
-      o = e.iterator[n];
-    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
-    var i = tryCatch(o, e.iterator, r.arg);
-    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
-    var a = i.arg;
-    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
+      o = e.iterator[n]
+    if (o === t)
+      return (
+        (r.delegate = null),
+        ('throw' === n &&
+          e.iterator.return &&
+          ((r.method = 'return'), (r.arg = t), maybeInvokeDelegate(e, r), 'throw' === r.method)) ||
+          ('return' !== n &&
+            ((r.method = 'throw'), (r.arg = new TypeError("The iterator does not provide a '" + n + "' method")))),
+        y
+      )
+    var i = tryCatch(o, e.iterator, r.arg)
+    if ('throw' === i.type) return (r.method = 'throw'), (r.arg = i.arg), (r.delegate = null), y
+    var a = i.arg
+    return a
+      ? a.done
+        ? ((r[e.resultName] = a.value),
+          (r.next = e.nextLoc),
+          'return' !== r.method && ((r.method = 'next'), (r.arg = t)),
+          (r.delegate = null),
+          y)
+        : a
+      : ((r.method = 'throw'), (r.arg = new TypeError('iterator result is not an object')), (r.delegate = null), y)
   }
   function pushTryEntry(t) {
     var e = {
-      tryLoc: t[0]
-    };
-    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
+      tryLoc: t[0],
+    }
+    1 in t && (e.catchLoc = t[1]), 2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])), this.tryEntries.push(e)
   }
   function resetTryEntry(t) {
-    var e = t.completion || {};
-    e.type = "normal", delete e.arg, t.completion = e;
+    var e = t.completion || {}
+    ;(e.type = 'normal'), delete e.arg, (t.completion = e)
   }
   function Context(t) {
-    this.tryEntries = [{
-      tryLoc: "root"
-    }], t.forEach(pushTryEntry, this), this.reset(!0);
+    ;(this.tryEntries = [
+      {
+        tryLoc: 'root',
+      },
+    ]),
+      t.forEach(pushTryEntry, this),
+      this.reset(!0)
   }
   function values(e) {
-    if (e || "" === e) {
-      var r = e[a];
-      if (r) return r.call(e);
-      if ("function" == typeof e.next) return e;
+    if (e || '' === e) {
+      var r = e[a]
+      if (r) return r.call(e)
+      if ('function' == typeof e.next) return e
       if (!isNaN(e.length)) {
         var o = -1,
           i = function next() {
-            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
-            return next.value = t, next.done = !0, next;
-          };
-        return i.next = i;
+            for (; ++o < e.length; ) if (n.call(e, o)) return (next.value = e[o]), (next.done = !1), next
+            return (next.value = t), (next.done = !0), next
+          }
+        return (i.next = i)
       }
     }
-    throw new TypeError(typeof e + " is not iterable");
-  }
-  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
-    value: GeneratorFunctionPrototype,
-    configurable: !0
-  }), o(GeneratorFunctionPrototype, "constructor", {
-    value: GeneratorFunction,
-    configurable: !0
-  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
-    var e = "function" == typeof t && t.constructor;
-    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
-  }, e.mark = function (t) {
-    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
-  }, e.awrap = function (t) {
-    return {
-      __await: t
-    };
-  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
-    return this;
-  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
-    void 0 === i && (i = Promise);
-    var a = new AsyncIterator(wrap(t, r, n, o), i);
-    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
-      return t.done ? t.value : a.next();
-    });
-  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
-    return this;
-  }), define(g, "toString", function () {
-    return "[object Generator]";
-  }), e.keys = function (t) {
-    var e = Object(t),
-      r = [];
-    for (var n in e) r.push(n);
-    return r.reverse(), function next() {
-      for (; r.length;) {
-        var t = r.pop();
-        if (t in e) return next.value = t, next.done = !1, next;
-      }
-      return next.done = !0, next;
-    };
-  }, e.values = values, Context.prototype = {
-    constructor: Context,
-    reset: function (e) {
-      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
-    },
-    stop: function () {
-      this.done = !0;
-      var t = this.tryEntries[0].completion;
-      if ("throw" === t.type) throw t.arg;
-      return this.rval;
-    },
-    dispatchException: function (e) {
-      if (this.done) throw e;
-      var r = this;
-      function handle(n, o) {
-        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
+    throw new TypeError(typeof e + ' is not iterable')
+  }
+  return (
+    (GeneratorFunction.prototype = GeneratorFunctionPrototype),
+    o(g, 'constructor', {
+      value: GeneratorFunctionPrototype,
+      configurable: !0,
+    }),
+    o(GeneratorFunctionPrototype, 'constructor', {
+      value: GeneratorFunction,
+      configurable: !0,
+    }),
+    (GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, 'GeneratorFunction')),
+    (e.isGeneratorFunction = function (t) {
+      var e = 'function' == typeof t && t.constructor
+      return !!e && (e === GeneratorFunction || 'GeneratorFunction' === (e.displayName || e.name))
+    }),
+    (e.mark = function (t) {
+      return (
+        Object.setPrototypeOf
+          ? Object.setPrototypeOf(t, GeneratorFunctionPrototype)
+          : ((t.__proto__ = GeneratorFunctionPrototype), define(t, u, 'GeneratorFunction')),
+        (t.prototype = Object.create(g)),
+        t
+      )
+    }),
+    (e.awrap = function (t) {
+      return {
+        __await: t,
       }
-      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
-        var i = this.tryEntries[o],
-          a = i.completion;
-        if ("root" === i.tryLoc) return handle("end");
-        if (i.tryLoc <= this.prev) {
-          var c = n.call(i, "catchLoc"),
-            u = n.call(i, "finallyLoc");
-          if (c && u) {
-            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
-            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
-          } else if (c) {
-            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
-          } else {
-            if (!u) throw new Error("try statement without catch or finally");
-            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
+    }),
+    defineIteratorMethods(AsyncIterator.prototype),
+    define(AsyncIterator.prototype, c, function () {
+      return this
+    }),
+    (e.AsyncIterator = AsyncIterator),
+    (e.async = function (t, r, n, o, i) {
+      void 0 === i && (i = Promise)
+      var a = new AsyncIterator(wrap(t, r, n, o), i)
+      return e.isGeneratorFunction(r)
+        ? a
+        : a.next().then(function (t) {
+            return t.done ? t.value : a.next()
+          })
+    }),
+    defineIteratorMethods(g),
+    define(g, u, 'Generator'),
+    define(g, a, function () {
+      return this
+    }),
+    define(g, 'toString', function () {
+      return '[object Generator]'
+    }),
+    (e.keys = function (t) {
+      var e = Object(t),
+        r = []
+      for (var n in e) r.push(n)
+      return (
+        r.reverse(),
+        function next() {
+          for (; r.length; ) {
+            var t = r.pop()
+            if (t in e) return (next.value = t), (next.done = !1), next
           }
+          return (next.done = !0), next
         }
-      }
-    },
-    abrupt: function (t, e) {
-      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
-        var o = this.tryEntries[r];
-        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
-          var i = o;
-          break;
+      )
+    }),
+    (e.values = values),
+    (Context.prototype = {
+      constructor: Context,
+      reset: function (e) {
+        if (
+          ((this.prev = 0),
+          (this.next = 0),
+          (this.sent = this._sent = t),
+          (this.done = !1),
+          (this.delegate = null),
+          (this.method = 'next'),
+          (this.arg = t),
+          this.tryEntries.forEach(resetTryEntry),
+          !e)
+        )
+          for (var r in this) 't' === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t)
+      },
+      stop: function () {
+        this.done = !0
+        var t = this.tryEntries[0].completion
+        if ('throw' === t.type) throw t.arg
+        return this.rval
+      },
+      dispatchException: function (e) {
+        if (this.done) throw e
+        var r = this
+        function handle(n, o) {
+          return (a.type = 'throw'), (a.arg = e), (r.next = n), o && ((r.method = 'next'), (r.arg = t)), !!o
         }
-      }
-      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
-      var a = i ? i.completion : {};
-      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
-    },
-    complete: function (t, e) {
-      if ("throw" === t.type) throw t.arg;
-      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
-    },
-    finish: function (t) {
-      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
-        var r = this.tryEntries[e];
-        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
-      }
-    },
-    catch: function (t) {
-      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
-        var r = this.tryEntries[e];
-        if (r.tryLoc === t) {
-          var n = r.completion;
-          if ("throw" === n.type) {
-            var o = n.arg;
-            resetTryEntry(r);
+        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
+          var i = this.tryEntries[o],
+            a = i.completion
+          if ('root' === i.tryLoc) return handle('end')
+          if (i.tryLoc <= this.prev) {
+            var c = n.call(i, 'catchLoc'),
+              u = n.call(i, 'finallyLoc')
+            if (c && u) {
+              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0)
+              if (this.prev < i.finallyLoc) return handle(i.finallyLoc)
+            } else if (c) {
+              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0)
+            } else {
+              if (!u) throw new Error('try statement without catch or finally')
+              if (this.prev < i.finallyLoc) return handle(i.finallyLoc)
+            }
           }
-          return o;
         }
-      }
-      throw new Error("illegal catch attempt");
-    },
-    delegateYield: function (e, r, n) {
-      return this.delegate = {
-        iterator: values(e),
-        resultName: r,
-        nextLoc: n
-      }, "next" === this.method && (this.arg = t), y;
-    }
-  }, e;
+      },
+      abrupt: function (t, e) {
+        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
+          var o = this.tryEntries[r]
+          if (o.tryLoc <= this.prev && n.call(o, 'finallyLoc') && this.prev < o.finallyLoc) {
+            var i = o
+            break
+          }
+        }
+        i && ('break' === t || 'continue' === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null)
+        var a = i ? i.completion : {}
+        return (a.type = t), (a.arg = e), i ? ((this.method = 'next'), (this.next = i.finallyLoc), y) : this.complete(a)
+      },
+      complete: function (t, e) {
+        if ('throw' === t.type) throw t.arg
+        return (
+          'break' === t.type || 'continue' === t.type
+            ? (this.next = t.arg)
+            : 'return' === t.type
+              ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
+              : 'normal' === t.type && e && (this.next = e),
+          y
+        )
+      },
+      finish: function (t) {
+        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+          var r = this.tryEntries[e]
+          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y
+        }
+      },
+      catch: function (t) {
+        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+          var r = this.tryEntries[e]
+          if (r.tryLoc === t) {
+            var n = r.completion
+            if ('throw' === n.type) {
+              var o = n.arg
+              resetTryEntry(r)
+            }
+            return o
+          }
+        }
+        throw new Error('illegal catch attempt')
+      },
+      delegateYield: function (e, r, n) {
+        return (
+          (this.delegate = {
+            iterator: values(e),
+            resultName: r,
+            nextLoc: n,
+          }),
+          'next' === this.method && (this.arg = t),
+          y
+        )
+      },
+    }),
+    e
+  )
 }
 function _toPrimitive(t, r) {
-  if ("object" != typeof t || !t) return t;
-  var e = t[Symbol.toPrimitive];
+  if ('object' != typeof t || !t) return t
+  var e = t[Symbol.toPrimitive]
   if (void 0 !== e) {
-    var i = e.call(t, r || "default");
-    if ("object" != typeof i) return i;
-    throw new TypeError("@@toPrimitive must return a primitive value.");
+    var i = e.call(t, r || 'default')
+    if ('object' != typeof i) return i
+    throw new TypeError('@@toPrimitive must return a primitive value.')
   }
-  return ("string" === r ? String : Number)(t);
+  return ('string' === r ? String : Number)(t)
 }
 function _toPropertyKey(t) {
-  var i = _toPrimitive(t, "string");
-  return "symbol" == typeof i ? i : String(i);
+  var i = _toPrimitive(t, 'string')
+  return 'symbol' == typeof i ? i : String(i)
 }
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
   try {
-    var info = gen[key](arg);
-    var value = info.value;
+    var info = gen[key](arg)
+    var value = info.value
   } catch (error) {
-    reject(error);
-    return;
+    reject(error)
+    return
   }
   if (info.done) {
-    resolve(value);
+    resolve(value)
   } else {
-    Promise.resolve(value).then(_next, _throw);
+    Promise.resolve(value).then(_next, _throw)
   }
 }
 function _asyncToGenerator(fn) {
   return function () {
     var self = this,
-      args = arguments;
+      args = arguments
     return new Promise(function (resolve, reject) {
-      var gen = fn.apply(self, args);
+      var gen = fn.apply(self, args)
       function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value)
       }
       function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err)
       }
-      _next(undefined);
-    });
-  };
+      _next(undefined)
+    })
+  }
 }
 function _defineProperties(target, props) {
   for (var i = 0; i < props.length; i++) {
-    var descriptor = props[i];
-    descriptor.enumerable = descriptor.enumerable || false;
-    descriptor.configurable = true;
-    if ("value" in descriptor) descriptor.writable = true;
-    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
+    var descriptor = props[i]
+    descriptor.enumerable = descriptor.enumerable || false
+    descriptor.configurable = true
+    if ('value' in descriptor) descriptor.writable = true
+    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor)
   }
 }
 function _createClass(Constructor, protoProps, staticProps) {
-  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
-  if (staticProps) _defineProperties(Constructor, staticProps);
-  Object.defineProperty(Constructor, "prototype", {
-    writable: false
-  });
-  return Constructor;
+  if (protoProps) _defineProperties(Constructor.prototype, protoProps)
+  if (staticProps) _defineProperties(Constructor, staticProps)
+  Object.defineProperty(Constructor, 'prototype', {
+    writable: false,
+  })
+  return Constructor
 }
 function _extends() {
-  _extends = Object.assign ? Object.assign.bind() : function (target) {
-    for (var i = 1; i < arguments.length; i++) {
-      var source = arguments[i];
-      for (var key in source) {
-        if (Object.prototype.hasOwnProperty.call(source, key)) {
-          target[key] = source[key];
+  _extends = Object.assign
+    ? Object.assign.bind()
+    : function (target) {
+        for (var i = 1; i < arguments.length; i++) {
+          var source = arguments[i]
+          for (var key in source) {
+            if (Object.prototype.hasOwnProperty.call(source, key)) {
+              target[key] = source[key]
+            }
+          }
         }
+        return target
       }
-    }
-    return target;
-  };
-  return _extends.apply(this, arguments);
+  return _extends.apply(this, arguments)
 }
 function _objectWithoutPropertiesLoose(source, excluded) {
-  if (source == null) return {};
-  var target = {};
-  var sourceKeys = Object.keys(source);
-  var key, i;
+  if (source == null) return {}
+  var target = {}
+  var sourceKeys = Object.keys(source)
+  var key, i
   for (i = 0; i < sourceKeys.length; i++) {
-    key = sourceKeys[i];
-    if (excluded.indexOf(key) >= 0) continue;
-    target[key] = source[key];
+    key = sourceKeys[i]
+    if (excluded.indexOf(key) >= 0) continue
+    target[key] = source[key]
   }
-  return target;
+  return target
 }
 function _unsupportedIterableToArray(o, minLen) {
-  if (!o) return;
-  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
-  var n = Object.prototype.toString.call(o).slice(8, -1);
-  if (n === "Object" && o.constructor) n = o.constructor.name;
-  if (n === "Map" || n === "Set") return Array.from(o);
-  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
+  if (!o) return
+  if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
+  var n = Object.prototype.toString.call(o).slice(8, -1)
+  if (n === 'Object' && o.constructor) n = o.constructor.name
+  if (n === 'Map' || n === 'Set') return Array.from(o)
+  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen)
 }
 function _arrayLikeToArray(arr, len) {
-  if (len == null || len > arr.length) len = arr.length;
-  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
-  return arr2;
+  if (len == null || len > arr.length) len = arr.length
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]
+  return arr2
 }
 function _createForOfIteratorHelperLoose(o, allowArrayLike) {
-  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
-  if (it) return (it = it.call(o)).next.bind(it);
-  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
-    if (it) o = it;
-    var i = 0;
+  var it = (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator']
+  if (it) return (it = it.call(o)).next.bind(it)
+  if (
+    Array.isArray(o) ||
+    (it = _unsupportedIterableToArray(o)) ||
+    (allowArrayLike && o && typeof o.length === 'number')
+  ) {
+    if (it) o = it
+    var i = 0
     return function () {
-      if (i >= o.length) return {
-        done: true
-      };
+      if (i >= o.length)
+        return {
+          done: true,
+        }
       return {
         done: false,
-        value: o[i++]
-      };
-    };
+        value: o[i++],
+      }
+    }
   }
-  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+  throw new TypeError(
+    'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
+  )
 }
 
-var _TICK_SPACINGS;
-var FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984';
-var ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
+var _TICK_SPACINGS
+var FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984'
+var ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'
 // @deprecated please use poolInitCodeHash(chainId: ChainId)
-var POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54';
+var POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'
 function poolInitCodeHash(chainId) {
   switch (chainId) {
     case ChainId.ZKSYNC:
-      return '0x010013f177ea1fcbc4520f9a3ca7cd2d1d77959e05aa66484027cb38e712aeed';
+      return '0x010013f177ea1fcbc4520f9a3ca7cd2d1d77959e05aa66484027cb38e712aeed'
     default:
-      return POOL_INIT_CODE_HASH;
+      return POOL_INIT_CODE_HASH
   }
 }
 /**
  * The default factory enabled fee amounts, denominated in hundredths of bips.
  */
-var FeeAmount;
-(function (FeeAmount) {
-  FeeAmount[FeeAmount["LOWEST"] = 100] = "LOWEST";
-  FeeAmount[FeeAmount["LOW_200"] = 200] = "LOW_200";
-  FeeAmount[FeeAmount["LOW_300"] = 300] = "LOW_300";
-  FeeAmount[FeeAmount["LOW_400"] = 400] = "LOW_400";
-  FeeAmount[FeeAmount["LOW"] = 500] = "LOW";
-  FeeAmount[FeeAmount["MEDIUM"] = 3000] = "MEDIUM";
-  FeeAmount[FeeAmount["HIGH"] = 10000] = "HIGH";
-})(FeeAmount || (FeeAmount = {}));
+var FeeAmount
+;(function (FeeAmount) {
+  FeeAmount[(FeeAmount['LOWEST'] = 100)] = 'LOWEST'
+  FeeAmount[(FeeAmount['LOW_200'] = 200)] = 'LOW_200'
+  FeeAmount[(FeeAmount['LOW_300'] = 300)] = 'LOW_300'
+  FeeAmount[(FeeAmount['LOW_400'] = 400)] = 'LOW_400'
+  FeeAmount[(FeeAmount['LOW'] = 500)] = 'LOW'
+  FeeAmount[(FeeAmount['MEDIUM'] = 3000)] = 'MEDIUM'
+  FeeAmount[(FeeAmount['HIGH'] = 10000)] = 'HIGH'
+  FeeAmount[(FeeAmount['LOWEST_SWAPMODE'] = 80)] = 'LOWEST_SWAPMODE'
+  FeeAmount[(FeeAmount['LOW_SWAPMODE'] = 350)] = 'LOW_SWAPMODE'
+  FeeAmount[(FeeAmount['LOW_SWAPMODE_450'] = 450)] = 'LOW_SWAPMODE_450'
+  FeeAmount[(FeeAmount['MEDIUM_SWAPMODE'] = 2500)] = 'MEDIUM_SWAPMODE'
+})(FeeAmount || (FeeAmount = {}))
 /**
  * The default factory tick spacings by fee amount.
  */
-var TICK_SPACINGS = (_TICK_SPACINGS = {}, _TICK_SPACINGS[FeeAmount.LOWEST] = 1, _TICK_SPACINGS[FeeAmount.LOW_200] = 4, _TICK_SPACINGS[FeeAmount.LOW_300] = 6, _TICK_SPACINGS[FeeAmount.LOW_400] = 8, _TICK_SPACINGS[FeeAmount.LOW] = 10, _TICK_SPACINGS[FeeAmount.MEDIUM] = 60, _TICK_SPACINGS[FeeAmount.HIGH] = 200, _TICK_SPACINGS);
+var TICK_SPACINGS =
+  ((_TICK_SPACINGS = {}),
+  (_TICK_SPACINGS[FeeAmount.LOWEST] = 1),
+  (_TICK_SPACINGS[FeeAmount.LOW_200] = 4),
+  (_TICK_SPACINGS[FeeAmount.LOW_300] = 6),
+  (_TICK_SPACINGS[FeeAmount.LOW_400] = 8),
+  (_TICK_SPACINGS[FeeAmount.LOW] = 10),
+  (_TICK_SPACINGS[FeeAmount.MEDIUM] = 60),
+  (_TICK_SPACINGS[FeeAmount.HIGH] = 200),
+  (_TICK_SPACINGS[FeeAmount.LOWEST_SWAPMODE] = 1),
+  (_TICK_SPACINGS[FeeAmount.LOW_SWAPMODE] = 10),
+  (_TICK_SPACINGS[FeeAmount.LOW_SWAPMODE_450] = 10),
+  (_TICK_SPACINGS[FeeAmount.MEDIUM_SWAPMODE] = 60),
+  _TICK_SPACINGS)
 
 // constants used internally but not expected to be used externally
-var NEGATIVE_ONE = /*#__PURE__*/JSBI.BigInt(-1);
-var ZERO = /*#__PURE__*/JSBI.BigInt(0);
-var ONE = /*#__PURE__*/JSBI.BigInt(1);
+var NEGATIVE_ONE = /*#__PURE__*/ JSBI.BigInt(-1)
+var ZERO = /*#__PURE__*/ JSBI.BigInt(0)
+var ONE = /*#__PURE__*/ JSBI.BigInt(1)
 // used in liquidity amount math
-var Q96 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(96));
-var Q192 = /*#__PURE__*/JSBI.exponentiate(Q96, /*#__PURE__*/JSBI.BigInt(2));
+var Q96 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(96))
+var Q192 = /*#__PURE__*/ JSBI.exponentiate(Q96, /*#__PURE__*/ JSBI.BigInt(2))
 
 /**
  * Computes a pool address
@@ -488,200 +617,308 @@ function computePoolAddress(_ref) {
     tokenB = _ref.tokenB,
     fee = _ref.fee,
     initCodeHashManualOverride = _ref.initCodeHashManualOverride,
-    chainId = _ref.chainId;
+    chainId = _ref.chainId
   var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],
     token0 = _ref2[0],
-    token1 = _ref2[1]; // does safety checks
-  var salt = keccak256(['bytes'], [defaultAbiCoder.encode(['address', 'address', 'uint24'], [token0.address, token1.address, fee])]);
-  var initCodeHash = initCodeHashManualOverride != null ? initCodeHashManualOverride : poolInitCodeHash(chainId);
+    token1 = _ref2[1] // does safety checks
+  var salt = keccak256(
+    ['bytes'],
+    [defaultAbiCoder.encode(['address', 'address', 'uint24'], [token0.address, token1.address, fee])],
+  )
+  var initCodeHash = initCodeHashManualOverride != null ? initCodeHashManualOverride : poolInitCodeHash(chainId)
   // ZKSync uses a different create2 address computation
   // Most likely all ZKEVM chains will use the different computation from standard create2
   switch (chainId) {
     case ChainId.ZKSYNC:
-      return computeZksyncCreate2Address(factoryAddress, initCodeHash, salt);
+      return computeZksyncCreate2Address(factoryAddress, initCodeHash, salt)
     default:
-      return getCreate2Address(factoryAddress, salt, initCodeHash);
+      return getCreate2Address(factoryAddress, salt, initCodeHash)
   }
 }
 
-var FullMath = /*#__PURE__*/function () {
+var FullMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function FullMath() {}
   FullMath.mulDivRoundingUp = function mulDivRoundingUp(a, b, denominator) {
-    var product = JSBI.multiply(a, b);
-    var result = JSBI.divide(product, denominator);
-    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE);
-    return result;
-  };
-  return FullMath;
-}();
+    var product = JSBI.multiply(a, b)
+    var result = JSBI.divide(product, denominator)
+    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE)
+    return result
+  }
+  return FullMath
+})()
 
-var MaxUint160 = /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(160)), ONE);
+var MaxUint160 = /*#__PURE__*/ JSBI.subtract(
+  /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(160)),
+  ONE,
+)
 function multiplyIn256(x, y) {
-  var product = JSBI.multiply(x, y);
-  return JSBI.bitwiseAnd(product, MaxUint256);
+  var product = JSBI.multiply(x, y)
+  return JSBI.bitwiseAnd(product, MaxUint256)
 }
 function addIn256(x, y) {
-  var sum = JSBI.add(x, y);
-  return JSBI.bitwiseAnd(sum, MaxUint256);
+  var sum = JSBI.add(x, y)
+  return JSBI.bitwiseAnd(sum, MaxUint256)
 }
-var SqrtPriceMath = /*#__PURE__*/function () {
+var SqrtPriceMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function SqrtPriceMath() {}
   SqrtPriceMath.getAmount0Delta = function getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
     if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-      var _ref = [sqrtRatioBX96, sqrtRatioAX96];
-      sqrtRatioAX96 = _ref[0];
-      sqrtRatioBX96 = _ref[1];
-    }
-    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
-    var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96);
-    return roundUp ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96) : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96);
-  };
+      var _ref = [sqrtRatioBX96, sqrtRatioAX96]
+      sqrtRatioAX96 = _ref[0]
+      sqrtRatioBX96 = _ref[1]
+    }
+    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96))
+    var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)
+    return roundUp
+      ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96)
+      : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96)
+  }
   SqrtPriceMath.getAmount1Delta = function getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
     if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-      var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
-      sqrtRatioAX96 = _ref2[0];
-      sqrtRatioBX96 = _ref2[1];
-    }
-    return roundUp ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96) : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96);
-  };
-  SqrtPriceMath.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne) {
-    !JSBI.greaterThan(sqrtPX96, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-    !JSBI.greaterThan(liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-    return zeroForOne ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true) : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
-  };
-  SqrtPriceMath.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne) {
-    !JSBI.greaterThan(sqrtPX96, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-    !JSBI.greaterThan(liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-    return zeroForOne ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false) : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
-  };
-  SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amount, add) {
-    if (JSBI.equal(amount, ZERO)) return sqrtPX96;
-    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
+      var _ref2 = [sqrtRatioBX96, sqrtRatioAX96]
+      sqrtRatioAX96 = _ref2[0]
+      sqrtRatioBX96 = _ref2[1]
+    }
+    return roundUp
+      ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96)
+      : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96)
+  }
+  SqrtPriceMath.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(
+    sqrtPX96,
+    liquidity,
+    amountIn,
+    zeroForOne,
+  ) {
+    !JSBI.greaterThan(sqrtPX96, ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false)
+        : invariant(false)
+      : void 0
+    !JSBI.greaterThan(liquidity, ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false)
+        : invariant(false)
+      : void 0
+    return zeroForOne
+      ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
+      : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true)
+  }
+  SqrtPriceMath.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(
+    sqrtPX96,
+    liquidity,
+    amountOut,
+    zeroForOne,
+  ) {
+    !JSBI.greaterThan(sqrtPX96, ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false)
+        : invariant(false)
+      : void 0
+    !JSBI.greaterThan(liquidity, ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false)
+        : invariant(false)
+      : void 0
+    return zeroForOne
+      ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
+      : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false)
+  }
+  SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(
+    sqrtPX96,
+    liquidity,
+    amount,
+    add,
+  ) {
+    if (JSBI.equal(amount, ZERO)) return sqrtPX96
+    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96))
     if (add) {
-      var product = multiplyIn256(amount, sqrtPX96);
+      var product = multiplyIn256(amount, sqrtPX96)
       if (JSBI.equal(JSBI.divide(product, amount), sqrtPX96)) {
-        var denominator = addIn256(numerator1, product);
+        var denominator = addIn256(numerator1, product)
         if (JSBI.greaterThanOrEqual(denominator, numerator1)) {
-          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator);
+          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator)
         }
       }
-      return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount));
+      return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount))
     } else {
-      var _product = multiplyIn256(amount, sqrtPX96);
-      !JSBI.equal(JSBI.divide(_product, amount), sqrtPX96) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-      !JSBI.greaterThan(numerator1, _product) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-      var _denominator = JSBI.subtract(numerator1, _product);
-      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator);
-    }
-  };
-  SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amount, add) {
+      var _product = multiplyIn256(amount, sqrtPX96)
+      !JSBI.equal(JSBI.divide(_product, amount), sqrtPX96)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false)
+          : invariant(false)
+        : void 0
+      !JSBI.greaterThan(numerator1, _product)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false)
+          : invariant(false)
+        : void 0
+      var _denominator = JSBI.subtract(numerator1, _product)
+      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator)
+    }
+  }
+  SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(
+    sqrtPX96,
+    liquidity,
+    amount,
+    add,
+  ) {
     if (add) {
-      var quotient = JSBI.lessThanOrEqual(amount, MaxUint160) ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity) : JSBI.divide(JSBI.multiply(amount, Q96), liquidity);
-      return JSBI.add(sqrtPX96, quotient);
+      var quotient = JSBI.lessThanOrEqual(amount, MaxUint160)
+        ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity)
+        : JSBI.divide(JSBI.multiply(amount, Q96), liquidity)
+      return JSBI.add(sqrtPX96, quotient)
     } else {
-      var _quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity);
-      !JSBI.greaterThan(sqrtPX96, _quotient) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-      return JSBI.subtract(sqrtPX96, _quotient);
+      var _quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity)
+      !JSBI.greaterThan(sqrtPX96, _quotient)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false)
+          : invariant(false)
+        : void 0
+      return JSBI.subtract(sqrtPX96, _quotient)
     }
-  };
-  return SqrtPriceMath;
-}();
+  }
+  return SqrtPriceMath
+})()
 
-var MAX_FEE = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(10), /*#__PURE__*/JSBI.BigInt(6));
-var SwapMath = /*#__PURE__*/function () {
+var MAX_FEE = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(10), /*#__PURE__*/ JSBI.BigInt(6))
+var SwapMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function SwapMath() {}
-  SwapMath.computeSwapStep = function computeSwapStep(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, amountRemaining, feePips) {
-    var returnValues = {};
-    feePips = JSBI.BigInt(feePips);
-    var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96);
-    var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO);
+  SwapMath.computeSwapStep = function computeSwapStep(
+    sqrtRatioCurrentX96,
+    sqrtRatioTargetX96,
+    liquidity,
+    amountRemaining,
+    feePips,
+  ) {
+    var returnValues = {}
+    feePips = JSBI.BigInt(feePips)
+    var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96)
+    var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO)
     if (exactIn) {
-      var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, feePips)), MAX_FEE);
-      returnValues.amountIn = zeroForOne ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true) : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
+      var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, feePips)), MAX_FEE)
+      returnValues.amountIn = zeroForOne
+        ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
+        : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true)
       if (JSBI.greaterThanOrEqual(amountRemainingLessFee, returnValues.amountIn)) {
-        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
+        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96
       } else {
-        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne);
+        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
+          sqrtRatioCurrentX96,
+          liquidity,
+          amountRemainingLessFee,
+          zeroForOne,
+        )
       }
     } else {
-      returnValues.amountOut = zeroForOne ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false) : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
+      returnValues.amountOut = zeroForOne
+        ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
+        : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false)
       if (JSBI.greaterThanOrEqual(JSBI.multiply(amountRemaining, NEGATIVE_ONE), returnValues.amountOut)) {
-        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
+        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96
       } else {
-        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtRatioCurrentX96, liquidity, JSBI.multiply(amountRemaining, NEGATIVE_ONE), zeroForOne);
+        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
+          sqrtRatioCurrentX96,
+          liquidity,
+          JSBI.multiply(amountRemaining, NEGATIVE_ONE),
+          zeroForOne,
+        )
       }
     }
-    var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96);
+    var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96)
     if (zeroForOne) {
-      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
-      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
+      returnValues.amountIn =
+        max && exactIn
+          ? returnValues.amountIn
+          : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true)
+      returnValues.amountOut =
+        max && !exactIn
+          ? returnValues.amountOut
+          : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false)
     } else {
-      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true);
-      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false);
+      returnValues.amountIn =
+        max && exactIn
+          ? returnValues.amountIn
+          : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true)
+      returnValues.amountOut =
+        max && !exactIn
+          ? returnValues.amountOut
+          : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false)
     }
     if (!exactIn && JSBI.greaterThan(returnValues.amountOut, JSBI.multiply(amountRemaining, NEGATIVE_ONE))) {
-      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE);
+      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE)
     }
     if (exactIn && JSBI.notEqual(returnValues.sqrtRatioNextX96, sqrtRatioTargetX96)) {
       // we didn't reach the target, so take the remainder of the maximum input as fee
-      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn);
+      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn)
     } else {
-      returnValues.feeAmount = FullMath.mulDivRoundingUp(returnValues.amountIn, feePips, JSBI.subtract(MAX_FEE, feePips));
+      returnValues.feeAmount = FullMath.mulDivRoundingUp(
+        returnValues.amountIn,
+        feePips,
+        JSBI.subtract(MAX_FEE, feePips),
+      )
     }
-    return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount];
-  };
-  return SwapMath;
-}();
+    return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount]
+  }
+  return SwapMath
+})()
 
-var LiquidityMath = /*#__PURE__*/function () {
+var LiquidityMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function LiquidityMath() {}
   LiquidityMath.addDelta = function addDelta(x, y) {
     if (JSBI.lessThan(y, ZERO)) {
-      return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE));
+      return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE))
     } else {
-      return JSBI.add(x, y);
+      return JSBI.add(x, y)
     }
-  };
-  return LiquidityMath;
-}();
+  }
+  return LiquidityMath
+})()
 
-var TWO = /*#__PURE__*/JSBI.BigInt(2);
-var POWERS_OF_2 = /*#__PURE__*/[128, 64, 32, 16, 8, 4, 2, 1].map(function (pow) {
-  return [pow, JSBI.exponentiate(TWO, JSBI.BigInt(pow))];
-});
+var TWO = /*#__PURE__*/ JSBI.BigInt(2)
+var POWERS_OF_2 = /*#__PURE__*/ [128, 64, 32, 16, 8, 4, 2, 1].map(function (pow) {
+  return [pow, JSBI.exponentiate(TWO, JSBI.BigInt(pow))]
+})
 function mostSignificantBit(x) {
-  !JSBI.greaterThan(x, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO') : invariant(false) : void 0;
-  !JSBI.lessThanOrEqual(x, MaxUint256) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX') : invariant(false) : void 0;
-  var msb = 0;
-  for (var _iterator = _createForOfIteratorHelperLoose(POWERS_OF_2), _step; !(_step = _iterator()).done;) {
+  !JSBI.greaterThan(x, ZERO)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'ZERO')
+      : invariant(false)
+    : void 0
+  !JSBI.lessThanOrEqual(x, MaxUint256)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'MAX')
+      : invariant(false)
+    : void 0
+  var msb = 0
+  for (var _iterator = _createForOfIteratorHelperLoose(POWERS_OF_2), _step; !(_step = _iterator()).done; ) {
     var _step$value = _step.value,
       power = _step$value[0],
-      min = _step$value[1];
+      min = _step$value[1]
     if (JSBI.greaterThanOrEqual(x, min)) {
-      x = JSBI.signedRightShift(x, JSBI.BigInt(power));
-      msb += power;
+      x = JSBI.signedRightShift(x, JSBI.BigInt(power))
+      msb += power
     }
   }
-  return msb;
+  return msb
 }
 
 function mulShift(val, mulBy) {
-  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128));
+  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128))
 }
-var Q32 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(32));
-var TickMath = /*#__PURE__*/function () {
+var Q32 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(32))
+var TickMath = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
@@ -691,226 +928,313 @@ var TickMath = /*#__PURE__*/function () {
    * @param tick the tick for which to compute the sqrt ratio
    */
   TickMath.getSqrtRatioAtTick = function getSqrtRatioAtTick(tick) {
-    !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK') : invariant(false) : void 0;
-    var absTick = tick < 0 ? tick * -1 : tick;
-    var ratio = (absTick & 0x1) !== 0 ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001') : JSBI.BigInt('0x100000000000000000000000000000000');
-    if ((absTick & 0x2) !== 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a');
-    if ((absTick & 0x4) !== 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc');
-    if ((absTick & 0x8) !== 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0');
-    if ((absTick & 0x10) !== 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644');
-    if ((absTick & 0x20) !== 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0');
-    if ((absTick & 0x40) !== 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861');
-    if ((absTick & 0x80) !== 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053');
-    if ((absTick & 0x100) !== 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4');
-    if ((absTick & 0x200) !== 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54');
-    if ((absTick & 0x400) !== 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3');
-    if ((absTick & 0x800) !== 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9');
-    if ((absTick & 0x1000) !== 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825');
-    if ((absTick & 0x2000) !== 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5');
-    if ((absTick & 0x4000) !== 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7');
-    if ((absTick & 0x8000) !== 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6');
-    if ((absTick & 0x10000) !== 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9');
-    if ((absTick & 0x20000) !== 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604');
-    if ((absTick & 0x40000) !== 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98');
-    if ((absTick & 0x80000) !== 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2');
-    if (tick > 0) ratio = JSBI.divide(MaxUint256, ratio);
+    !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick))
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TICK')
+        : invariant(false)
+      : void 0
+    var absTick = tick < 0 ? tick * -1 : tick
+    var ratio =
+      (absTick & 0x1) !== 0
+        ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001')
+        : JSBI.BigInt('0x100000000000000000000000000000000')
+    if ((absTick & 0x2) !== 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a')
+    if ((absTick & 0x4) !== 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc')
+    if ((absTick & 0x8) !== 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0')
+    if ((absTick & 0x10) !== 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644')
+    if ((absTick & 0x20) !== 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0')
+    if ((absTick & 0x40) !== 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861')
+    if ((absTick & 0x80) !== 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053')
+    if ((absTick & 0x100) !== 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4')
+    if ((absTick & 0x200) !== 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54')
+    if ((absTick & 0x400) !== 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3')
+    if ((absTick & 0x800) !== 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9')
+    if ((absTick & 0x1000) !== 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825')
+    if ((absTick & 0x2000) !== 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5')
+    if ((absTick & 0x4000) !== 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7')
+    if ((absTick & 0x8000) !== 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6')
+    if ((absTick & 0x10000) !== 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9')
+    if ((absTick & 0x20000) !== 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604')
+    if ((absTick & 0x40000) !== 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98')
+    if ((absTick & 0x80000) !== 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2')
+    if (tick > 0) ratio = JSBI.divide(MaxUint256, ratio)
     // back to Q96
-    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO) ? JSBI.add(JSBI.divide(ratio, Q32), ONE) : JSBI.divide(ratio, Q32);
+    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO)
+      ? JSBI.add(JSBI.divide(ratio, Q32), ONE)
+      : JSBI.divide(ratio, Q32)
   }
   /**
    * Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96
    * and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96
    * @param sqrtRatioX96 the sqrt ratio as a Q64.96 for which to compute the tick
-   */;
+   */
   TickMath.getTickAtSqrtRatio = function getTickAtSqrtRatio(sqrtRatioX96) {
-    !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SQRT_RATIO') : invariant(false) : void 0;
-    var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32));
-    var msb = mostSignificantBit(sqrtRatioX128);
-    var r;
+    !(
+      JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&
+      JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)
+    )
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'SQRT_RATIO')
+        : invariant(false)
+      : void 0
+    var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32))
+    var msb = mostSignificantBit(sqrtRatioX128)
+    var r
     if (JSBI.greaterThanOrEqual(JSBI.BigInt(msb), JSBI.BigInt(128))) {
-      r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127));
+      r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127))
     } else {
-      r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb));
+      r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb))
     }
-    var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64));
+    var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64))
     for (var i = 0; i < 14; i++) {
-      r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127));
-      var f = JSBI.signedRightShift(r, JSBI.BigInt(128));
-      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)));
-      r = JSBI.signedRightShift(r, f);
-    }
-    var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'));
-    var tickLow = JSBI.toNumber(JSBI.signedRightShift(JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')), JSBI.BigInt(128)));
-    var tickHigh = JSBI.toNumber(JSBI.signedRightShift(JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')), JSBI.BigInt(128)));
-    return tickLow === tickHigh ? tickLow : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96) ? tickHigh : tickLow;
-  };
-  return TickMath;
-}();
+      r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127))
+      var f = JSBI.signedRightShift(r, JSBI.BigInt(128))
+      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)))
+      r = JSBI.signedRightShift(r, f)
+    }
+    var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'))
+    var tickLow = JSBI.toNumber(
+      JSBI.signedRightShift(
+        JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')),
+        JSBI.BigInt(128),
+      ),
+    )
+    var tickHigh = JSBI.toNumber(
+      JSBI.signedRightShift(
+        JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')),
+        JSBI.BigInt(128),
+      ),
+    )
+    return tickLow === tickHigh
+      ? tickLow
+      : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96)
+        ? tickHigh
+        : tickLow
+  }
+  return TickMath
+})()
 /**
  * The minimum tick that can be used on any pool.
  */
-TickMath.MIN_TICK = -887272;
+TickMath.MIN_TICK = -887272
 /**
  * The maximum tick that can be used on any pool.
  */
-TickMath.MAX_TICK = -TickMath.MIN_TICK;
+TickMath.MAX_TICK = -TickMath.MIN_TICK
 /**
  * The sqrt ratio corresponding to the minimum tick that could be used on any pool.
  */
-TickMath.MIN_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('4295128739');
+TickMath.MIN_SQRT_RATIO = /*#__PURE__*/ JSBI.BigInt('4295128739')
 /**
  * The sqrt ratio corresponding to the maximum tick that could be used on any pool.
  */
-TickMath.MAX_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('1461446703485210103287273052203988822378723970342');
+TickMath.MAX_SQRT_RATIO = /*#__PURE__*/ JSBI.BigInt('1461446703485210103287273052203988822378723970342')
 
 function v3Swap(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {
-  return _v3Swap.apply(this, arguments);
+  return _v3Swap.apply(this, arguments)
 }
 function _v3Swap() {
-  _v3Swap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fee, sqrtRatioX96, tickCurrent, liquidity, tickSpacing, tickDataProvider, zeroForOne, amountSpecified, sqrtPriceLimitX96) {
-    var exactInput, state, step, _yield$tickDataProvid, _SwapMath$computeSwap, liquidityNet;
-    return _regeneratorRuntime().wrap(function _callee$(_context) {
-      while (1) switch (_context.prev = _context.next) {
-        case 0:
-          if (!sqrtPriceLimitX96) sqrtPriceLimitX96 = zeroForOne ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE) : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE);
-          if (zeroForOne) {
-            !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_MIN') : invariant(false) : void 0;
-            !JSBI.lessThan(sqrtPriceLimitX96, sqrtRatioX96) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_CURRENT') : invariant(false) : void 0;
-          } else {
-            !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_MAX') : invariant(false) : void 0;
-            !JSBI.greaterThan(sqrtPriceLimitX96, sqrtRatioX96) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_CURRENT') : invariant(false) : void 0;
-          }
-          exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO); // keep track of swap state
-          state = {
-            amountSpecifiedRemaining: amountSpecified,
-            amountCalculated: ZERO,
-            sqrtPriceX96: sqrtRatioX96,
-            tick: tickCurrent,
-            liquidity: liquidity
-          }; // start swap while loop
-        case 4:
-          if (!(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 !== sqrtPriceLimitX96)) {
-            _context.next = 35;
-            break;
-          }
-          step = {};
-          step.sqrtPriceStartX96 = state.sqrtPriceX96;
-          _context.next = 9;
-          return tickDataProvider.nextInitializedTickWithinOneWord(state.tick, zeroForOne, tickSpacing);
-        case 9:
-          _yield$tickDataProvid = _context.sent;
-          step.tickNext = _yield$tickDataProvid[0];
-          step.initialized = _yield$tickDataProvid[1];
-          if (step.tickNext < TickMath.MIN_TICK) {
-            step.tickNext = TickMath.MIN_TICK;
-          } else if (step.tickNext > TickMath.MAX_TICK) {
-            step.tickNext = TickMath.MAX_TICK;
-          }
-          step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
-          _SwapMath$computeSwap = SwapMath.computeSwapStep(state.sqrtPriceX96, (zeroForOne ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96) : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state.liquidity, state.amountSpecifiedRemaining, fee);
-          state.sqrtPriceX96 = _SwapMath$computeSwap[0];
-          step.amountIn = _SwapMath$computeSwap[1];
-          step.amountOut = _SwapMath$computeSwap[2];
-          step.feeAmount = _SwapMath$computeSwap[3];
-          if (exactInput) {
-            state.amountSpecifiedRemaining = JSBI.subtract(state.amountSpecifiedRemaining, JSBI.add(step.amountIn, step.feeAmount));
-            state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut);
-          } else {
-            state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut);
-            state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount));
-          }
-          // TODO
-          if (!JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {
-            _context.next = 32;
-            break;
-          }
-          if (!step.initialized) {
-            _context.next = 29;
-            break;
-          }
-          _context.t0 = JSBI;
-          _context.next = 25;
-          return tickDataProvider.getTick(step.tickNext);
-        case 25:
-          _context.t1 = _context.sent.liquidityNet;
-          liquidityNet = _context.t0.BigInt.call(_context.t0, _context.t1);
-          // if we're moving leftward, we interpret liquidityNet as the opposite sign
-          // safe because liquidityNet cannot be type(int128).min
-          if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE);
-          state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
-        case 29:
-          state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
-          _context.next = 33;
-          break;
-        case 32:
-          if (JSBI.notEqual(state.sqrtPriceX96, step.sqrtPriceStartX96)) {
-            // updated comparison function
-            // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
-            state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
-          }
-        case 33:
-          _context.next = 4;
-          break;
-        case 35:
-          return _context.abrupt("return", {
-            amountCalculated: state.amountCalculated,
-            sqrtRatioX96: state.sqrtPriceX96,
-            liquidity: state.liquidity,
-            tickCurrent: state.tick
-          });
-        case 36:
-        case "end":
-          return _context.stop();
-      }
-    }, _callee);
-  }));
-  return _v3Swap.apply(this, arguments);
+  _v3Swap = _asyncToGenerator(
+    /*#__PURE__*/ _regeneratorRuntime().mark(
+      function _callee(
+        fee,
+        sqrtRatioX96,
+        tickCurrent,
+        liquidity,
+        tickSpacing,
+        tickDataProvider,
+        zeroForOne,
+        amountSpecified,
+        sqrtPriceLimitX96,
+      ) {
+        var exactInput, state, step, _yield$tickDataProvid, _SwapMath$computeSwap, liquidityNet
+        return _regeneratorRuntime().wrap(function _callee$(_context) {
+          while (1)
+            switch ((_context.prev = _context.next)) {
+              case 0:
+                if (!sqrtPriceLimitX96)
+                  sqrtPriceLimitX96 = zeroForOne
+                    ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE)
+                    : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE)
+                if (zeroForOne) {
+                  !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'RATIO_MIN')
+                      : invariant(false)
+                    : void 0
+                  !JSBI.lessThan(sqrtPriceLimitX96, sqrtRatioX96)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'RATIO_CURRENT')
+                      : invariant(false)
+                    : void 0
+                } else {
+                  !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'RATIO_MAX')
+                      : invariant(false)
+                    : void 0
+                  !JSBI.greaterThan(sqrtPriceLimitX96, sqrtRatioX96)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'RATIO_CURRENT')
+                      : invariant(false)
+                    : void 0
+                }
+                exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO) // keep track of swap state
+                state = {
+                  amountSpecifiedRemaining: amountSpecified,
+                  amountCalculated: ZERO,
+                  sqrtPriceX96: sqrtRatioX96,
+                  tick: tickCurrent,
+                  liquidity: liquidity,
+                } // start swap while loop
+              case 4:
+                if (
+                  !(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 !== sqrtPriceLimitX96)
+                ) {
+                  _context.next = 35
+                  break
+                }
+                step = {}
+                step.sqrtPriceStartX96 = state.sqrtPriceX96
+                _context.next = 9
+                return tickDataProvider.nextInitializedTickWithinOneWord(state.tick, zeroForOne, tickSpacing)
+              case 9:
+                _yield$tickDataProvid = _context.sent
+                step.tickNext = _yield$tickDataProvid[0]
+                step.initialized = _yield$tickDataProvid[1]
+                if (step.tickNext < TickMath.MIN_TICK) {
+                  step.tickNext = TickMath.MIN_TICK
+                } else if (step.tickNext > TickMath.MAX_TICK) {
+                  step.tickNext = TickMath.MAX_TICK
+                }
+                step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext)
+                _SwapMath$computeSwap = SwapMath.computeSwapStep(
+                  state.sqrtPriceX96,
+                  (
+                    zeroForOne
+                      ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)
+                      : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)
+                  )
+                    ? sqrtPriceLimitX96
+                    : step.sqrtPriceNextX96,
+                  state.liquidity,
+                  state.amountSpecifiedRemaining,
+                  fee,
+                )
+                state.sqrtPriceX96 = _SwapMath$computeSwap[0]
+                step.amountIn = _SwapMath$computeSwap[1]
+                step.amountOut = _SwapMath$computeSwap[2]
+                step.feeAmount = _SwapMath$computeSwap[3]
+                if (exactInput) {
+                  state.amountSpecifiedRemaining = JSBI.subtract(
+                    state.amountSpecifiedRemaining,
+                    JSBI.add(step.amountIn, step.feeAmount),
+                  )
+                  state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut)
+                } else {
+                  state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut)
+                  state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount))
+                }
+                // TODO
+                if (!JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {
+                  _context.next = 32
+                  break
+                }
+                if (!step.initialized) {
+                  _context.next = 29
+                  break
+                }
+                _context.t0 = JSBI
+                _context.next = 25
+                return tickDataProvider.getTick(step.tickNext)
+              case 25:
+                _context.t1 = _context.sent.liquidityNet
+                liquidityNet = _context.t0.BigInt.call(_context.t0, _context.t1)
+                // if we're moving leftward, we interpret liquidityNet as the opposite sign
+                // safe because liquidityNet cannot be type(int128).min
+                if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE)
+                state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet)
+              case 29:
+                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext
+                _context.next = 33
+                break
+              case 32:
+                if (JSBI.notEqual(state.sqrtPriceX96, step.sqrtPriceStartX96)) {
+                  // updated comparison function
+                  // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
+                  state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96)
+                }
+              case 33:
+                _context.next = 4
+                break
+              case 35:
+                return _context.abrupt('return', {
+                  amountCalculated: state.amountCalculated,
+                  sqrtRatioX96: state.sqrtPriceX96,
+                  liquidity: state.liquidity,
+                  tickCurrent: state.tick,
+                })
+              case 36:
+              case 'end':
+                return _context.stop()
+            }
+        }, _callee)
+      },
+    ),
+  )
+  return _v3Swap.apply(this, arguments)
 }
 
 /**
  * This tick data provider does not know how to fetch any tick data. It throws whenever it is required. Useful if you
  * do not need to load tick data for your use case.
  */
-var NoTickDataProvider = /*#__PURE__*/function () {
+var NoTickDataProvider = /*#__PURE__*/ (function () {
   function NoTickDataProvider() {}
-  var _proto = NoTickDataProvider.prototype;
-  _proto.getTick = /*#__PURE__*/function () {
-    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_tick) {
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
-          case 1:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee);
-    }));
+  var _proto = NoTickDataProvider.prototype
+  _proto.getTick = /*#__PURE__*/ (function () {
+    var _getTick = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(_tick) {
+        return _regeneratorRuntime().wrap(function _callee$(_context) {
+          while (1)
+            switch ((_context.prev = _context.next)) {
+              case 0:
+                throw new Error(NoTickDataProvider.ERROR_MESSAGE)
+              case 1:
+              case 'end':
+                return _context.stop()
+            }
+        }, _callee)
+      }),
+    )
     function getTick(_x) {
-      return _getTick.apply(this, arguments);
-    }
-    return getTick;
-  }();
-  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
-    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_tick, _lte, _tickSpacing) {
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2);
-    }));
+      return _getTick.apply(this, arguments)
+    }
+    return getTick
+  })()
+  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/ (function () {
+    var _nextInitializedTickWithinOneWord = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(_tick, _lte, _tickSpacing) {
+        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+          while (1)
+            switch ((_context2.prev = _context2.next)) {
+              case 0:
+                throw new Error(NoTickDataProvider.ERROR_MESSAGE)
+              case 1:
+              case 'end':
+                return _context2.stop()
+            }
+        }, _callee2)
+      }),
+    )
     function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
-      return _nextInitializedTickWithinOneWord.apply(this, arguments);
+      return _nextInitializedTickWithinOneWord.apply(this, arguments)
     }
-    return nextInitializedTickWithinOneWord;
-  }();
-  return NoTickDataProvider;
-}();
-NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';
+    return nextInitializedTickWithinOneWord
+  })()
+  return NoTickDataProvider
+})()
+NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given'
 
 /**
  * Determines if a tick list is sorted
@@ -921,114 +1245,157 @@ NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';
 function isSorted(list, comparator) {
   for (var i = 0; i < list.length - 1; i++) {
     if (comparator(list[i], list[i + 1]) > 0) {
-      return false;
+      return false
     }
   }
-  return true;
+  return true
 }
 
 function tickComparator(a, b) {
-  return a.index - b.index;
+  return a.index - b.index
 }
 /**
  * Utility methods for interacting with sorted lists of ticks
  */
-var TickList = /*#__PURE__*/function () {
+var TickList = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed
    */
   function TickList() {}
   TickList.validateList = function validateList(ticks, tickSpacing) {
-    !(tickSpacing > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_SPACING_NONZERO') : invariant(false) : void 0;
+    !(tickSpacing > 0)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TICK_SPACING_NONZERO')
+        : invariant(false)
+      : void 0
     // ensure ticks are spaced appropriately
     !ticks.every(function (_ref) {
-      var index = _ref.index;
-      return index % tickSpacing === 0;
-    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_SPACING') : invariant(false) : void 0;
+      var index = _ref.index
+      return index % tickSpacing === 0
+    })
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TICK_SPACING')
+        : invariant(false)
+      : void 0
     // ensure tick liquidity deltas sum to 0
-    !JSBI.equal(ticks.reduce(function (accumulator, _ref2) {
-      var liquidityNet = _ref2.liquidityNet;
-      return JSBI.add(accumulator, liquidityNet);
-    }, ZERO), ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO_NET') : invariant(false) : void 0;
-    !isSorted(ticks, tickComparator) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SORTED') : invariant(false) : void 0;
-  };
+    !JSBI.equal(
+      ticks.reduce(function (accumulator, _ref2) {
+        var liquidityNet = _ref2.liquidityNet
+        return JSBI.add(accumulator, liquidityNet)
+      }, ZERO),
+      ZERO,
+    )
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'ZERO_NET')
+        : invariant(false)
+      : void 0
+    !isSorted(ticks, tickComparator)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'SORTED')
+        : invariant(false)
+      : void 0
+  }
   TickList.isBelowSmallest = function isBelowSmallest(ticks, tick) {
-    !(ticks.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'LENGTH') : invariant(false) : void 0;
-    return tick < ticks[0].index;
-  };
+    !(ticks.length > 0)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'LENGTH')
+        : invariant(false)
+      : void 0
+    return tick < ticks[0].index
+  }
   TickList.isAtOrAboveLargest = function isAtOrAboveLargest(ticks, tick) {
-    !(ticks.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'LENGTH') : invariant(false) : void 0;
-    return tick >= ticks[ticks.length - 1].index;
-  };
+    !(ticks.length > 0)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'LENGTH')
+        : invariant(false)
+      : void 0
+    return tick >= ticks[ticks.length - 1].index
+  }
   TickList.getTick = function getTick(ticks, index) {
-    var tick = ticks[this.binarySearch(ticks, index)];
-    !(tick.index === index) ? process.env.NODE_ENV !== "production" ? invariant(false, 'NOT_CONTAINED') : invariant(false) : void 0;
-    return tick;
+    var tick = ticks[this.binarySearch(ticks, index)]
+    !(tick.index === index)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'NOT_CONTAINED')
+        : invariant(false)
+      : void 0
+    return tick
   }
   /**
    * Finds the largest tick in the list of ticks that is less than or equal to tick
    * @param ticks list of ticks
    * @param tick tick to find the largest tick that is less than or equal to tick
    * @private
-   */;
+   */
   TickList.binarySearch = function binarySearch(ticks, tick) {
-    !!this.isBelowSmallest(ticks, tick) ? process.env.NODE_ENV !== "production" ? invariant(false, 'BELOW_SMALLEST') : invariant(false) : void 0;
-    var l = 0;
-    var r = ticks.length - 1;
-    var i;
+    !!this.isBelowSmallest(ticks, tick)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'BELOW_SMALLEST')
+        : invariant(false)
+      : void 0
+    var l = 0
+    var r = ticks.length - 1
+    var i
     while (true) {
-      i = Math.floor((l + r) / 2);
+      i = Math.floor((l + r) / 2)
       if (ticks[i].index <= tick && (i === ticks.length - 1 || ticks[i + 1].index > tick)) {
-        return i;
+        return i
       }
       if (ticks[i].index < tick) {
-        l = i + 1;
+        l = i + 1
       } else {
-        r = i - 1;
+        r = i - 1
       }
     }
-  };
+  }
   TickList.nextInitializedTick = function nextInitializedTick(ticks, tick, lte) {
     if (lte) {
-      !!TickList.isBelowSmallest(ticks, tick) ? process.env.NODE_ENV !== "production" ? invariant(false, 'BELOW_SMALLEST') : invariant(false) : void 0;
+      !!TickList.isBelowSmallest(ticks, tick)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'BELOW_SMALLEST')
+          : invariant(false)
+        : void 0
       if (TickList.isAtOrAboveLargest(ticks, tick)) {
-        return ticks[ticks.length - 1];
+        return ticks[ticks.length - 1]
       }
-      var index = this.binarySearch(ticks, tick);
-      return ticks[index];
+      var index = this.binarySearch(ticks, tick)
+      return ticks[index]
     } else {
-      !!this.isAtOrAboveLargest(ticks, tick) ? process.env.NODE_ENV !== "production" ? invariant(false, 'AT_OR_ABOVE_LARGEST') : invariant(false) : void 0;
+      !!this.isAtOrAboveLargest(ticks, tick)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'AT_OR_ABOVE_LARGEST')
+          : invariant(false)
+        : void 0
       if (this.isBelowSmallest(ticks, tick)) {
-        return ticks[0];
+        return ticks[0]
       }
-      var _index = this.binarySearch(ticks, tick);
-      return ticks[_index + 1];
+      var _index = this.binarySearch(ticks, tick)
+      return ticks[_index + 1]
     }
-  };
+  }
   TickList.nextInitializedTickWithinOneWord = function nextInitializedTickWithinOneWord(ticks, tick, lte, tickSpacing) {
-    var compressed = Math.floor(tick / tickSpacing); // matches rounding in the code
+    var compressed = Math.floor(tick / tickSpacing) // matches rounding in the code
     if (lte) {
-      var wordPos = compressed >> 8;
-      var minimum = (wordPos << 8) * tickSpacing;
+      var wordPos = compressed >> 8
+      var minimum = (wordPos << 8) * tickSpacing
       if (TickList.isBelowSmallest(ticks, tick)) {
-        return [minimum, false];
+        return [minimum, false]
       }
-      var index = TickList.nextInitializedTick(ticks, tick, lte).index;
-      var nextInitializedTick = Math.max(minimum, index);
-      return [nextInitializedTick, nextInitializedTick === index];
+      var index = TickList.nextInitializedTick(ticks, tick, lte).index
+      var nextInitializedTick = Math.max(minimum, index)
+      return [nextInitializedTick, nextInitializedTick === index]
     } else {
-      var _wordPos = compressed + 1 >> 8;
-      var maximum = ((_wordPos + 1 << 8) - 1) * tickSpacing;
+      var _wordPos = (compressed + 1) >> 8
+      var maximum = (((_wordPos + 1) << 8) - 1) * tickSpacing
       if (this.isAtOrAboveLargest(ticks, tick)) {
-        return [maximum, false];
+        return [maximum, false]
       }
-      var _index2 = this.nextInitializedTick(ticks, tick, lte).index;
-      var _nextInitializedTick = Math.min(maximum, _index2);
-      return [_nextInitializedTick, _nextInitializedTick === _index2];
+      var _index2 = this.nextInitializedTick(ticks, tick, lte).index
+      var _nextInitializedTick = Math.min(maximum, _index2)
+      return [_nextInitializedTick, _nextInitializedTick === _index2]
     }
-  };
-  return TickList;
-}();
+  }
+  return TickList
+})()
 
 /**
  * Converts a big int to a hex string
@@ -1036,12 +1403,12 @@ var TickList = /*#__PURE__*/function () {
  * @returns The hex encoded calldata
  */
 function toHex(bigintIsh) {
-  var bigInt = JSBI.BigInt(bigintIsh);
-  var hex = bigInt.toString(16);
+  var bigInt = JSBI.BigInt(bigintIsh)
+  var hex = bigInt.toString(16)
   if (hex.length % 2 !== 0) {
-    hex = "0" + hex;
+    hex = '0' + hex
   }
-  return "0x" + hex;
+  return '0x' + hex
 }
 
 /**
@@ -1050,33 +1417,36 @@ function toHex(bigintIsh) {
  * @param exactOutput whether the route should be encoded in reverse, for making exact output swaps
  */
 function encodeRouteToPath(route, exactOutput) {
-  var firstInputToken = route.input.wrapped;
-  var _route$pools$reduce = route.pools.reduce(function (_ref, pool, index) {
-      var inputToken = _ref.inputToken,
-        path = _ref.path,
-        types = _ref.types;
-      var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;
-      if (index === 0) {
-        return {
-          inputToken: outputToken,
-          types: ['address', 'uint24', 'address'],
-          path: [inputToken.address, pool.fee, outputToken.address]
-        };
-      } else {
-        return {
-          inputToken: outputToken,
-          types: [].concat(types, ['uint24', 'address']),
-          path: [].concat(path, [pool.fee, outputToken.address])
-        };
-      }
-    }, {
-      inputToken: firstInputToken,
-      path: [],
-      types: []
-    }),
+  var firstInputToken = route.input.wrapped
+  var _route$pools$reduce = route.pools.reduce(
+      function (_ref, pool, index) {
+        var inputToken = _ref.inputToken,
+          path = _ref.path,
+          types = _ref.types
+        var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0
+        if (index === 0) {
+          return {
+            inputToken: outputToken,
+            types: ['address', 'uint24', 'address'],
+            path: [inputToken.address, pool.fee, outputToken.address],
+          }
+        } else {
+          return {
+            inputToken: outputToken,
+            types: [].concat(types, ['uint24', 'address']),
+            path: [].concat(path, [pool.fee, outputToken.address]),
+          }
+        }
+      },
+      {
+        inputToken: firstInputToken,
+        path: [],
+        types: [],
+      },
+    ),
     path = _route$pools$reduce.path,
-    types = _route$pools$reduce.types;
-  return exactOutput ? pack(types.reverse(), path.reverse()) : pack(types, path);
+    types = _route$pools$reduce.types
+  return exactOutput ? pack(types.reverse(), path.reverse()) : pack(types, path)
 }
 
 /**
@@ -1086,10 +1456,10 @@ function encodeRouteToPath(route, exactOutput) {
  * @returns The sqrt ratio
  */
 function encodeSqrtRatioX96(amount1, amount0) {
-  var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192));
-  var denominator = JSBI.BigInt(amount0);
-  var ratioX192 = JSBI.divide(numerator, denominator);
-  return sqrt(ratioX192);
+  var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192))
+  var denominator = JSBI.BigInt(amount0)
+  var ratioX192 = JSBI.divide(numerator, denominator)
+  return sqrt(ratioX192)
 }
 
 /**
@@ -1105,12 +1475,12 @@ function encodeSqrtRatioX96(amount1, amount0) {
  */
 function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref[0];
-    sqrtRatioBX96 = _ref[1];
+    var _ref = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref[0]
+    sqrtRatioBX96 = _ref[1]
   }
-  var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96);
-  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
+  var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96)
+  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))
 }
 /**
  * Returns a precise maximum amount of liquidity received for a given amount of token 0 by dividing by Q64 instead of Q96 in the intermediate step,
@@ -1122,13 +1492,13 @@ function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0)
  */
 function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref2[0];
-    sqrtRatioBX96 = _ref2[1];
+    var _ref2 = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref2[0]
+    sqrtRatioBX96 = _ref2[1]
   }
-  var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96);
-  var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
-  return JSBI.divide(numerator, denominator);
+  var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96)
+  var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))
+  return JSBI.divide(numerator, denominator)
 }
 /**
  * Computes the maximum amount of liquidity received for a given amount of token1
@@ -1139,11 +1509,11 @@ function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  */
 function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref3 = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref3[0];
-    sqrtRatioBX96 = _ref3[1];
+    var _ref3 = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref3[0]
+    sqrtRatioBX96 = _ref3[1]
   }
-  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
+  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))
 }
 /**
  * Computes the maximum amount of liquidity received for a given amount of token0, token1,
@@ -1158,19 +1528,19 @@ function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
  */
 function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
-    var _ref4 = [sqrtRatioBX96, sqrtRatioAX96];
-    sqrtRatioAX96 = _ref4[0];
-    sqrtRatioBX96 = _ref4[1];
+    var _ref4 = [sqrtRatioBX96, sqrtRatioAX96]
+    sqrtRatioAX96 = _ref4[0]
+    sqrtRatioBX96 = _ref4[1]
   }
-  var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise;
+  var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise
   if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {
-    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
+    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0)
   } else if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {
-    var liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0);
-    var liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1);
-    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1;
+    var liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0)
+    var liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1)
+    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1
   } else {
-    return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
+    return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1)
   }
 }
 
@@ -1180,27 +1550,53 @@ function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX9
  * @param tickSpacing the spacing of the pool
  */
 function nearestUsableTick(tick, tickSpacing) {
-  !(Number.isInteger(tick) && Number.isInteger(tickSpacing)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INTEGERS') : invariant(false) : void 0;
-  !(tickSpacing > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_SPACING') : invariant(false) : void 0;
-  !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_BOUND') : invariant(false) : void 0;
-  var rounded = Math.round(tick / tickSpacing) * tickSpacing;
-  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;else return rounded;
+  !(Number.isInteger(tick) && Number.isInteger(tickSpacing))
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'INTEGERS')
+      : invariant(false)
+    : void 0
+  !(tickSpacing > 0)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'TICK_SPACING')
+      : invariant(false)
+    : void 0
+  !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'TICK_BOUND')
+      : invariant(false)
+    : void 0
+  var rounded = Math.round(tick / tickSpacing) * tickSpacing
+  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing
+  else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing
+  else return rounded
 }
 
-var Q128 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128));
-var PositionLibrary = /*#__PURE__*/function () {
+var Q128 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(128))
+var PositionLibrary = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function PositionLibrary() {}
   // replicates the portions of Position#update required to compute unaccounted fees
-  PositionLibrary.getTokensOwed = function getTokensOwed(feeGrowthInside0LastX128, feeGrowthInside1LastX128, liquidity, feeGrowthInside0X128, feeGrowthInside1X128) {
-    var tokensOwed0 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity), Q128);
-    var tokensOwed1 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity), Q128);
-    return [tokensOwed0, tokensOwed1];
-  };
-  return PositionLibrary;
-}();
+  PositionLibrary.getTokensOwed = function getTokensOwed(
+    feeGrowthInside0LastX128,
+    feeGrowthInside1LastX128,
+    liquidity,
+    feeGrowthInside0X128,
+    feeGrowthInside1X128,
+  ) {
+    var tokensOwed0 = JSBI.divide(
+      JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity),
+      Q128,
+    )
+    var tokensOwed1 = JSBI.divide(
+      JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity),
+      Q128,
+    )
+    return [tokensOwed0, tokensOwed1]
+  }
+  return PositionLibrary
+})()
 
 /**
  * Returns a price object corresponding to the input tick and the base/quote token
@@ -1210,9 +1606,11 @@ var PositionLibrary = /*#__PURE__*/function () {
  * @param tick the tick for which to return the price
  */
 function tickToPrice(baseToken, quoteToken, tick) {
-  var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
-  var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);
-  return baseToken.sortsBefore(quoteToken) ? new Price(baseToken, quoteToken, Q192, ratioX192) : new Price(baseToken, quoteToken, ratioX192, Q192);
+  var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick)
+  var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96)
+  return baseToken.sortsBefore(quoteToken)
+    ? new Price(baseToken, quoteToken, Q192, ratioX192)
+    : new Price(baseToken, quoteToken, ratioX192, Q192)
 }
 /**
  * Returns the first tick for which the given price is greater than or equal to the tick price
@@ -1220,127 +1618,161 @@ function tickToPrice(baseToken, quoteToken, tick) {
  * i.e. the price of the returned tick is less than or equal to the input price
  */
 function priceToClosestTick(price) {
-  var sorted = price.baseCurrency.sortsBefore(price.quoteCurrency);
-  var sqrtRatioX96 = sorted ? encodeSqrtRatioX96(price.numerator, price.denominator) : encodeSqrtRatioX96(price.denominator, price.numerator);
-  var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);
-  var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);
+  var sorted = price.baseCurrency.sortsBefore(price.quoteCurrency)
+  var sqrtRatioX96 = sorted
+    ? encodeSqrtRatioX96(price.numerator, price.denominator)
+    : encodeSqrtRatioX96(price.denominator, price.numerator)
+  var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96)
+  var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1)
   if (sorted) {
     if (!price.lessThan(nextTickPrice)) {
-      tick++;
+      tick++
     }
   } else {
     if (!price.greaterThan(nextTickPrice)) {
-      tick++;
+      tick++
     }
   }
-  return tick;
+  return tick
 }
 
-var Q256 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(256));
+var Q256 = /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(256))
 function subIn256(x, y) {
-  var difference = JSBI.subtract(x, y);
+  var difference = JSBI.subtract(x, y)
   if (JSBI.lessThan(difference, ZERO)) {
-    return JSBI.add(Q256, difference);
+    return JSBI.add(Q256, difference)
   } else {
-    return difference;
+    return difference
   }
 }
-var TickLibrary = /*#__PURE__*/function () {
+var TickLibrary = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function TickLibrary() {}
-  TickLibrary.getFeeGrowthInside = function getFeeGrowthInside(feeGrowthOutsideLower, feeGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, feeGrowthGlobal0X128, feeGrowthGlobal1X128) {
-    var feeGrowthBelow0X128;
-    var feeGrowthBelow1X128;
+  TickLibrary.getFeeGrowthInside = function getFeeGrowthInside(
+    feeGrowthOutsideLower,
+    feeGrowthOutsideUpper,
+    tickLower,
+    tickUpper,
+    tickCurrent,
+    feeGrowthGlobal0X128,
+    feeGrowthGlobal1X128,
+  ) {
+    var feeGrowthBelow0X128
+    var feeGrowthBelow1X128
     if (tickCurrent >= tickLower) {
-      feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128;
-      feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128;
+      feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128
+      feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128
     } else {
-      feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128);
-      feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128);
+      feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128)
+      feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128)
     }
-    var feeGrowthAbove0X128;
-    var feeGrowthAbove1X128;
+    var feeGrowthAbove0X128
+    var feeGrowthAbove1X128
     if (tickCurrent < tickUpper) {
-      feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128;
-      feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128;
+      feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128
+      feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128
     } else {
-      feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128);
-      feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128);
+      feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128)
+      feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128)
     }
-    return [subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128), subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128)];
-  };
-  return TickLibrary;
-}();
+    return [
+      subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128),
+      subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128),
+    ]
+  }
+  return TickLibrary
+})()
 
 var Tick = function Tick(_ref) {
   var index = _ref.index,
     liquidityGross = _ref.liquidityGross,
-    liquidityNet = _ref.liquidityNet;
-  !(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK') : invariant(false) : void 0;
-  this.index = index;
-  this.liquidityGross = JSBI.BigInt(liquidityGross);
-  this.liquidityNet = JSBI.BigInt(liquidityNet);
-};
+    liquidityNet = _ref.liquidityNet
+  !(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'TICK')
+      : invariant(false)
+    : void 0
+  this.index = index
+  this.liquidityGross = JSBI.BigInt(liquidityGross)
+  this.liquidityNet = JSBI.BigInt(liquidityNet)
+}
 
 /**
  * A data provider for ticks that is backed by an in-memory array of ticks.
  */
-var TickListDataProvider = /*#__PURE__*/function () {
+var TickListDataProvider = /*#__PURE__*/ (function () {
   function TickListDataProvider(ticks, tickSpacing) {
     var ticksMapped = ticks.map(function (t) {
-      return t instanceof Tick ? t : new Tick(t);
-    });
-    TickList.validateList(ticksMapped, tickSpacing);
-    this.ticks = ticksMapped;
-  }
-  var _proto = TickListDataProvider.prototype;
-  _proto.getTick = /*#__PURE__*/function () {
-    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tick) {
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            return _context.abrupt("return", TickList.getTick(this.ticks, tick));
-          case 1:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee, this);
-    }));
+      return t instanceof Tick ? t : new Tick(t)
+    })
+    TickList.validateList(ticksMapped, tickSpacing)
+    this.ticks = ticksMapped
+  }
+  var _proto = TickListDataProvider.prototype
+  _proto.getTick = /*#__PURE__*/ (function () {
+    var _getTick = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(tick) {
+        return _regeneratorRuntime().wrap(
+          function _callee$(_context) {
+            while (1)
+              switch ((_context.prev = _context.next)) {
+                case 0:
+                  return _context.abrupt('return', TickList.getTick(this.ticks, tick))
+                case 1:
+                case 'end':
+                  return _context.stop()
+              }
+          },
+          _callee,
+          this,
+        )
+      }),
+    )
     function getTick(_x) {
-      return _getTick.apply(this, arguments);
-    }
-    return getTick;
-  }();
-  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
-    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tick, lte, tickSpacing) {
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            return _context2.abrupt("return", TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing));
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2, this);
-    }));
+      return _getTick.apply(this, arguments)
+    }
+    return getTick
+  })()
+  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/ (function () {
+    var _nextInitializedTickWithinOneWord = /*#__PURE__*/ _asyncToGenerator(
+      /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(tick, lte, tickSpacing) {
+        return _regeneratorRuntime().wrap(
+          function _callee2$(_context2) {
+            while (1)
+              switch ((_context2.prev = _context2.next)) {
+                case 0:
+                  return _context2.abrupt(
+                    'return',
+                    TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing),
+                  )
+                case 1:
+                case 'end':
+                  return _context2.stop()
+              }
+          },
+          _callee2,
+          this,
+        )
+      }),
+    )
     function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
-      return _nextInitializedTickWithinOneWord.apply(this, arguments);
+      return _nextInitializedTickWithinOneWord.apply(this, arguments)
     }
-    return nextInitializedTickWithinOneWord;
-  }();
-  return TickListDataProvider;
-}();
+    return nextInitializedTickWithinOneWord
+  })()
+  return TickListDataProvider
+})()
 
 /**
  * By default, pools will not allow operations that require ticks.
  */
-var NO_TICK_DATA_PROVIDER_DEFAULT = /*#__PURE__*/new NoTickDataProvider();
+var NO_TICK_DATA_PROVIDER_DEFAULT = /*#__PURE__*/ new NoTickDataProvider()
 /**
  * Represents a V3 pool
  */
-var Pool = /*#__PURE__*/function () {
+var Pool = /*#__PURE__*/ (function () {
   /**
    * Construct a pool
    * @param tokenA One of the tokens in the pool
@@ -1353,20 +1785,31 @@ var Pool = /*#__PURE__*/function () {
    */
   function Pool(tokenA, tokenB, fee, sqrtRatioX96, liquidity, tickCurrent, ticks) {
     if (ticks === void 0) {
-      ticks = NO_TICK_DATA_PROVIDER_DEFAULT;
-    }
-    !(Number.isInteger(fee) && fee < 1000000) ? process.env.NODE_ENV !== "production" ? invariant(false, 'FEE') : invariant(false) : void 0;
-    var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent);
-    var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1);
-    !(JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) && JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'PRICE_BOUNDS') : invariant(false) : void 0;
-    var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
-    this.token0 = _ref[0];
-    this.token1 = _ref[1];
-    this.fee = fee;
-    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96);
-    this.liquidity = JSBI.BigInt(liquidity);
-    this.tickCurrent = tickCurrent;
-    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks;
+      ticks = NO_TICK_DATA_PROVIDER_DEFAULT
+    }
+    !(Number.isInteger(fee) && fee < 1000000)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'FEE')
+        : invariant(false)
+      : void 0
+    var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent)
+    var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1)
+    !(
+      JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) &&
+      JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)
+    )
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'PRICE_BOUNDS')
+        : invariant(false)
+      : void 0
+    var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]
+    this.token0 = _ref[0]
+    this.token1 = _ref[1]
+    this.fee = fee
+    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96)
+    this.liquidity = JSBI.BigInt(liquidity)
+    this.tickCurrent = tickCurrent
+    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks
   }
   Pool.getAddress = function getAddress(tokenA, tokenB, fee, initCodeHashManualOverride, factoryAddressOverride) {
     return computePoolAddress({
@@ -1374,33 +1817,37 @@ var Pool = /*#__PURE__*/function () {
       fee: fee,
       tokenA: tokenA,
       tokenB: tokenB,
-      initCodeHashManualOverride: initCodeHashManualOverride
-    });
+      initCodeHashManualOverride: initCodeHashManualOverride,
+    })
   }
   /**
    * Returns true if the token is either token0 or token1
    * @param token The token to check
    * @returns True if token is either token0 or token
-   */;
-  var _proto = Pool.prototype;
+   */
+  var _proto = Pool.prototype
   _proto.involvesToken = function involvesToken(token) {
-    return token.equals(this.token0) || token.equals(this.token1);
+    return token.equals(this.token0) || token.equals(this.token1)
   }
   /**
    * Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0
-   */;
+   */
   /**
    * Return the price of the given token in terms of the other token in the pool.
    * @param token The token to return price of
    * @returns The price of the given token, in terms of the other.
    */
   _proto.priceOf = function priceOf(token) {
-    !this.involvesToken(token) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
-    return token.equals(this.token0) ? this.token0Price : this.token1Price;
+    !this.involvesToken(token)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TOKEN')
+        : invariant(false)
+      : void 0
+    return token.equals(this.token0) ? this.token0Price : this.token1Price
   }
   /**
    * Returns the chain ID of the tokens in the pool.
-   */;
+   */
   /**
    * Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade
    * @param inputAmount The input amount for which to quote the output amount
@@ -1408,74 +1855,117 @@ var Pool = /*#__PURE__*/function () {
    * @returns The output amount and the pool with updated state
    */
   _proto.getOutputAmount =
-  /*#__PURE__*/
-  function () {
-    var _getOutputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputAmount, sqrtPriceLimitX96) {
-      var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken;
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            !this.involvesToken(inputAmount.currency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
-            zeroForOne = inputAmount.currency.equals(this.token0);
-            _context.next = 4;
-            return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96);
-          case 4:
-            _yield$this$swap = _context.sent;
-            outputAmount = _yield$this$swap.amountCalculated;
-            sqrtRatioX96 = _yield$this$swap.sqrtRatioX96;
-            liquidity = _yield$this$swap.liquidity;
-            tickCurrent = _yield$this$swap.tickCurrent;
-            outputToken = zeroForOne ? this.token1 : this.token0;
-            return _context.abrupt("return", [CurrencyAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)), new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
-          case 11:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee, this);
-    }));
-    function getOutputAmount(_x, _x2) {
-      return _getOutputAmount.apply(this, arguments);
-    }
-    return getOutputAmount;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _getOutputAmount = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(inputAmount, sqrtPriceLimitX96) {
+          var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken
+          return _regeneratorRuntime().wrap(
+            function _callee$(_context) {
+              while (1)
+                switch ((_context.prev = _context.next)) {
+                  case 0:
+                    !this.involvesToken(inputAmount.currency)
+                      ? process.env.NODE_ENV !== 'production'
+                        ? invariant(false, 'TOKEN')
+                        : invariant(false)
+                      : void 0
+                    zeroForOne = inputAmount.currency.equals(this.token0)
+                    _context.next = 4
+                    return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96)
+                  case 4:
+                    _yield$this$swap = _context.sent
+                    outputAmount = _yield$this$swap.amountCalculated
+                    sqrtRatioX96 = _yield$this$swap.sqrtRatioX96
+                    liquidity = _yield$this$swap.liquidity
+                    tickCurrent = _yield$this$swap.tickCurrent
+                    outputToken = zeroForOne ? this.token1 : this.token0
+                    return _context.abrupt('return', [
+                      CurrencyAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)),
+                      new Pool(
+                        this.token0,
+                        this.token1,
+                        this.fee,
+                        sqrtRatioX96,
+                        liquidity,
+                        tickCurrent,
+                        this.tickDataProvider,
+                      ),
+                    ])
+                  case 11:
+                  case 'end':
+                    return _context.stop()
+                }
+            },
+            _callee,
+            this,
+          )
+        }),
+      )
+      function getOutputAmount(_x, _x2) {
+        return _getOutputAmount.apply(this, arguments)
+      }
+      return getOutputAmount
+    })()
   /**
    * Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade
    * @param outputAmount the output amount for which to quote the input amount
    * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap
    * @returns The input amount and the pool with updated state
    */
-  ;
   _proto.getInputAmount =
-  /*#__PURE__*/
-  function () {
-    var _getInputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
-      var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken;
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            !(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
-            zeroForOne = outputAmount.currency.equals(this.token1);
-            _context2.next = 4;
-            return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96);
-          case 4:
-            _yield$this$swap2 = _context2.sent;
-            inputAmount = _yield$this$swap2.amountCalculated;
-            sqrtRatioX96 = _yield$this$swap2.sqrtRatioX96;
-            liquidity = _yield$this$swap2.liquidity;
-            tickCurrent = _yield$this$swap2.tickCurrent;
-            inputToken = zeroForOne ? this.token0 : this.token1;
-            return _context2.abrupt("return", [CurrencyAmount.fromRawAmount(inputToken, inputAmount), new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
-          case 11:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2, this);
-    }));
-    function getInputAmount(_x3, _x4) {
-      return _getInputAmount.apply(this, arguments);
-    }
-    return getInputAmount;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _getInputAmount = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
+          var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken
+          return _regeneratorRuntime().wrap(
+            function _callee2$(_context2) {
+              while (1)
+                switch ((_context2.prev = _context2.next)) {
+                  case 0:
+                    !(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency))
+                      ? process.env.NODE_ENV !== 'production'
+                        ? invariant(false, 'TOKEN')
+                        : invariant(false)
+                      : void 0
+                    zeroForOne = outputAmount.currency.equals(this.token1)
+                    _context2.next = 4
+                    return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96)
+                  case 4:
+                    _yield$this$swap2 = _context2.sent
+                    inputAmount = _yield$this$swap2.amountCalculated
+                    sqrtRatioX96 = _yield$this$swap2.sqrtRatioX96
+                    liquidity = _yield$this$swap2.liquidity
+                    tickCurrent = _yield$this$swap2.tickCurrent
+                    inputToken = zeroForOne ? this.token0 : this.token1
+                    return _context2.abrupt('return', [
+                      CurrencyAmount.fromRawAmount(inputToken, inputAmount),
+                      new Pool(
+                        this.token0,
+                        this.token1,
+                        this.fee,
+                        sqrtRatioX96,
+                        liquidity,
+                        tickCurrent,
+                        this.tickDataProvider,
+                      ),
+                    ])
+                  case 11:
+                  case 'end':
+                    return _context2.stop()
+                }
+            },
+            _callee2,
+            this,
+          )
+        }),
+      )
+      function getInputAmount(_x3, _x4) {
+        return _getInputAmount.apply(this, arguments)
+      }
+      return getInputAmount
+    })()
   /**
    * Executes a swap
    * @param zeroForOne Whether the amount in is token0 or token1
@@ -1486,59 +1976,97 @@ var Pool = /*#__PURE__*/function () {
    * @returns liquidity
    * @returns tickCurrent
    */
-  ;
   _proto.swap =
-  /*#__PURE__*/
-  function () {
-    var _swap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
-      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
-        while (1) switch (_context3.prev = _context3.next) {
-          case 0:
-            return _context3.abrupt("return", v3Swap(JSBI.BigInt(this.fee), this.sqrtRatioX96, this.tickCurrent, this.liquidity, this.tickSpacing, this.tickDataProvider, zeroForOne, amountSpecified, sqrtPriceLimitX96));
-          case 1:
-          case "end":
-            return _context3.stop();
-        }
-      }, _callee3, this);
-    }));
-    function swap(_x5, _x6, _x7) {
-      return _swap.apply(this, arguments);
-    }
-    return swap;
-  }();
-  _createClass(Pool, [{
-    key: "token0Price",
-    get: function get() {
-      var _this$_token0Price;
-      return (_this$_token0Price = this._token0Price) != null ? _this$_token0Price : this._token0Price = new Price(this.token0, this.token1, Q192, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96));
-    }
-    /**
-     * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
-     */
-  }, {
-    key: "token1Price",
-    get: function get() {
-      var _this$_token1Price;
-      return (_this$_token1Price = this._token1Price) != null ? _this$_token1Price : this._token1Price = new Price(this.token1, this.token0, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96), Q192);
-    }
-  }, {
-    key: "chainId",
-    get: function get() {
-      return this.token0.chainId;
-    }
-  }, {
-    key: "tickSpacing",
-    get: function get() {
-      return TICK_SPACINGS[this.fee];
-    }
-  }]);
-  return Pool;
-}();
+    /*#__PURE__*/
+    (function () {
+      var _swap = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
+          return _regeneratorRuntime().wrap(
+            function _callee3$(_context3) {
+              while (1)
+                switch ((_context3.prev = _context3.next)) {
+                  case 0:
+                    return _context3.abrupt(
+                      'return',
+                      v3Swap(
+                        JSBI.BigInt(this.fee),
+                        this.sqrtRatioX96,
+                        this.tickCurrent,
+                        this.liquidity,
+                        this.tickSpacing,
+                        this.tickDataProvider,
+                        zeroForOne,
+                        amountSpecified,
+                        sqrtPriceLimitX96,
+                      ),
+                    )
+                  case 1:
+                  case 'end':
+                    return _context3.stop()
+                }
+            },
+            _callee3,
+            this,
+          )
+        }),
+      )
+      function swap(_x5, _x6, _x7) {
+        return _swap.apply(this, arguments)
+      }
+      return swap
+    })()
+  _createClass(Pool, [
+    {
+      key: 'token0Price',
+      get: function get() {
+        var _this$_token0Price
+        return (_this$_token0Price = this._token0Price) != null
+          ? _this$_token0Price
+          : (this._token0Price = new Price(
+              this.token0,
+              this.token1,
+              Q192,
+              JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96),
+            ))
+      },
+      /**
+       * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
+       */
+    },
+    {
+      key: 'token1Price',
+      get: function get() {
+        var _this$_token1Price
+        return (_this$_token1Price = this._token1Price) != null
+          ? _this$_token1Price
+          : (this._token1Price = new Price(
+              this.token1,
+              this.token0,
+              JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96),
+              Q192,
+            ))
+      },
+    },
+    {
+      key: 'chainId',
+      get: function get() {
+        return this.token0.chainId
+      },
+    },
+    {
+      key: 'tickSpacing',
+      get: function get() {
+        return TICK_SPACINGS[this.fee]
+      },
+    },
+  ])
+  return Pool
+})()
 
 /**
  * Represents a position on a Uniswap V3 Pool
  */
-var Position = /*#__PURE__*/function () {
+var Position = /*#__PURE__*/ (function () {
   /**
    * Constructs a position for a given pool with the given liquidity
    * @param pool For which pool the liquidity is assigned
@@ -1550,124 +2078,170 @@ var Position = /*#__PURE__*/function () {
     var pool = _ref.pool,
       liquidity = _ref.liquidity,
       tickLower = _ref.tickLower,
-      tickUpper = _ref.tickUpper;
+      tickUpper = _ref.tickUpper
     // cached resuts for the getters
-    this._token0Amount = null;
-    this._token1Amount = null;
-    this._mintAmounts = null;
-    !(tickLower < tickUpper) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_ORDER') : invariant(false) : void 0;
-    !(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_LOWER') : invariant(false) : void 0;
-    !(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_UPPER') : invariant(false) : void 0;
-    this.pool = pool;
-    this.tickLower = tickLower;
-    this.tickUpper = tickUpper;
-    this.liquidity = JSBI.BigInt(liquidity);
+    this._token0Amount = null
+    this._token1Amount = null
+    this._mintAmounts = null
+    !(tickLower < tickUpper)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TICK_ORDER')
+        : invariant(false)
+      : void 0
+    !(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TICK_LOWER')
+        : invariant(false)
+      : void 0
+    !(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TICK_UPPER')
+        : invariant(false)
+      : void 0
+    this.pool = pool
+    this.tickLower = tickLower
+    this.tickUpper = tickUpper
+    this.liquidity = JSBI.BigInt(liquidity)
   }
   /**
    * Returns the price of token0 at the lower tick
    */
-  var _proto = Position.prototype;
+  var _proto = Position.prototype
   /**
    * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage
    * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert
    * @returns The sqrt ratios after slippage
    */
   _proto.ratiosAfterSlippage = function ratiosAfterSlippage(slippageTolerance) {
-    var priceLower = this.pool.token0Price.asFraction.multiply(new Percent(1).subtract(slippageTolerance));
-    var priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1));
-    var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);
+    var priceLower = this.pool.token0Price.asFraction.multiply(new Percent(1).subtract(slippageTolerance))
+    var priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1))
+    var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator)
     if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {
-      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));
+      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1))
     }
-    var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);
+    var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator)
     if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {
-      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));
+      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1))
     }
     return {
       sqrtRatioX96Lower: sqrtRatioX96Lower,
-      sqrtRatioX96Upper: sqrtRatioX96Upper
-    };
+      sqrtRatioX96Upper: sqrtRatioX96Upper,
+    }
   }
   /**
    * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position
    * with the given slippage tolerance
    * @param slippageTolerance Tolerance of unfavorable slippage from the current price
    * @returns The amounts, with slippage
-   */;
+   */
   _proto.mintAmountsWithSlippage = function mintAmountsWithSlippage(slippageTolerance) {
     // get lower/upper prices
     var _this$ratiosAfterSlip = this.ratiosAfterSlippage(slippageTolerance),
       sqrtRatioX96Upper = _this$ratiosAfterSlip.sqrtRatioX96Upper,
-      sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower;
+      sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower
     // construct counterfactual pools
-    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
-    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper));
+    var poolLower = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Lower,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower),
+    )
+    var poolUpper = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Upper,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper),
+    )
     // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)
-    var positionThatWillBeCreated = Position.fromAmounts(_extends({
-      pool: this.pool,
-      tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }, this.mintAmounts, {
-      useFullPrecision: false
-    }));
+    var positionThatWillBeCreated = Position.fromAmounts(
+      _extends(
+        {
+          pool: this.pool,
+          tickLower: this.tickLower,
+          tickUpper: this.tickUpper,
+        },
+        this.mintAmounts,
+        {
+          useFullPrecision: false,
+        },
+      ),
+    )
     // we want the smaller amounts...
     // ...which occurs at the upper price for amount0...
     var amount0 = new Position({
       pool: poolUpper,
       liquidity: positionThatWillBeCreated.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).mintAmounts.amount0;
+      tickUpper: this.tickUpper,
+    }).mintAmounts.amount0
     // ...and the lower for amount1
     var amount1 = new Position({
       pool: poolLower,
       liquidity: positionThatWillBeCreated.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).mintAmounts.amount1;
+      tickUpper: this.tickUpper,
+    }).mintAmounts.amount1
     return {
       amount0: amount0,
-      amount1: amount1
-    };
+      amount1: amount1,
+    }
   }
   /**
    * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the
    * position with the given slippage tolerance
    * @param slippageTolerance tolerance of unfavorable slippage from the current price
    * @returns The amounts, with slippage
-   */;
+   */
   _proto.burnAmountsWithSlippage = function burnAmountsWithSlippage(slippageTolerance) {
     // get lower/upper prices
     var _this$ratiosAfterSlip2 = this.ratiosAfterSlippage(slippageTolerance),
       sqrtRatioX96Upper = _this$ratiosAfterSlip2.sqrtRatioX96Upper,
-      sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower;
+      sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower
     // construct counterfactual pools
-    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
-    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper));
+    var poolLower = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Lower,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower),
+    )
+    var poolUpper = new Pool(
+      this.pool.token0,
+      this.pool.token1,
+      this.pool.fee,
+      sqrtRatioX96Upper,
+      0 /* liquidity doesn't matter */,
+      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper),
+    )
     // we want the smaller amounts...
     // ...which occurs at the upper price for amount0...
     var amount0 = new Position({
       pool: poolUpper,
       liquidity: this.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).amount0;
+      tickUpper: this.tickUpper,
+    }).amount0
     // ...and the lower for amount1
     var amount1 = new Position({
       pool: poolLower,
       liquidity: this.liquidity,
       tickLower: this.tickLower,
-      tickUpper: this.tickUpper
-    }).amount1;
+      tickUpper: this.tickUpper,
+    }).amount1
     return {
       amount0: amount0.quotient,
-      amount1: amount1.quotient
-    };
+      amount1: amount1.quotient,
+    }
   }
   /**
    * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at
    * the current price for the pool
-   */;
+   */
   /**
    * Computes the maximum amount of liquidity received for a given amount of token0, token1,
    * and the prices at the tick boundaries.
@@ -1686,15 +2260,22 @@ var Position = /*#__PURE__*/function () {
       tickUpper = _ref2.tickUpper,
       amount0 = _ref2.amount0,
       amount1 = _ref2.amount1,
-      useFullPrecision = _ref2.useFullPrecision;
-    var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
-    var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
+      useFullPrecision = _ref2.useFullPrecision
+    var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower)
+    var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper)
     return new Position({
       pool: pool,
       tickLower: tickLower,
       tickUpper: tickUpper,
-      liquidity: maxLiquidityForAmounts(pool.sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision)
-    });
+      liquidity: maxLiquidityForAmounts(
+        pool.sqrtRatioX96,
+        sqrtRatioAX96,
+        sqrtRatioBX96,
+        amount0,
+        amount1,
+        useFullPrecision,
+      ),
+    })
   }
   /**
    * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1
@@ -1705,21 +2286,21 @@ var Position = /*#__PURE__*/function () {
    * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
    * not what core can theoretically support
    * @returns The position
-   */;
+   */
   Position.fromAmount0 = function fromAmount0(_ref3) {
     var pool = _ref3.pool,
       tickLower = _ref3.tickLower,
       tickUpper = _ref3.tickUpper,
       amount0 = _ref3.amount0,
-      useFullPrecision = _ref3.useFullPrecision;
+      useFullPrecision = _ref3.useFullPrecision
     return Position.fromAmounts({
       pool: pool,
       tickLower: tickLower,
       tickUpper: tickUpper,
       amount0: amount0,
       amount1: MaxUint256,
-      useFullPrecision: useFullPrecision
-    });
+      useFullPrecision: useFullPrecision,
+    })
   }
   /**
    * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0
@@ -1728,12 +2309,12 @@ var Position = /*#__PURE__*/function () {
    * @param tickUpper The upper tick
    * @param amount1 The desired amount of token1
    * @returns The position
-   */;
+   */
   Position.fromAmount1 = function fromAmount1(_ref4) {
     var pool = _ref4.pool,
       tickLower = _ref4.tickLower,
       tickUpper = _ref4.tickUpper,
-      amount1 = _ref4.amount1;
+      amount1 = _ref4.amount1
     // this function always uses full precision,
     return Position.fromAmounts({
       pool: pool,
@@ -1741,89 +2322,147 @@ var Position = /*#__PURE__*/function () {
       tickUpper: tickUpper,
       amount0: MaxUint256,
       amount1: amount1,
-      useFullPrecision: true
-    });
-  };
-  _createClass(Position, [{
-    key: "token0PriceLower",
-    get: function get() {
-      return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower);
-    }
-    /**
-     * Returns the price of token0 at the upper tick
-     */
-  }, {
-    key: "token0PriceUpper",
-    get: function get() {
-      return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper);
-    }
-    /**
-     * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
-     */
-  }, {
-    key: "amount0",
-    get: function get() {
-      if (this._token0Amount === null) {
-        if (this.pool.tickCurrent < this.tickLower) {
-          this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
-        } else if (this.pool.tickCurrent < this.tickUpper) {
-          this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
-        } else {
-          this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, ZERO);
+      useFullPrecision: true,
+    })
+  }
+  _createClass(Position, [
+    {
+      key: 'token0PriceLower',
+      get: function get() {
+        return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower)
+      },
+      /**
+       * Returns the price of token0 at the upper tick
+       */
+    },
+    {
+      key: 'token0PriceUpper',
+      get: function get() {
+        return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper)
+      },
+      /**
+       * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
+       */
+    },
+    {
+      key: 'amount0',
+      get: function get() {
+        if (this._token0Amount === null) {
+          if (this.pool.tickCurrent < this.tickLower) {
+            this._token0Amount = CurrencyAmount.fromRawAmount(
+              this.pool.token0,
+              SqrtPriceMath.getAmount0Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                false,
+              ),
+            )
+          } else if (this.pool.tickCurrent < this.tickUpper) {
+            this._token0Amount = CurrencyAmount.fromRawAmount(
+              this.pool.token0,
+              SqrtPriceMath.getAmount0Delta(
+                this.pool.sqrtRatioX96,
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                false,
+              ),
+            )
+          } else {
+            this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, ZERO)
+          }
         }
-      }
-      return this._token0Amount;
-    }
-    /**
-     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
-     */
-  }, {
-    key: "amount1",
-    get: function get() {
-      if (this._token1Amount === null) {
-        if (this.pool.tickCurrent < this.tickLower) {
-          this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, ZERO);
-        } else if (this.pool.tickCurrent < this.tickUpper) {
-          this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, false));
-        } else {
-          this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
+        return this._token0Amount
+      },
+      /**
+       * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
+       */
+    },
+    {
+      key: 'amount1',
+      get: function get() {
+        if (this._token1Amount === null) {
+          if (this.pool.tickCurrent < this.tickLower) {
+            this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, ZERO)
+          } else if (this.pool.tickCurrent < this.tickUpper) {
+            this._token1Amount = CurrencyAmount.fromRawAmount(
+              this.pool.token1,
+              SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                this.pool.sqrtRatioX96,
+                this.liquidity,
+                false,
+              ),
+            )
+          } else {
+            this._token1Amount = CurrencyAmount.fromRawAmount(
+              this.pool.token1,
+              SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                false,
+              ),
+            )
+          }
         }
-      }
-      return this._token1Amount;
-    }
-  }, {
-    key: "mintAmounts",
-    get: function get() {
-      if (this._mintAmounts === null) {
-        if (this.pool.tickCurrent < this.tickLower) {
-          return {
-            amount0: SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
-            amount1: ZERO
-          };
-        } else if (this.pool.tickCurrent < this.tickUpper) {
-          return {
-            amount0: SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
-            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, true)
-          };
-        } else {
-          return {
-            amount0: ZERO,
-            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true)
-          };
+        return this._token1Amount
+      },
+    },
+    {
+      key: 'mintAmounts',
+      get: function get() {
+        if (this._mintAmounts === null) {
+          if (this.pool.tickCurrent < this.tickLower) {
+            return {
+              amount0: SqrtPriceMath.getAmount0Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                true,
+              ),
+              amount1: ZERO,
+            }
+          } else if (this.pool.tickCurrent < this.tickUpper) {
+            return {
+              amount0: SqrtPriceMath.getAmount0Delta(
+                this.pool.sqrtRatioX96,
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                true,
+              ),
+              amount1: SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                this.pool.sqrtRatioX96,
+                this.liquidity,
+                true,
+              ),
+            }
+          } else {
+            return {
+              amount0: ZERO,
+              amount1: SqrtPriceMath.getAmount1Delta(
+                TickMath.getSqrtRatioAtTick(this.tickLower),
+                TickMath.getSqrtRatioAtTick(this.tickUpper),
+                this.liquidity,
+                true,
+              ),
+            }
+          }
         }
-      }
-      return this._mintAmounts;
-    }
-  }]);
-  return Position;
-}();
+        return this._mintAmounts
+      },
+    },
+  ])
+  return Position
+})()
 
 /**
  * Represents a list of pools through which a swap can occur
  * @template TInput The input token
  * @template TOutput The output token
  */
-var Route = /*#__PURE__*/function () {
+var Route = /*#__PURE__*/ (function () {
   /**
    * Creates an instance of route.
    * @param pools An array of `Pool` objects, ordered by the route the swap will take
@@ -1831,68 +2470,98 @@ var Route = /*#__PURE__*/function () {
    * @param output The output token
    */
   function Route(pools, input, output) {
-    this._midPrice = null;
-    !(pools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS') : invariant(false) : void 0;
-    var chainId = pools[0].chainId;
+    this._midPrice = null
+    !(pools.length > 0)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'POOLS')
+        : invariant(false)
+      : void 0
+    var chainId = pools[0].chainId
     var allOnSameChain = pools.every(function (pool) {
-      return pool.chainId === chainId;
-    });
-    !allOnSameChain ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;
-    var wrappedInput = input.wrapped;
-    !pools[0].involvesToken(wrappedInput) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT') : invariant(false) : void 0;
-    !pools[pools.length - 1].involvesToken(output.wrapped) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;
+      return pool.chainId === chainId
+    })
+    !allOnSameChain
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'CHAIN_IDS')
+        : invariant(false)
+      : void 0
+    var wrappedInput = input.wrapped
+    !pools[0].involvesToken(wrappedInput)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'INPUT')
+        : invariant(false)
+      : void 0
+    !pools[pools.length - 1].involvesToken(output.wrapped)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'OUTPUT')
+        : invariant(false)
+      : void 0
     /**
      * Normalizes token0-token1 order and selects the next token/fee step to add to the path
      * */
-    var tokenPath = [wrappedInput];
-    for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done;) {
+    var tokenPath = [wrappedInput]
+    for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done; ) {
       var _step$value = _step.value,
         i = _step$value[0],
-        pool = _step$value[1];
-      var currentInputToken = tokenPath[i];
-      !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'PATH') : invariant(false) : void 0;
-      var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0;
-      tokenPath.push(nextToken);
-    }
-    this.pools = pools;
-    this.tokenPath = tokenPath;
-    this.input = input;
-    this.output = output != null ? output : tokenPath[tokenPath.length - 1];
-  }
-  _createClass(Route, [{
-    key: "chainId",
-    get: function get() {
-      return this.pools[0].chainId;
+        pool = _step$value[1]
+      var currentInputToken = tokenPath[i]
+      !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1))
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'PATH')
+          : invariant(false)
+        : void 0
+      var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0
+      tokenPath.push(nextToken)
     }
-    /**
-     * Returns the mid price of the route
-     */
-  }, {
-    key: "midPrice",
-    get: function get() {
-      if (this._midPrice !== null) return this._midPrice;
-      var price = this.pools.slice(1).reduce(function (_ref, pool) {
-        var nextInput = _ref.nextInput,
-          price = _ref.price;
-        return nextInput.equals(pool.token0) ? {
-          nextInput: pool.token1,
-          price: price.multiply(pool.token0Price)
-        } : {
-          nextInput: pool.token0,
-          price: price.multiply(pool.token1Price)
-        };
-      }, this.pools[0].token0.equals(this.input.wrapped) ? {
-        nextInput: this.pools[0].token1,
-        price: this.pools[0].token0Price
-      } : {
-        nextInput: this.pools[0].token0,
-        price: this.pools[0].token1Price
-      }).price;
-      return this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator);
-    }
-  }]);
-  return Route;
-}();
+    this.pools = pools
+    this.tokenPath = tokenPath
+    this.input = input
+    this.output = output != null ? output : tokenPath[tokenPath.length - 1]
+  }
+  _createClass(Route, [
+    {
+      key: 'chainId',
+      get: function get() {
+        return this.pools[0].chainId
+      },
+      /**
+       * Returns the mid price of the route
+       */
+    },
+    {
+      key: 'midPrice',
+      get: function get() {
+        if (this._midPrice !== null) return this._midPrice
+        var price = this.pools.slice(1).reduce(
+          function (_ref, pool) {
+            var nextInput = _ref.nextInput,
+              price = _ref.price
+            return nextInput.equals(pool.token0)
+              ? {
+                  nextInput: pool.token1,
+                  price: price.multiply(pool.token0Price),
+                }
+              : {
+                  nextInput: pool.token0,
+                  price: price.multiply(pool.token1Price),
+                }
+          },
+          this.pools[0].token0.equals(this.input.wrapped)
+            ? {
+                nextInput: this.pools[0].token1,
+                price: this.pools[0].token0Price,
+              }
+            : {
+                nextInput: this.pools[0].token0,
+                price: this.pools[0].token1Price,
+              },
+        ).price
+        return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))
+      },
+    },
+  ])
+  return Route
+})()
 
 /**
  * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them
@@ -1905,31 +2574,39 @@ var Route = /*#__PURE__*/function () {
  */
 function tradeComparator(a, b) {
   // must have same input and output token for comparison
-  !a.inputAmount.currency.equals(b.inputAmount.currency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT_CURRENCY') : invariant(false) : void 0;
-  !a.outputAmount.currency.equals(b.outputAmount.currency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT_CURRENCY') : invariant(false) : void 0;
+  !a.inputAmount.currency.equals(b.inputAmount.currency)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'INPUT_CURRENCY')
+      : invariant(false)
+    : void 0
+  !a.outputAmount.currency.equals(b.outputAmount.currency)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'OUTPUT_CURRENCY')
+      : invariant(false)
+    : void 0
   if (a.outputAmount.equalTo(b.outputAmount)) {
     if (a.inputAmount.equalTo(b.inputAmount)) {
       // consider the number of hops since each hop costs gas
       var aHops = a.swaps.reduce(function (total, cur) {
-        return total + cur.route.tokenPath.length;
-      }, 0);
+        return total + cur.route.tokenPath.length
+      }, 0)
       var bHops = b.swaps.reduce(function (total, cur) {
-        return total + cur.route.tokenPath.length;
-      }, 0);
-      return aHops - bHops;
+        return total + cur.route.tokenPath.length
+      }, 0)
+      return aHops - bHops
     }
     // trade A requires less input than trade B, so A should come first
     if (a.inputAmount.lessThan(b.inputAmount)) {
-      return -1;
+      return -1
     } else {
-      return 1;
+      return 1
     }
   } else {
     // tradeA has less output than trade B, so should come second
     if (a.outputAmount.lessThan(b.outputAmount)) {
-      return 1;
+      return 1
     } else {
-      return -1;
+      return -1
     }
   }
 }
@@ -1945,7 +2622,7 @@ function tradeComparator(a, b) {
  * @template TOutput The output token, either Ether or an ERC-20
  * @template TTradeType The trade type, either exact input or exact output
  */
-var Trade = /*#__PURE__*/function () {
+var Trade = /*#__PURE__*/ (function () {
   /**
    * Construct a trade by passing in the pre-computed property values
    * @param routes The routes through which the trade occurs
@@ -1953,34 +2630,48 @@ var Trade = /*#__PURE__*/function () {
    */
   function Trade(_ref) {
     var routes = _ref.routes,
-      tradeType = _ref.tradeType;
-    var inputCurrency = routes[0].inputAmount.currency;
-    var outputCurrency = routes[0].outputAmount.currency;
+      tradeType = _ref.tradeType
+    var inputCurrency = routes[0].inputAmount.currency
+    var outputCurrency = routes[0].outputAmount.currency
     !routes.every(function (_ref2) {
-      var route = _ref2.route;
-      return inputCurrency.wrapped.equals(route.input.wrapped);
-    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT_CURRENCY_MATCH') : invariant(false) : void 0;
+      var route = _ref2.route
+      return inputCurrency.wrapped.equals(route.input.wrapped)
+    })
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'INPUT_CURRENCY_MATCH')
+        : invariant(false)
+      : void 0
     !routes.every(function (_ref3) {
-      var route = _ref3.route;
-      return outputCurrency.wrapped.equals(route.output.wrapped);
-    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT_CURRENCY_MATCH') : invariant(false) : void 0;
-    var numPools = routes.map(function (_ref4) {
-      var route = _ref4.route;
-      return route.pools.length;
-    }).reduce(function (total, cur) {
-      return total + cur;
-    }, 0);
-    var poolAddressSet = new Set();
-    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done;) {
-      var route = _step.value.route;
-      for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done;) {
-        var pool = _step2.value;
-        poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee));
+      var route = _ref3.route
+      return outputCurrency.wrapped.equals(route.output.wrapped)
+    })
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'OUTPUT_CURRENCY_MATCH')
+        : invariant(false)
+      : void 0
+    var numPools = routes
+      .map(function (_ref4) {
+        var route = _ref4.route
+        return route.pools.length
+      })
+      .reduce(function (total, cur) {
+        return total + cur
+      }, 0)
+    var poolAddressSet = new Set()
+    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done; ) {
+      var route = _step.value.route
+      for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done; ) {
+        var pool = _step2.value
+        poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee))
       }
     }
-    !(numPools === poolAddressSet.size) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS_DUPLICATED') : invariant(false) : void 0;
-    this.swaps = routes;
-    this.tradeType = tradeType;
+    !(numPools === poolAddressSet.size)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'POOLS_DUPLICATED')
+        : invariant(false)
+      : void 0
+    this.swaps = routes
+    this.tradeType = tradeType
   }
   /**
    * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes
@@ -1998,24 +2689,27 @@ var Trade = /*#__PURE__*/function () {
    * @returns The exact in trade
    */
   Trade.exactIn =
-  /*#__PURE__*/
-  function () {
-    var _exactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(route, amountIn) {
-      return _regeneratorRuntime().wrap(function _callee$(_context) {
-        while (1) switch (_context.prev = _context.next) {
-          case 0:
-            return _context.abrupt("return", Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT));
-          case 1:
-          case "end":
-            return _context.stop();
-        }
-      }, _callee);
-    }));
-    function exactIn(_x, _x2) {
-      return _exactIn.apply(this, arguments);
-    }
-    return exactIn;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _exactIn = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(route, amountIn) {
+          return _regeneratorRuntime().wrap(function _callee$(_context) {
+            while (1)
+              switch ((_context.prev = _context.next)) {
+                case 0:
+                  return _context.abrupt('return', Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT))
+                case 1:
+                case 'end':
+                  return _context.stop()
+              }
+          }, _callee)
+        }),
+      )
+      function exactIn(_x, _x2) {
+        return _exactIn.apply(this, arguments)
+      }
+      return exactIn
+    })()
   /**
    * Constructs an exact out trade with the given amount out and route
    * @template TInput The input token, either Ether or an ERC-20
@@ -2024,26 +2718,28 @@ var Trade = /*#__PURE__*/function () {
    * @param amountOut The amount returned by the trade
    * @returns The exact out trade
    */
-  ;
   Trade.exactOut =
-  /*#__PURE__*/
-  function () {
-    var _exactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(route, amountOut) {
-      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
-        while (1) switch (_context2.prev = _context2.next) {
-          case 0:
-            return _context2.abrupt("return", Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT));
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }, _callee2);
-    }));
-    function exactOut(_x3, _x4) {
-      return _exactOut.apply(this, arguments);
-    }
-    return exactOut;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _exactOut = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(route, amountOut) {
+          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+            while (1)
+              switch ((_context2.prev = _context2.next)) {
+                case 0:
+                  return _context2.abrupt('return', Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT))
+                case 1:
+                case 'end':
+                  return _context2.stop()
+              }
+          }, _callee2)
+        }),
+      )
+      function exactOut(_x3, _x4) {
+        return _exactOut.apply(this, arguments)
+      }
+      return exactOut
+    })()
   /**
    * Constructs a trade by simulating swaps through the given route
    * @template TInput The input token, either Ether or an ERC-20.
@@ -2054,87 +2750,120 @@ var Trade = /*#__PURE__*/function () {
    * @param tradeType whether the trade is an exact input or exact output swap
    * @returns The route
    */
-  ;
   Trade.fromRoute =
-  /*#__PURE__*/
-  function () {
-    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(route, amount, tradeType) {
-      var amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput, _outputAmount, _i, _pool, _yield$_pool$getInput, _inputAmount;
-      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
-        while (1) switch (_context3.prev = _context3.next) {
-          case 0:
-            amounts = new Array(route.tokenPath.length);
-            if (!(tradeType === TradeType.EXACT_INPUT)) {
-              _context3.next = 19;
-              break;
-            }
-            !amount.currency.equals(route.input) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT') : invariant(false) : void 0;
-            amounts[0] = amount.wrapped;
-            i = 0;
-          case 5:
-            if (!(i < route.tokenPath.length - 1)) {
-              _context3.next = 15;
-              break;
-            }
-            pool = route.pools[i];
-            _context3.next = 9;
-            return pool.getOutputAmount(amounts[i]);
-          case 9:
-            _yield$pool$getOutput = _context3.sent;
-            _outputAmount = _yield$pool$getOutput[0];
-            amounts[i + 1] = _outputAmount;
-          case 12:
-            i++;
-            _context3.next = 5;
-            break;
-          case 15:
-            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
-            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
-            _context3.next = 34;
-            break;
-          case 19:
-            !amount.currency.equals(route.output) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;
-            amounts[amounts.length - 1] = amount.wrapped;
-            _i = route.tokenPath.length - 1;
-          case 22:
-            if (!(_i > 0)) {
-              _context3.next = 32;
-              break;
-            }
-            _pool = route.pools[_i - 1];
-            _context3.next = 26;
-            return _pool.getInputAmount(amounts[_i]);
-          case 26:
-            _yield$_pool$getInput = _context3.sent;
-            _inputAmount = _yield$_pool$getInput[0];
-            amounts[_i - 1] = _inputAmount;
-          case 29:
-            _i--;
-            _context3.next = 22;
-            break;
-          case 32:
-            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
-            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
-          case 34:
-            return _context3.abrupt("return", new Trade({
-              routes: [{
-                inputAmount: inputAmount,
-                outputAmount: outputAmount,
-                route: route
-              }],
-              tradeType: tradeType
-            }));
-          case 35:
-          case "end":
-            return _context3.stop();
-        }
-      }, _callee3);
-    }));
-    function fromRoute(_x5, _x6, _x7) {
-      return _fromRoute.apply(this, arguments);
-    }
-    return fromRoute;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _fromRoute = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee3(route, amount, tradeType) {
+          var amounts,
+            inputAmount,
+            outputAmount,
+            i,
+            pool,
+            _yield$pool$getOutput,
+            _outputAmount,
+            _i,
+            _pool,
+            _yield$_pool$getInput,
+            _inputAmount
+          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
+            while (1)
+              switch ((_context3.prev = _context3.next)) {
+                case 0:
+                  amounts = new Array(route.tokenPath.length)
+                  if (!(tradeType === TradeType.EXACT_INPUT)) {
+                    _context3.next = 19
+                    break
+                  }
+                  !amount.currency.equals(route.input)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'INPUT')
+                      : invariant(false)
+                    : void 0
+                  amounts[0] = amount.wrapped
+                  i = 0
+                case 5:
+                  if (!(i < route.tokenPath.length - 1)) {
+                    _context3.next = 15
+                    break
+                  }
+                  pool = route.pools[i]
+                  _context3.next = 9
+                  return pool.getOutputAmount(amounts[i])
+                case 9:
+                  _yield$pool$getOutput = _context3.sent
+                  _outputAmount = _yield$pool$getOutput[0]
+                  amounts[i + 1] = _outputAmount
+                case 12:
+                  i++
+                  _context3.next = 5
+                  break
+                case 15:
+                  inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)
+                  outputAmount = CurrencyAmount.fromFractionalAmount(
+                    route.output,
+                    amounts[amounts.length - 1].numerator,
+                    amounts[amounts.length - 1].denominator,
+                  )
+                  _context3.next = 34
+                  break
+                case 19:
+                  !amount.currency.equals(route.output)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'OUTPUT')
+                      : invariant(false)
+                    : void 0
+                  amounts[amounts.length - 1] = amount.wrapped
+                  _i = route.tokenPath.length - 1
+                case 22:
+                  if (!(_i > 0)) {
+                    _context3.next = 32
+                    break
+                  }
+                  _pool = route.pools[_i - 1]
+                  _context3.next = 26
+                  return _pool.getInputAmount(amounts[_i])
+                case 26:
+                  _yield$_pool$getInput = _context3.sent
+                  _inputAmount = _yield$_pool$getInput[0]
+                  amounts[_i - 1] = _inputAmount
+                case 29:
+                  _i--
+                  _context3.next = 22
+                  break
+                case 32:
+                  inputAmount = CurrencyAmount.fromFractionalAmount(
+                    route.input,
+                    amounts[0].numerator,
+                    amounts[0].denominator,
+                  )
+                  outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator)
+                case 34:
+                  return _context3.abrupt(
+                    'return',
+                    new Trade({
+                      routes: [
+                        {
+                          inputAmount: inputAmount,
+                          outputAmount: outputAmount,
+                          route: route,
+                        },
+                      ],
+                      tradeType: tradeType,
+                    }),
+                  )
+                case 35:
+                case 'end':
+                  return _context3.stop()
+              }
+          }, _callee3)
+        }),
+      )
+      function fromRoute(_x5, _x6, _x7) {
+        return _fromRoute.apply(this, arguments)
+      }
+      return fromRoute
+    })()
   /**
    * Constructs a trade from routes by simulating swaps
    *
@@ -2145,102 +2874,147 @@ var Trade = /*#__PURE__*/function () {
    * @param tradeType whether the trade is an exact input or exact output swap
    * @returns The trade
    */
-  ;
   Trade.fromRoutes =
-  /*#__PURE__*/
-  function () {
-    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(routes, tradeType) {
-      var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput2, _outputAmount2, _i2, _pool2, _yield$_pool2$getInpu, _inputAmount2;
-      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
-        while (1) switch (_context4.prev = _context4.next) {
-          case 0:
-            populatedRoutes = [];
-            _iterator3 = _createForOfIteratorHelperLoose(routes);
-          case 2:
-            if ((_step3 = _iterator3()).done) {
-              _context4.next = 43;
-              break;
-            }
-            _step3$value = _step3.value, route = _step3$value.route, amount = _step3$value.amount;
-            amounts = new Array(route.tokenPath.length);
-            inputAmount = void 0;
-            outputAmount = void 0;
-            if (!(tradeType === TradeType.EXACT_INPUT)) {
-              _context4.next = 25;
-              break;
-            }
-            !amount.currency.equals(route.input) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT') : invariant(false) : void 0;
-            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
-            amounts[0] = CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);
-            i = 0;
-          case 12:
-            if (!(i < route.tokenPath.length - 1)) {
-              _context4.next = 22;
-              break;
-            }
-            pool = route.pools[i];
-            _context4.next = 16;
-            return pool.getOutputAmount(amounts[i]);
-          case 16:
-            _yield$pool$getOutput2 = _context4.sent;
-            _outputAmount2 = _yield$pool$getOutput2[0];
-            amounts[i + 1] = _outputAmount2;
-          case 19:
-            i++;
-            _context4.next = 12;
-            break;
-          case 22:
-            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
-            _context4.next = 40;
-            break;
-          case 25:
-            !amount.currency.equals(route.output) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;
-            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
-            amounts[amounts.length - 1] = CurrencyAmount.fromFractionalAmount(route.output.wrapped, amount.numerator, amount.denominator);
-            _i2 = route.tokenPath.length - 1;
-          case 29:
-            if (!(_i2 > 0)) {
-              _context4.next = 39;
-              break;
-            }
-            _pool2 = route.pools[_i2 - 1];
-            _context4.next = 33;
-            return _pool2.getInputAmount(amounts[_i2]);
-          case 33:
-            _yield$_pool2$getInpu = _context4.sent;
-            _inputAmount2 = _yield$_pool2$getInpu[0];
-            amounts[_i2 - 1] = _inputAmount2;
-          case 36:
-            _i2--;
-            _context4.next = 29;
-            break;
-          case 39:
-            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
-          case 40:
-            populatedRoutes.push({
-              route: route,
-              inputAmount: inputAmount,
-              outputAmount: outputAmount
-            });
-          case 41:
-            _context4.next = 2;
-            break;
-          case 43:
-            return _context4.abrupt("return", new Trade({
-              routes: populatedRoutes,
-              tradeType: tradeType
-            }));
-          case 44:
-          case "end":
-            return _context4.stop();
-        }
-      }, _callee4);
-    }));
-    function fromRoutes(_x8, _x9) {
-      return _fromRoutes.apply(this, arguments);
-    }
-    return fromRoutes;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _fromRoutes = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(function _callee4(routes, tradeType) {
+          var populatedRoutes,
+            _iterator3,
+            _step3,
+            _step3$value,
+            route,
+            amount,
+            amounts,
+            inputAmount,
+            outputAmount,
+            i,
+            pool,
+            _yield$pool$getOutput2,
+            _outputAmount2,
+            _i2,
+            _pool2,
+            _yield$_pool2$getInpu,
+            _inputAmount2
+          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
+            while (1)
+              switch ((_context4.prev = _context4.next)) {
+                case 0:
+                  populatedRoutes = []
+                  _iterator3 = _createForOfIteratorHelperLoose(routes)
+                case 2:
+                  if ((_step3 = _iterator3()).done) {
+                    _context4.next = 43
+                    break
+                  }
+                  ;(_step3$value = _step3.value), (route = _step3$value.route), (amount = _step3$value.amount)
+                  amounts = new Array(route.tokenPath.length)
+                  inputAmount = void 0
+                  outputAmount = void 0
+                  if (!(tradeType === TradeType.EXACT_INPUT)) {
+                    _context4.next = 25
+                    break
+                  }
+                  !amount.currency.equals(route.input)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'INPUT')
+                      : invariant(false)
+                    : void 0
+                  inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)
+                  amounts[0] = CurrencyAmount.fromFractionalAmount(
+                    route.input.wrapped,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  i = 0
+                case 12:
+                  if (!(i < route.tokenPath.length - 1)) {
+                    _context4.next = 22
+                    break
+                  }
+                  pool = route.pools[i]
+                  _context4.next = 16
+                  return pool.getOutputAmount(amounts[i])
+                case 16:
+                  _yield$pool$getOutput2 = _context4.sent
+                  _outputAmount2 = _yield$pool$getOutput2[0]
+                  amounts[i + 1] = _outputAmount2
+                case 19:
+                  i++
+                  _context4.next = 12
+                  break
+                case 22:
+                  outputAmount = CurrencyAmount.fromFractionalAmount(
+                    route.output,
+                    amounts[amounts.length - 1].numerator,
+                    amounts[amounts.length - 1].denominator,
+                  )
+                  _context4.next = 40
+                  break
+                case 25:
+                  !amount.currency.equals(route.output)
+                    ? process.env.NODE_ENV !== 'production'
+                      ? invariant(false, 'OUTPUT')
+                      : invariant(false)
+                    : void 0
+                  outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator)
+                  amounts[amounts.length - 1] = CurrencyAmount.fromFractionalAmount(
+                    route.output.wrapped,
+                    amount.numerator,
+                    amount.denominator,
+                  )
+                  _i2 = route.tokenPath.length - 1
+                case 29:
+                  if (!(_i2 > 0)) {
+                    _context4.next = 39
+                    break
+                  }
+                  _pool2 = route.pools[_i2 - 1]
+                  _context4.next = 33
+                  return _pool2.getInputAmount(amounts[_i2])
+                case 33:
+                  _yield$_pool2$getInpu = _context4.sent
+                  _inputAmount2 = _yield$_pool2$getInpu[0]
+                  amounts[_i2 - 1] = _inputAmount2
+                case 36:
+                  _i2--
+                  _context4.next = 29
+                  break
+                case 39:
+                  inputAmount = CurrencyAmount.fromFractionalAmount(
+                    route.input,
+                    amounts[0].numerator,
+                    amounts[0].denominator,
+                  )
+                case 40:
+                  populatedRoutes.push({
+                    route: route,
+                    inputAmount: inputAmount,
+                    outputAmount: outputAmount,
+                  })
+                case 41:
+                  _context4.next = 2
+                  break
+                case 43:
+                  return _context4.abrupt(
+                    'return',
+                    new Trade({
+                      routes: populatedRoutes,
+                      tradeType: tradeType,
+                    }),
+                  )
+                case 44:
+                case 'end':
+                  return _context4.stop()
+              }
+          }, _callee4)
+        }),
+      )
+      function fromRoutes(_x8, _x9) {
+        return _fromRoutes.apply(this, arguments)
+      }
+      return fromRoutes
+    })()
   /**
    * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade
    * elsewhere and do not have any tick data
@@ -2250,15 +3024,18 @@ var Trade = /*#__PURE__*/function () {
    * @param constructorArguments The arguments passed to the trade constructor
    * @returns The unchecked trade
    */
-  ;
   Trade.createUncheckedTrade = function createUncheckedTrade(constructorArguments) {
-    return new Trade(_extends({}, constructorArguments, {
-      routes: [{
-        inputAmount: constructorArguments.inputAmount,
-        outputAmount: constructorArguments.outputAmount,
-        route: constructorArguments.route
-      }]
-    }));
+    return new Trade(
+      _extends({}, constructorArguments, {
+        routes: [
+          {
+            inputAmount: constructorArguments.inputAmount,
+            outputAmount: constructorArguments.outputAmount,
+            route: constructorArguments.route,
+          },
+        ],
+      }),
+    )
   }
   /**
    * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade
@@ -2268,52 +3045,68 @@ var Trade = /*#__PURE__*/function () {
    * @template TTradeType The type of the trade, either exact in or exact out
    * @param constructorArguments The arguments passed to the trade constructor
    * @returns The unchecked trade
-   */;
+   */
   Trade.createUncheckedTradeWithMultipleRoutes = function createUncheckedTradeWithMultipleRoutes(constructorArguments) {
-    return new Trade(constructorArguments);
+    return new Trade(constructorArguments)
   }
   /**
    * Get the minimum amount that must be received from this trade for the given slippage tolerance
    * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
    * @returns The amount out
-   */;
-  var _proto = Trade.prototype;
+   */
+  var _proto = Trade.prototype
   _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {
     if (amountOut === void 0) {
-      amountOut = this.outputAmount;
+      amountOut = this.outputAmount
     }
-    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;
+    !!slippageTolerance.lessThan(ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'SLIPPAGE_TOLERANCE')
+        : invariant(false)
+      : void 0
     if (this.tradeType === TradeType.EXACT_OUTPUT) {
-      return amountOut;
+      return amountOut
     } else {
-      var slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;
-      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);
+      var slippageAdjustedAmountOut = new Fraction(ONE)
+        .add(slippageTolerance)
+        .invert()
+        .multiply(amountOut.quotient).quotient
+      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)
     }
   }
   /**
    * Get the maximum amount in that can be spent via this trade for the given slippage tolerance
    * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
    * @returns The amount in
-   */;
+   */
   _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {
     if (amountIn === void 0) {
-      amountIn = this.inputAmount;
+      amountIn = this.inputAmount
     }
-    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;
+    !!slippageTolerance.lessThan(ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'SLIPPAGE_TOLERANCE')
+        : invariant(false)
+      : void 0
     if (this.tradeType === TradeType.EXACT_INPUT) {
-      return amountIn;
+      return amountIn
     } else {
-      var slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient;
-      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);
+      var slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient
+      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)
     }
   }
   /**
    * Return the execution price after accounting for slippage tolerance
    * @param slippageTolerance the allowed tolerated slippage
    * @returns The execution price
-   */;
+   */
   _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {
-    return new Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
+    return new Price(
+      this.inputAmount.currency,
+      this.outputAmount.currency,
+      this.maximumAmountIn(slippageTolerance).quotient,
+      this.minimumAmountOut(slippageTolerance).quotient,
+    )
   }
   /**
    * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
@@ -2329,108 +3122,164 @@ var Trade = /*#__PURE__*/function () {
    * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter
    * @param bestTrades used in recursion; the current list of best trades
    * @returns The exact in trade
-   */;
+   */
   Trade.bestTradeExactIn =
-  /*#__PURE__*/
-  function () {
-    var _bestTradeExactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(pools, currencyAmountIn, currencyOut, _temp,
-    // used in recursion.
-    currentPools, nextAmountIn, bestTrades) {
-      var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i, pool, amountOut, _yield$pool$getOutput3, poolsExcludingThisPool;
-      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
-        while (1) switch (_context5.prev = _context5.next) {
-          case 0:
-            _ref5 = _temp === void 0 ? {} : _temp, _ref5$maxNumResults = _ref5.maxNumResults, maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults, _ref5$maxHops = _ref5.maxHops, maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops;
-            if (currentPools === void 0) {
-              currentPools = [];
-            }
-            if (nextAmountIn === void 0) {
-              nextAmountIn = currencyAmountIn;
-            }
-            if (bestTrades === void 0) {
-              bestTrades = [];
-            }
-            !(pools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS') : invariant(false) : void 0;
-            !(maxHops > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;
-            !(currencyAmountIn === nextAmountIn || currentPools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;
-            amountIn = nextAmountIn.wrapped;
-            tokenOut = currencyOut.wrapped;
-            i = 0;
-          case 10:
-            if (!(i < pools.length)) {
-              _context5.next = 46;
-              break;
-            }
-            pool = pools[i]; // pool irrelevant
-            if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {
-              _context5.next = 14;
-              break;
-            }
-            return _context5.abrupt("continue", 43);
-          case 14:
-            amountOut = void 0;
-            _context5.prev = 15;
-            _context5.next = 19;
-            return pool.getOutputAmount(amountIn);
-          case 19:
-            _yield$pool$getOutput3 = _context5.sent;
-            amountOut = _yield$pool$getOutput3[0];
-            _context5.next = 28;
-            break;
-          case 23:
-            _context5.prev = 23;
-            _context5.t0 = _context5["catch"](15);
-            if (!_context5.t0.isInsufficientInputAmountError) {
-              _context5.next = 27;
-              break;
-            }
-            return _context5.abrupt("continue", 43);
-          case 27:
-            throw _context5.t0;
-          case 28:
-            if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {
-              _context5.next = 39;
-              break;
-            }
-            _context5.t1 = sortedInsert;
-            _context5.t2 = bestTrades;
-            _context5.next = 33;
-            return Trade.fromRoute(new Route([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT);
-          case 33:
-            _context5.t3 = _context5.sent;
-            _context5.t4 = maxNumResults;
-            _context5.t5 = tradeComparator;
-            (0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5);
-            _context5.next = 43;
-            break;
-          case 39:
-            if (!(maxHops > 1 && pools.length > 1)) {
-              _context5.next = 43;
-              break;
-            }
-            poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops
-            _context5.next = 43;
-            return Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {
-              maxNumResults: maxNumResults,
-              maxHops: maxHops - 1
-            }, [].concat(currentPools, [pool]), amountOut, bestTrades);
-          case 43:
-            i++;
-            _context5.next = 10;
-            break;
-          case 46:
-            return _context5.abrupt("return", bestTrades);
-          case 47:
-          case "end":
-            return _context5.stop();
-        }
-      }, _callee5, null, [[15, 23]]);
-    }));
-    function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
-      return _bestTradeExactIn.apply(this, arguments);
-    }
-    return bestTradeExactIn;
-  }()
+    /*#__PURE__*/
+    (function () {
+      var _bestTradeExactIn = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(
+          function _callee5(
+            pools,
+            currencyAmountIn,
+            currencyOut,
+            _temp,
+            // used in recursion.
+            currentPools,
+            nextAmountIn,
+            bestTrades,
+          ) {
+            var _ref5,
+              _ref5$maxNumResults,
+              maxNumResults,
+              _ref5$maxHops,
+              maxHops,
+              amountIn,
+              tokenOut,
+              i,
+              pool,
+              amountOut,
+              _yield$pool$getOutput3,
+              poolsExcludingThisPool
+            return _regeneratorRuntime().wrap(
+              function _callee5$(_context5) {
+                while (1)
+                  switch ((_context5.prev = _context5.next)) {
+                    case 0:
+                      ;(_ref5 = _temp === void 0 ? {} : _temp),
+                        (_ref5$maxNumResults = _ref5.maxNumResults),
+                        (maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults),
+                        (_ref5$maxHops = _ref5.maxHops),
+                        (maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops)
+                      if (currentPools === void 0) {
+                        currentPools = []
+                      }
+                      if (nextAmountIn === void 0) {
+                        nextAmountIn = currencyAmountIn
+                      }
+                      if (bestTrades === void 0) {
+                        bestTrades = []
+                      }
+                      !(pools.length > 0)
+                        ? process.env.NODE_ENV !== 'production'
+                          ? invariant(false, 'POOLS')
+                          : invariant(false)
+                        : void 0
+                      !(maxHops > 0)
+                        ? process.env.NODE_ENV !== 'production'
+                          ? invariant(false, 'MAX_HOPS')
+                          : invariant(false)
+                        : void 0
+                      !(currencyAmountIn === nextAmountIn || currentPools.length > 0)
+                        ? process.env.NODE_ENV !== 'production'
+                          ? invariant(false, 'INVALID_RECURSION')
+                          : invariant(false)
+                        : void 0
+                      amountIn = nextAmountIn.wrapped
+                      tokenOut = currencyOut.wrapped
+                      i = 0
+                    case 10:
+                      if (!(i < pools.length)) {
+                        _context5.next = 46
+                        break
+                      }
+                      pool = pools[i] // pool irrelevant
+                      if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {
+                        _context5.next = 14
+                        break
+                      }
+                      return _context5.abrupt('continue', 43)
+                    case 14:
+                      amountOut = void 0
+                      _context5.prev = 15
+                      _context5.next = 19
+                      return pool.getOutputAmount(amountIn)
+                    case 19:
+                      _yield$pool$getOutput3 = _context5.sent
+                      amountOut = _yield$pool$getOutput3[0]
+                      _context5.next = 28
+                      break
+                    case 23:
+                      _context5.prev = 23
+                      _context5.t0 = _context5['catch'](15)
+                      if (!_context5.t0.isInsufficientInputAmountError) {
+                        _context5.next = 27
+                        break
+                      }
+                      return _context5.abrupt('continue', 43)
+                    case 27:
+                      throw _context5.t0
+                    case 28:
+                      if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {
+                        _context5.next = 39
+                        break
+                      }
+                      _context5.t1 = sortedInsert
+                      _context5.t2 = bestTrades
+                      _context5.next = 33
+                      return Trade.fromRoute(
+                        new Route([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut),
+                        currencyAmountIn,
+                        TradeType.EXACT_INPUT,
+                      )
+                    case 33:
+                      _context5.t3 = _context5.sent
+                      _context5.t4 = maxNumResults
+                      _context5.t5 = tradeComparator
+                      ;(0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5)
+                      _context5.next = 43
+                      break
+                    case 39:
+                      if (!(maxHops > 1 && pools.length > 1)) {
+                        _context5.next = 43
+                        break
+                      }
+                      poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)) // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops
+                      _context5.next = 43
+                      return Trade.bestTradeExactIn(
+                        poolsExcludingThisPool,
+                        currencyAmountIn,
+                        currencyOut,
+                        {
+                          maxNumResults: maxNumResults,
+                          maxHops: maxHops - 1,
+                        },
+                        [].concat(currentPools, [pool]),
+                        amountOut,
+                        bestTrades,
+                      )
+                    case 43:
+                      i++
+                      _context5.next = 10
+                      break
+                    case 46:
+                      return _context5.abrupt('return', bestTrades)
+                    case 47:
+                    case 'end':
+                      return _context5.stop()
+                  }
+              },
+              _callee5,
+              null,
+              [[15, 23]],
+            )
+          },
+        ),
+      )
+      function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
+        return _bestTradeExactIn.apply(this, arguments)
+      }
+      return bestTradeExactIn
+    })()
   /**
    * similar to the above method but instead targets a fixed output amount
    * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
@@ -2447,477 +3296,666 @@ var Trade = /*#__PURE__*/function () {
    * @param bestTrades used in recursion; the current list of best trades
    * @returns The exact out trade
    */
-  ;
   Trade.bestTradeExactOut =
-  /*#__PURE__*/
-  function () {
-    var _bestTradeExactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pools, currencyIn, currencyAmountOut, _temp2,
-    // used in recursion.
-    currentPools, nextAmountOut, bestTrades) {
-      var _ref6, _ref6$maxNumResults, maxNumResults, _ref6$maxHops, maxHops, amountOut, tokenIn, i, pool, amountIn, _yield$pool$getInputA, poolsExcludingThisPool;
-      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
-        while (1) switch (_context6.prev = _context6.next) {
-          case 0:
-            _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$maxNumResults = _ref6.maxNumResults, maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults, _ref6$maxHops = _ref6.maxHops, maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops;
-            if (currentPools === void 0) {
-              currentPools = [];
-            }
-            if (nextAmountOut === void 0) {
-              nextAmountOut = currencyAmountOut;
-            }
-            if (bestTrades === void 0) {
-              bestTrades = [];
-            }
-            !(pools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS') : invariant(false) : void 0;
-            !(maxHops > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;
-            !(currencyAmountOut === nextAmountOut || currentPools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;
-            amountOut = nextAmountOut.wrapped;
-            tokenIn = currencyIn.wrapped;
-            i = 0;
-          case 10:
-            if (!(i < pools.length)) {
-              _context6.next = 46;
-              break;
-            }
-            pool = pools[i]; // pool irrelevant
-            if (!(!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))) {
-              _context6.next = 14;
-              break;
-            }
-            return _context6.abrupt("continue", 43);
-          case 14:
-            amountIn = void 0;
-            _context6.prev = 15;
-            _context6.next = 19;
-            return pool.getInputAmount(amountOut);
-          case 19:
-            _yield$pool$getInputA = _context6.sent;
-            amountIn = _yield$pool$getInputA[0];
-            _context6.next = 28;
-            break;
-          case 23:
-            _context6.prev = 23;
-            _context6.t0 = _context6["catch"](15);
-            if (!_context6.t0.isInsufficientReservesError) {
-              _context6.next = 27;
-              break;
-            }
-            return _context6.abrupt("continue", 43);
-          case 27:
-            throw _context6.t0;
-          case 28:
-            if (!amountIn.currency.equals(tokenIn)) {
-              _context6.next = 39;
-              break;
-            }
-            _context6.t1 = sortedInsert;
-            _context6.t2 = bestTrades;
-            _context6.next = 33;
-            return Trade.fromRoute(new Route([pool].concat(currentPools), currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT);
-          case 33:
-            _context6.t3 = _context6.sent;
-            _context6.t4 = maxNumResults;
-            _context6.t5 = tradeComparator;
-            (0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5);
-            _context6.next = 43;
-            break;
-          case 39:
-            if (!(maxHops > 1 && pools.length > 1)) {
-              _context6.next = 43;
-              break;
-            }
-            poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops
-            _context6.next = 43;
-            return Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {
-              maxNumResults: maxNumResults,
-              maxHops: maxHops - 1
-            }, [pool].concat(currentPools), amountIn, bestTrades);
-          case 43:
-            i++;
-            _context6.next = 10;
-            break;
-          case 46:
-            return _context6.abrupt("return", bestTrades);
-          case 47:
-          case "end":
-            return _context6.stop();
-        }
-      }, _callee6, null, [[15, 23]]);
-    }));
-    function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
-      return _bestTradeExactOut.apply(this, arguments);
-    }
-    return bestTradeExactOut;
-  }();
-  _createClass(Trade, [{
-    key: "route",
-    get: function get() {
-      !(this.swaps.length === 1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MULTIPLE_ROUTES') : invariant(false) : void 0;
-      return this.swaps[0].route;
-    }
-    /**
-     * The input amount for the trade assuming no slippage.
-     */
-  }, {
-    key: "inputAmount",
-    get: function get() {
-      if (this._inputAmount) {
-        return this._inputAmount;
-      }
-      var inputCurrency = this.swaps[0].inputAmount.currency;
-      var totalInputFromRoutes = this.swaps.map(function (_ref7) {
-        var inputAmount = _ref7.inputAmount;
-        return inputAmount;
-      }).reduce(function (total, cur) {
-        return total.add(cur);
-      }, CurrencyAmount.fromRawAmount(inputCurrency, 0));
-      this._inputAmount = totalInputFromRoutes;
-      return this._inputAmount;
-    }
-    /**
-     * The output amount for the trade assuming no slippage.
-     */
-  }, {
-    key: "outputAmount",
-    get: function get() {
-      if (this._outputAmount) {
-        return this._outputAmount;
-      }
-      var outputCurrency = this.swaps[0].outputAmount.currency;
-      var totalOutputFromRoutes = this.swaps.map(function (_ref8) {
-        var outputAmount = _ref8.outputAmount;
-        return outputAmount;
-      }).reduce(function (total, cur) {
-        return total.add(cur);
-      }, CurrencyAmount.fromRawAmount(outputCurrency, 0));
-      this._outputAmount = totalOutputFromRoutes;
-      return this._outputAmount;
-    }
-    /**
-     * The price expressed in terms of output amount/input amount.
-     */
-  }, {
-    key: "executionPrice",
-    get: function get() {
-      var _this$_executionPrice;
-      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
-    }
-    /**
-     * Returns the percent difference between the route's mid price and the price impact
-     */
-  }, {
-    key: "priceImpact",
-    get: function get() {
-      if (this._priceImpact) {
-        return this._priceImpact;
-      }
-      var spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);
-      for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done;) {
-        var _step4$value = _step4.value,
-          route = _step4$value.route,
-          inputAmount = _step4$value.inputAmount;
-        var midPrice = route.midPrice;
-        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));
+    /*#__PURE__*/
+    (function () {
+      var _bestTradeExactOut = /*#__PURE__*/ _asyncToGenerator(
+        /*#__PURE__*/ _regeneratorRuntime().mark(
+          function _callee6(
+            pools,
+            currencyIn,
+            currencyAmountOut,
+            _temp2,
+            // used in recursion.
+            currentPools,
+            nextAmountOut,
+            bestTrades,
+          ) {
+            var _ref6,
+              _ref6$maxNumResults,
+              maxNumResults,
+              _ref6$maxHops,
+              maxHops,
+              amountOut,
+              tokenIn,
+              i,
+              pool,
+              amountIn,
+              _yield$pool$getInputA,
+              poolsExcludingThisPool
+            return _regeneratorRuntime().wrap(
+              function _callee6$(_context6) {
+                while (1)
+                  switch ((_context6.prev = _context6.next)) {
+                    case 0:
+                      ;(_ref6 = _temp2 === void 0 ? {} : _temp2),
+                        (_ref6$maxNumResults = _ref6.maxNumResults),
+                        (maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults),
+                        (_ref6$maxHops = _ref6.maxHops),
+                        (maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops)
+                      if (currentPools === void 0) {
+                        currentPools = []
+                      }
+                      if (nextAmountOut === void 0) {
+                        nextAmountOut = currencyAmountOut
+                      }
+                      if (bestTrades === void 0) {
+                        bestTrades = []
+                      }
+                      !(pools.length > 0)
+                        ? process.env.NODE_ENV !== 'production'
+                          ? invariant(false, 'POOLS')
+                          : invariant(false)
+                        : void 0
+                      !(maxHops > 0)
+                        ? process.env.NODE_ENV !== 'production'
+                          ? invariant(false, 'MAX_HOPS')
+                          : invariant(false)
+                        : void 0
+                      !(currencyAmountOut === nextAmountOut || currentPools.length > 0)
+                        ? process.env.NODE_ENV !== 'production'
+                          ? invariant(false, 'INVALID_RECURSION')
+                          : invariant(false)
+                        : void 0
+                      amountOut = nextAmountOut.wrapped
+                      tokenIn = currencyIn.wrapped
+                      i = 0
+                    case 10:
+                      if (!(i < pools.length)) {
+                        _context6.next = 46
+                        break
+                      }
+                      pool = pools[i] // pool irrelevant
+                      if (!(!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))) {
+                        _context6.next = 14
+                        break
+                      }
+                      return _context6.abrupt('continue', 43)
+                    case 14:
+                      amountIn = void 0
+                      _context6.prev = 15
+                      _context6.next = 19
+                      return pool.getInputAmount(amountOut)
+                    case 19:
+                      _yield$pool$getInputA = _context6.sent
+                      amountIn = _yield$pool$getInputA[0]
+                      _context6.next = 28
+                      break
+                    case 23:
+                      _context6.prev = 23
+                      _context6.t0 = _context6['catch'](15)
+                      if (!_context6.t0.isInsufficientReservesError) {
+                        _context6.next = 27
+                        break
+                      }
+                      return _context6.abrupt('continue', 43)
+                    case 27:
+                      throw _context6.t0
+                    case 28:
+                      if (!amountIn.currency.equals(tokenIn)) {
+                        _context6.next = 39
+                        break
+                      }
+                      _context6.t1 = sortedInsert
+                      _context6.t2 = bestTrades
+                      _context6.next = 33
+                      return Trade.fromRoute(
+                        new Route([pool].concat(currentPools), currencyIn, currencyAmountOut.currency),
+                        currencyAmountOut,
+                        TradeType.EXACT_OUTPUT,
+                      )
+                    case 33:
+                      _context6.t3 = _context6.sent
+                      _context6.t4 = maxNumResults
+                      _context6.t5 = tradeComparator
+                      ;(0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5)
+                      _context6.next = 43
+                      break
+                    case 39:
+                      if (!(maxHops > 1 && pools.length > 1)) {
+                        _context6.next = 43
+                        break
+                      }
+                      poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)) // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops
+                      _context6.next = 43
+                      return Trade.bestTradeExactOut(
+                        poolsExcludingThisPool,
+                        currencyIn,
+                        currencyAmountOut,
+                        {
+                          maxNumResults: maxNumResults,
+                          maxHops: maxHops - 1,
+                        },
+                        [pool].concat(currentPools),
+                        amountIn,
+                        bestTrades,
+                      )
+                    case 43:
+                      i++
+                      _context6.next = 10
+                      break
+                    case 46:
+                      return _context6.abrupt('return', bestTrades)
+                    case 47:
+                    case 'end':
+                      return _context6.stop()
+                  }
+              },
+              _callee6,
+              null,
+              [[15, 23]],
+            )
+          },
+        ),
+      )
+      function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
+        return _bestTradeExactOut.apply(this, arguments)
       }
-      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);
-      this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator);
-      return this._priceImpact;
-    }
-  }]);
-  return Trade;
-}();
+      return bestTradeExactOut
+    })()
+  _createClass(Trade, [
+    {
+      key: 'route',
+      get: function get() {
+        !(this.swaps.length === 1)
+          ? process.env.NODE_ENV !== 'production'
+            ? invariant(false, 'MULTIPLE_ROUTES')
+            : invariant(false)
+          : void 0
+        return this.swaps[0].route
+      },
+      /**
+       * The input amount for the trade assuming no slippage.
+       */
+    },
+    {
+      key: 'inputAmount',
+      get: function get() {
+        if (this._inputAmount) {
+          return this._inputAmount
+        }
+        var inputCurrency = this.swaps[0].inputAmount.currency
+        var totalInputFromRoutes = this.swaps
+          .map(function (_ref7) {
+            var inputAmount = _ref7.inputAmount
+            return inputAmount
+          })
+          .reduce(
+            function (total, cur) {
+              return total.add(cur)
+            },
+            CurrencyAmount.fromRawAmount(inputCurrency, 0),
+          )
+        this._inputAmount = totalInputFromRoutes
+        return this._inputAmount
+      },
+      /**
+       * The output amount for the trade assuming no slippage.
+       */
+    },
+    {
+      key: 'outputAmount',
+      get: function get() {
+        if (this._outputAmount) {
+          return this._outputAmount
+        }
+        var outputCurrency = this.swaps[0].outputAmount.currency
+        var totalOutputFromRoutes = this.swaps
+          .map(function (_ref8) {
+            var outputAmount = _ref8.outputAmount
+            return outputAmount
+          })
+          .reduce(
+            function (total, cur) {
+              return total.add(cur)
+            },
+            CurrencyAmount.fromRawAmount(outputCurrency, 0),
+          )
+        this._outputAmount = totalOutputFromRoutes
+        return this._outputAmount
+      },
+      /**
+       * The price expressed in terms of output amount/input amount.
+       */
+    },
+    {
+      key: 'executionPrice',
+      get: function get() {
+        var _this$_executionPrice
+        return (_this$_executionPrice = this._executionPrice) != null
+          ? _this$_executionPrice
+          : (this._executionPrice = new Price(
+              this.inputAmount.currency,
+              this.outputAmount.currency,
+              this.inputAmount.quotient,
+              this.outputAmount.quotient,
+            ))
+      },
+      /**
+       * Returns the percent difference between the route's mid price and the price impact
+       */
+    },
+    {
+      key: 'priceImpact',
+      get: function get() {
+        if (this._priceImpact) {
+          return this._priceImpact
+        }
+        var spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)
+        for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done; ) {
+          var _step4$value = _step4.value,
+            route = _step4$value.route,
+            inputAmount = _step4$value.inputAmount
+          var midPrice = route.midPrice
+          spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))
+        }
+        var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)
+        this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)
+        return this._priceImpact
+      },
+    },
+  ])
+  return Trade
+})()
 
-var Multicall = /*#__PURE__*/function () {
+var Multicall = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function Multicall() {}
   Multicall.encodeMulticall = function encodeMulticall(calldatas) {
     if (!Array.isArray(calldatas)) {
-      calldatas = [calldatas];
+      calldatas = [calldatas]
     }
-    return calldatas.length === 1 ? calldatas[0] : Multicall.INTERFACE.encodeFunctionData('multicall', [calldatas]);
-  };
+    return calldatas.length === 1 ? calldatas[0] : Multicall.INTERFACE.encodeFunctionData('multicall', [calldatas])
+  }
   Multicall.decodeMulticall = function decodeMulticall(multicall) {
-    return Multicall.INTERFACE.decodeFunctionData('multicall', multicall).data;
-  };
-  return Multicall;
-}();
-Multicall.INTERFACE = /*#__PURE__*/new Interface(IMulticall.abi);
+    return Multicall.INTERFACE.decodeFunctionData('multicall', multicall).data
+  }
+  return Multicall
+})()
+Multicall.INTERFACE = /*#__PURE__*/ new Interface(IMulticall.abi)
 
 function isAllowedPermit(permitOptions) {
-  return 'nonce' in permitOptions;
+  return 'nonce' in permitOptions
 }
-var SelfPermit = /*#__PURE__*/function () {
+var SelfPermit = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function SelfPermit() {}
   SelfPermit.encodePermit = function encodePermit(token, options) {
-    return isAllowedPermit(options) ? SelfPermit.INTERFACE.encodeFunctionData('selfPermitAllowed', [token.address, toHex(options.nonce), toHex(options.expiry), options.v, options.r, options.s]) : SelfPermit.INTERFACE.encodeFunctionData('selfPermit', [token.address, toHex(options.amount), toHex(options.deadline), options.v, options.r, options.s]);
-  };
-  return SelfPermit;
-}();
-SelfPermit.INTERFACE = /*#__PURE__*/new Interface(ISelfPermit.abi);
+    return isAllowedPermit(options)
+      ? SelfPermit.INTERFACE.encodeFunctionData('selfPermitAllowed', [
+          token.address,
+          toHex(options.nonce),
+          toHex(options.expiry),
+          options.v,
+          options.r,
+          options.s,
+        ])
+      : SelfPermit.INTERFACE.encodeFunctionData('selfPermit', [
+          token.address,
+          toHex(options.amount),
+          toHex(options.deadline),
+          options.v,
+          options.r,
+          options.s,
+        ])
+  }
+  return SelfPermit
+})()
+SelfPermit.INTERFACE = /*#__PURE__*/ new Interface(ISelfPermit.abi)
 
-var Payments = /*#__PURE__*/function () {
+var Payments = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function Payments() {}
   Payments.encodeFeeBips = function encodeFeeBips(fee) {
-    return toHex(fee.multiply(10000).quotient);
-  };
+    return toHex(fee.multiply(10000).quotient)
+  }
   Payments.encodeUnwrapWETH9 = function encodeUnwrapWETH9(amountMinimum, recipient, feeOptions) {
-    recipient = validateAndParseAddress(recipient);
+    recipient = validateAndParseAddress(recipient)
     if (!!feeOptions) {
-      var feeBips = this.encodeFeeBips(feeOptions.fee);
-      var feeRecipient = validateAndParseAddress(feeOptions.recipient);
-      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9WithFee', [toHex(amountMinimum), recipient, feeBips, feeRecipient]);
+      var feeBips = this.encodeFeeBips(feeOptions.fee)
+      var feeRecipient = validateAndParseAddress(feeOptions.recipient)
+      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9WithFee', [
+        toHex(amountMinimum),
+        recipient,
+        feeBips,
+        feeRecipient,
+      ])
     } else {
-      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9', [toHex(amountMinimum), recipient]);
+      return Payments.INTERFACE.encodeFunctionData('unwrapWETH9', [toHex(amountMinimum), recipient])
     }
-  };
+  }
   Payments.encodeSweepToken = function encodeSweepToken(token, amountMinimum, recipient, feeOptions) {
-    recipient = validateAndParseAddress(recipient);
+    recipient = validateAndParseAddress(recipient)
     if (!!feeOptions) {
-      var feeBips = this.encodeFeeBips(feeOptions.fee);
-      var feeRecipient = validateAndParseAddress(feeOptions.recipient);
-      return Payments.INTERFACE.encodeFunctionData('sweepTokenWithFee', [token.address, toHex(amountMinimum), recipient, feeBips, feeRecipient]);
+      var feeBips = this.encodeFeeBips(feeOptions.fee)
+      var feeRecipient = validateAndParseAddress(feeOptions.recipient)
+      return Payments.INTERFACE.encodeFunctionData('sweepTokenWithFee', [
+        token.address,
+        toHex(amountMinimum),
+        recipient,
+        feeBips,
+        feeRecipient,
+      ])
     } else {
-      return Payments.INTERFACE.encodeFunctionData('sweepToken', [token.address, toHex(amountMinimum), recipient]);
+      return Payments.INTERFACE.encodeFunctionData('sweepToken', [token.address, toHex(amountMinimum), recipient])
     }
-  };
+  }
   Payments.encodeRefundETH = function encodeRefundETH() {
-    return Payments.INTERFACE.encodeFunctionData('refundETH');
-  };
-  return Payments;
-}();
-Payments.INTERFACE = /*#__PURE__*/new Interface(IPeripheryPaymentsWithFee.abi);
+    return Payments.INTERFACE.encodeFunctionData('refundETH')
+  }
+  return Payments
+})()
+Payments.INTERFACE = /*#__PURE__*/ new Interface(IPeripheryPaymentsWithFee.abi)
 
-var _excluded = ["expectedCurrencyOwed0", "expectedCurrencyOwed1"];
-var MaxUint128 = /*#__PURE__*/toHex( /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128)), /*#__PURE__*/JSBI.BigInt(1)));
+var _excluded = ['expectedCurrencyOwed0', 'expectedCurrencyOwed1']
+var MaxUint128 = /*#__PURE__*/ toHex(
+  /*#__PURE__*/ JSBI.subtract(
+    /*#__PURE__*/ JSBI.exponentiate(/*#__PURE__*/ JSBI.BigInt(2), /*#__PURE__*/ JSBI.BigInt(128)),
+    /*#__PURE__*/ JSBI.BigInt(1),
+  ),
+)
 // type guard
 function isMint(options) {
   return Object.keys(options).some(function (k) {
-    return k === 'recipient';
-  });
+    return k === 'recipient'
+  })
 }
 var NFT_PERMIT_TYPES = {
-  Permit: [{
-    name: 'spender',
-    type: 'address'
-  }, {
-    name: 'tokenId',
-    type: 'uint256'
-  }, {
-    name: 'nonce',
-    type: 'uint256'
-  }, {
-    name: 'deadline',
-    type: 'uint256'
-  }]
-};
-var NonfungiblePositionManager = /*#__PURE__*/function () {
+  Permit: [
+    {
+      name: 'spender',
+      type: 'address',
+    },
+    {
+      name: 'tokenId',
+      type: 'uint256',
+    },
+    {
+      name: 'nonce',
+      type: 'uint256',
+    },
+    {
+      name: 'deadline',
+      type: 'uint256',
+    },
+  ],
+}
+var NonfungiblePositionManager = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
   function NonfungiblePositionManager() {}
   NonfungiblePositionManager.encodeCreate = function encodeCreate(pool) {
-    return NonfungiblePositionManager.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [pool.token0.address, pool.token1.address, pool.fee, toHex(pool.sqrtRatioX96)]);
-  };
+    return NonfungiblePositionManager.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [
+      pool.token0.address,
+      pool.token1.address,
+      pool.fee,
+      toHex(pool.sqrtRatioX96),
+    ])
+  }
   NonfungiblePositionManager.createCallParameters = function createCallParameters(pool) {
     return {
       calldata: this.encodeCreate(pool),
-      value: toHex(0)
-    };
-  };
+      value: toHex(0),
+    }
+  }
   NonfungiblePositionManager.addCallParameters = function addCallParameters(position, options) {
-    !JSBI.greaterThan(position.liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO_LIQUIDITY') : invariant(false) : void 0;
-    var calldatas = [];
+    !JSBI.greaterThan(position.liquidity, ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'ZERO_LIQUIDITY')
+        : invariant(false)
+      : void 0
+    var calldatas = []
     // get amounts
     var _position$mintAmounts = position.mintAmounts,
       amount0Desired = _position$mintAmounts.amount0,
-      amount1Desired = _position$mintAmounts.amount1;
+      amount1Desired = _position$mintAmounts.amount1
     // adjust for slippage
-    var minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance);
-    var amount0Min = toHex(minimumAmounts.amount0);
-    var amount1Min = toHex(minimumAmounts.amount1);
-    var deadline = toHex(options.deadline);
+    var minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance)
+    var amount0Min = toHex(minimumAmounts.amount0)
+    var amount1Min = toHex(minimumAmounts.amount1)
+    var deadline = toHex(options.deadline)
     // create pool if needed
     if (isMint(options) && options.createPool) {
-      calldatas.push(this.encodeCreate(position.pool));
+      calldatas.push(this.encodeCreate(position.pool))
     }
     // permits if necessary
     if (options.token0Permit) {
-      calldatas.push(SelfPermit.encodePermit(position.pool.token0, options.token0Permit));
+      calldatas.push(SelfPermit.encodePermit(position.pool.token0, options.token0Permit))
     }
     if (options.token1Permit) {
-      calldatas.push(SelfPermit.encodePermit(position.pool.token1, options.token1Permit));
+      calldatas.push(SelfPermit.encodePermit(position.pool.token1, options.token1Permit))
     }
     // mint
     if (isMint(options)) {
-      var recipient = validateAndParseAddress(options.recipient);
-      calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('mint', [{
-        token0: position.pool.token0.address,
-        token1: position.pool.token1.address,
-        fee: position.pool.fee,
-        tickLower: position.tickLower,
-        tickUpper: position.tickUpper,
-        amount0Desired: toHex(amount0Desired),
-        amount1Desired: toHex(amount1Desired),
-        amount0Min: amount0Min,
-        amount1Min: amount1Min,
-        recipient: recipient,
-        deadline: deadline
-      }]));
+      var recipient = validateAndParseAddress(options.recipient)
+      calldatas.push(
+        NonfungiblePositionManager.INTERFACE.encodeFunctionData('mint', [
+          {
+            token0: position.pool.token0.address,
+            token1: position.pool.token1.address,
+            fee: position.pool.fee,
+            tickLower: position.tickLower,
+            tickUpper: position.tickUpper,
+            amount0Desired: toHex(amount0Desired),
+            amount1Desired: toHex(amount1Desired),
+            amount0Min: amount0Min,
+            amount1Min: amount1Min,
+            recipient: recipient,
+            deadline: deadline,
+          },
+        ]),
+      )
     } else {
       // increase
-      calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('increaseLiquidity', [{
-        tokenId: toHex(options.tokenId),
-        amount0Desired: toHex(amount0Desired),
-        amount1Desired: toHex(amount1Desired),
-        amount0Min: amount0Min,
-        amount1Min: amount1Min,
-        deadline: deadline
-      }]));
-    }
-    var value = toHex(0);
+      calldatas.push(
+        NonfungiblePositionManager.INTERFACE.encodeFunctionData('increaseLiquidity', [
+          {
+            tokenId: toHex(options.tokenId),
+            amount0Desired: toHex(amount0Desired),
+            amount1Desired: toHex(amount1Desired),
+            amount0Min: amount0Min,
+            amount1Min: amount1Min,
+            deadline: deadline,
+          },
+        ]),
+      )
+    }
+    var value = toHex(0)
     if (options.useNative) {
-      var wrapped = options.useNative.wrapped;
-      !(position.pool.token0.equals(wrapped) || position.pool.token1.equals(wrapped)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'NO_WETH') : invariant(false) : void 0;
-      var wrappedValue = position.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired;
+      var wrapped = options.useNative.wrapped
+      !(position.pool.token0.equals(wrapped) || position.pool.token1.equals(wrapped))
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'NO_WETH')
+          : invariant(false)
+        : void 0
+      var wrappedValue = position.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired
       // we only need to refund if we're actually sending ETH
       if (JSBI.greaterThan(wrappedValue, ZERO)) {
-        calldatas.push(Payments.encodeRefundETH());
+        calldatas.push(Payments.encodeRefundETH())
       }
-      value = toHex(wrappedValue);
+      value = toHex(wrappedValue)
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: value
-    };
-  };
+      value: value,
+    }
+  }
   NonfungiblePositionManager.encodeCollect = function encodeCollect(options) {
-    var calldatas = [];
-    var tokenId = toHex(options.tokenId);
-    var involvesETH = options.expectedCurrencyOwed0.currency.isNative || options.expectedCurrencyOwed1.currency.isNative;
-    var recipient = validateAndParseAddress(options.recipient);
+    var calldatas = []
+    var tokenId = toHex(options.tokenId)
+    var involvesETH = options.expectedCurrencyOwed0.currency.isNative || options.expectedCurrencyOwed1.currency.isNative
+    var recipient = validateAndParseAddress(options.recipient)
     // collect
-    calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('collect', [{
-      tokenId: tokenId,
-      recipient: involvesETH ? ADDRESS_ZERO : recipient,
-      amount0Max: MaxUint128,
-      amount1Max: MaxUint128
-    }]));
+    calldatas.push(
+      NonfungiblePositionManager.INTERFACE.encodeFunctionData('collect', [
+        {
+          tokenId: tokenId,
+          recipient: involvesETH ? ADDRESS_ZERO : recipient,
+          amount0Max: MaxUint128,
+          amount1Max: MaxUint128,
+        },
+      ]),
+    )
     if (involvesETH) {
-      var ethAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed0.quotient : options.expectedCurrencyOwed1.quotient;
-      var token = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.currency : options.expectedCurrencyOwed0.currency;
-      var tokenAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.quotient : options.expectedCurrencyOwed0.quotient;
-      calldatas.push(Payments.encodeUnwrapWETH9(ethAmount, recipient));
-      calldatas.push(Payments.encodeSweepToken(token, tokenAmount, recipient));
-    }
-    return calldatas;
-  };
+      var ethAmount = options.expectedCurrencyOwed0.currency.isNative
+        ? options.expectedCurrencyOwed0.quotient
+        : options.expectedCurrencyOwed1.quotient
+      var token = options.expectedCurrencyOwed0.currency.isNative
+        ? options.expectedCurrencyOwed1.currency
+        : options.expectedCurrencyOwed0.currency
+      var tokenAmount = options.expectedCurrencyOwed0.currency.isNative
+        ? options.expectedCurrencyOwed1.quotient
+        : options.expectedCurrencyOwed0.quotient
+      calldatas.push(Payments.encodeUnwrapWETH9(ethAmount, recipient))
+      calldatas.push(Payments.encodeSweepToken(token, tokenAmount, recipient))
+    }
+    return calldatas
+  }
   NonfungiblePositionManager.collectCallParameters = function collectCallParameters(options) {
-    var calldatas = NonfungiblePositionManager.encodeCollect(options);
+    var calldatas = NonfungiblePositionManager.encodeCollect(options)
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   /**
    * Produces the calldata for completely or partially exiting a position
    * @param position The position to exit
    * @param options Additional information necessary for generating the calldata
    * @returns The call parameters
-   */;
+   */
   NonfungiblePositionManager.removeCallParameters = function removeCallParameters(position, options) {
-    var calldatas = [];
-    var deadline = toHex(options.deadline);
-    var tokenId = toHex(options.tokenId);
+    var calldatas = []
+    var deadline = toHex(options.deadline)
+    var tokenId = toHex(options.tokenId)
     // construct a partial position with a percentage of liquidity
     var partialPosition = new Position({
       pool: position.pool,
       liquidity: options.liquidityPercentage.multiply(position.liquidity).quotient,
       tickLower: position.tickLower,
-      tickUpper: position.tickUpper
-    });
-    !JSBI.greaterThan(partialPosition.liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO_LIQUIDITY') : invariant(false) : void 0;
+      tickUpper: position.tickUpper,
+    })
+    !JSBI.greaterThan(partialPosition.liquidity, ZERO)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'ZERO_LIQUIDITY')
+        : invariant(false)
+      : void 0
     // slippage-adjusted underlying amounts
     var _partialPosition$burn = partialPosition.burnAmountsWithSlippage(options.slippageTolerance),
       amount0Min = _partialPosition$burn.amount0,
-      amount1Min = _partialPosition$burn.amount1;
+      amount1Min = _partialPosition$burn.amount1
     if (options.permit) {
-      calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('permit', [validateAndParseAddress(options.permit.spender), tokenId, toHex(options.permit.deadline), options.permit.v, options.permit.r, options.permit.s]));
+      calldatas.push(
+        NonfungiblePositionManager.INTERFACE.encodeFunctionData('permit', [
+          validateAndParseAddress(options.permit.spender),
+          tokenId,
+          toHex(options.permit.deadline),
+          options.permit.v,
+          options.permit.r,
+          options.permit.s,
+        ]),
+      )
     }
     // remove liquidity
-    calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('decreaseLiquidity', [{
-      tokenId: tokenId,
-      liquidity: toHex(partialPosition.liquidity),
-      amount0Min: toHex(amount0Min),
-      amount1Min: toHex(amount1Min),
-      deadline: deadline
-    }]));
+    calldatas.push(
+      NonfungiblePositionManager.INTERFACE.encodeFunctionData('decreaseLiquidity', [
+        {
+          tokenId: tokenId,
+          liquidity: toHex(partialPosition.liquidity),
+          amount0Min: toHex(amount0Min),
+          amount1Min: toHex(amount1Min),
+          deadline: deadline,
+        },
+      ]),
+    )
     var _options$collectOptio = options.collectOptions,
       expectedCurrencyOwed0 = _options$collectOptio.expectedCurrencyOwed0,
       expectedCurrencyOwed1 = _options$collectOptio.expectedCurrencyOwed1,
-      rest = _objectWithoutPropertiesLoose(_options$collectOptio, _excluded);
-    calldatas.push.apply(calldatas, NonfungiblePositionManager.encodeCollect(_extends({
-      tokenId: toHex(options.tokenId),
-      // add the underlying value to the expected currency already owed
-      expectedCurrencyOwed0: expectedCurrencyOwed0.add(CurrencyAmount.fromRawAmount(expectedCurrencyOwed0.currency, amount0Min)),
-      expectedCurrencyOwed1: expectedCurrencyOwed1.add(CurrencyAmount.fromRawAmount(expectedCurrencyOwed1.currency, amount1Min))
-    }, rest)));
+      rest = _objectWithoutPropertiesLoose(_options$collectOptio, _excluded)
+    calldatas.push.apply(
+      calldatas,
+      NonfungiblePositionManager.encodeCollect(
+        _extends(
+          {
+            tokenId: toHex(options.tokenId),
+            // add the underlying value to the expected currency already owed
+            expectedCurrencyOwed0: expectedCurrencyOwed0.add(
+              CurrencyAmount.fromRawAmount(expectedCurrencyOwed0.currency, amount0Min),
+            ),
+            expectedCurrencyOwed1: expectedCurrencyOwed1.add(
+              CurrencyAmount.fromRawAmount(expectedCurrencyOwed1.currency, amount1Min),
+            ),
+          },
+          rest,
+        ),
+      ),
+    )
     if (options.liquidityPercentage.equalTo(ONE)) {
       if (options.burnToken) {
-        calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('burn', [tokenId]));
+        calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('burn', [tokenId]))
       }
     } else {
-      !(options.burnToken !== true) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CANNOT_BURN') : invariant(false) : void 0;
+      !(options.burnToken !== true)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'CANNOT_BURN')
+          : invariant(false)
+        : void 0
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
-  };
+      value: toHex(0),
+    }
+  }
   NonfungiblePositionManager.safeTransferFromParameters = function safeTransferFromParameters(options) {
-    var recipient = validateAndParseAddress(options.recipient);
-    var sender = validateAndParseAddress(options.sender);
-    var calldata;
+    var recipient = validateAndParseAddress(options.recipient)
+    var sender = validateAndParseAddress(options.sender)
+    var calldata
     if (options.data) {
-      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256,bytes)', [sender, recipient, toHex(options.tokenId), options.data]);
+      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData(
+        'safeTransferFrom(address,address,uint256,bytes)',
+        [sender, recipient, toHex(options.tokenId), options.data],
+      )
     } else {
-      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256)', [sender, recipient, toHex(options.tokenId)]);
+      calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256)', [
+        sender,
+        recipient,
+        toHex(options.tokenId),
+      ])
     }
     return {
       calldata: calldata,
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   // Prepare the params for an EIP712 signTypedData request
-  ;
   NonfungiblePositionManager.getPermitData = function getPermitData(permit, positionManagerAddress, chainId) {
     return {
       domain: {
         name: 'Uniswap V3 Positions NFT-V1',
         chainId: chainId,
         version: '1',
-        verifyingContract: positionManagerAddress
+        verifyingContract: positionManagerAddress,
       },
       types: NFT_PERMIT_TYPES,
-      values: permit
-    };
-  };
-  return NonfungiblePositionManager;
-}();
-NonfungiblePositionManager.INTERFACE = /*#__PURE__*/new Interface(INonfungiblePositionManager.abi);
+      values: permit,
+    }
+  }
+  return NonfungiblePositionManager
+})()
+NonfungiblePositionManager.INTERFACE = /*#__PURE__*/ new Interface(INonfungiblePositionManager.abi)
 
 /**
  * Represents the Uniswap V3 QuoterV1 contract with a method for returning the formatted
  * calldata needed to call the quoter contract.
  */
-var SwapQuoter = /*#__PURE__*/function () {
+var SwapQuoter = /*#__PURE__*/ (function () {
   function SwapQuoter() {}
   /**
    * Produces the on-chain method name of the appropriate function within QuoterV2,
@@ -2932,46 +3970,70 @@ var SwapQuoter = /*#__PURE__*/function () {
    */
   SwapQuoter.quoteCallParameters = function quoteCallParameters(route, amount, tradeType, options) {
     if (options === void 0) {
-      options = {};
+      options = {}
     }
-    var singleHop = route.pools.length === 1;
-    var quoteAmount = toHex(amount.quotient);
-    var calldata;
-    var swapInterface = options.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE;
+    var singleHop = route.pools.length === 1
+    var quoteAmount = toHex(amount.quotient)
+    var calldata
+    var swapInterface = options.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE
     if (singleHop) {
-      var _options$sqrtPriceLim, _options;
+      var _options$sqrtPriceLim, _options
       var baseQuoteParams = {
         tokenIn: route.tokenPath[0].address,
         tokenOut: route.tokenPath[1].address,
         fee: route.pools[0].fee,
-        sqrtPriceLimitX96: toHex((_options$sqrtPriceLim = (_options = options) == null ? void 0 : _options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
-      };
-      var v2QuoteParams = _extends({}, baseQuoteParams, tradeType === TradeType.EXACT_INPUT ? {
-        amountIn: quoteAmount
-      } : {
-        amount: quoteAmount
-      });
-      var v1QuoteParams = [baseQuoteParams.tokenIn, baseQuoteParams.tokenOut, baseQuoteParams.fee, quoteAmount, baseQuoteParams.sqrtPriceLimitX96];
-      var tradeTypeFunctionName = tradeType === TradeType.EXACT_INPUT ? 'quoteExactInputSingle' : 'quoteExactOutputSingle';
-      calldata = swapInterface.encodeFunctionData(tradeTypeFunctionName, options.useQuoterV2 ? [v2QuoteParams] : v1QuoteParams);
+        sqrtPriceLimitX96: toHex(
+          (_options$sqrtPriceLim = (_options = options) == null ? void 0 : _options.sqrtPriceLimitX96) != null
+            ? _options$sqrtPriceLim
+            : 0,
+        ),
+      }
+      var v2QuoteParams = _extends(
+        {},
+        baseQuoteParams,
+        tradeType === TradeType.EXACT_INPUT
+          ? {
+              amountIn: quoteAmount,
+            }
+          : {
+              amount: quoteAmount,
+            },
+      )
+      var v1QuoteParams = [
+        baseQuoteParams.tokenIn,
+        baseQuoteParams.tokenOut,
+        baseQuoteParams.fee,
+        quoteAmount,
+        baseQuoteParams.sqrtPriceLimitX96,
+      ]
+      var tradeTypeFunctionName =
+        tradeType === TradeType.EXACT_INPUT ? 'quoteExactInputSingle' : 'quoteExactOutputSingle'
+      calldata = swapInterface.encodeFunctionData(
+        tradeTypeFunctionName,
+        options.useQuoterV2 ? [v2QuoteParams] : v1QuoteParams,
+      )
     } else {
-      var _options2;
-      !(((_options2 = options) == null ? void 0 : _options2.sqrtPriceLimitX96) === undefined) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MULTIHOP_PRICE_LIMIT') : invariant(false) : void 0;
-      var path = encodeRouteToPath(route, tradeType === TradeType.EXACT_OUTPUT);
-      var _tradeTypeFunctionName = tradeType === TradeType.EXACT_INPUT ? 'quoteExactInput' : 'quoteExactOutput';
-      calldata = swapInterface.encodeFunctionData(_tradeTypeFunctionName, [path, quoteAmount]);
+      var _options2
+      !(((_options2 = options) == null ? void 0 : _options2.sqrtPriceLimitX96) === undefined)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'MULTIHOP_PRICE_LIMIT')
+          : invariant(false)
+        : void 0
+      var path = encodeRouteToPath(route, tradeType === TradeType.EXACT_OUTPUT)
+      var _tradeTypeFunctionName = tradeType === TradeType.EXACT_INPUT ? 'quoteExactInput' : 'quoteExactOutput'
+      calldata = swapInterface.encodeFunctionData(_tradeTypeFunctionName, [path, quoteAmount])
     }
     return {
       calldata: calldata,
-      value: toHex(0)
-    };
-  };
-  return SwapQuoter;
-}();
-SwapQuoter.V1INTERFACE = /*#__PURE__*/new Interface(IQuoter.abi);
-SwapQuoter.V2INTERFACE = /*#__PURE__*/new Interface(IQuoterV2.abi);
+      value: toHex(0),
+    }
+  }
+  return SwapQuoter
+})()
+SwapQuoter.V1INTERFACE = /*#__PURE__*/ new Interface(IQuoter.abi)
+SwapQuoter.V2INTERFACE = /*#__PURE__*/ new Interface(IQuoterV2.abi)
 
-var Staker = /*#__PURE__*/function () {
+var Staker = /*#__PURE__*/ (function () {
   function Staker() {}
   /**
    *  To claim rewards, must unstake and then claim.
@@ -2980,13 +4042,20 @@ var Staker = /*#__PURE__*/function () {
    * @returns The calldatas for 'unstakeToken' and 'claimReward'.
    */
   Staker.encodeClaim = function encodeClaim(incentiveKey, options) {
-    var _options$amount;
-    var calldatas = [];
-    calldatas.push(Staker.INTERFACE.encodeFunctionData('unstakeToken', [this._encodeIncentiveKey(incentiveKey), toHex(options.tokenId)]));
-    var recipient = validateAndParseAddress(options.recipient);
-    var amount = (_options$amount = options.amount) != null ? _options$amount : 0;
-    calldatas.push(Staker.INTERFACE.encodeFunctionData('claimReward', [incentiveKey.rewardToken.address, recipient, toHex(amount)]));
-    return calldatas;
+    var _options$amount
+    var calldatas = []
+    calldatas.push(
+      Staker.INTERFACE.encodeFunctionData('unstakeToken', [
+        this._encodeIncentiveKey(incentiveKey),
+        toHex(options.tokenId),
+      ]),
+    )
+    var recipient = validateAndParseAddress(options.recipient)
+    var amount = (_options$amount = options.amount) != null ? _options$amount : 0
+    calldatas.push(
+      Staker.INTERFACE.encodeFunctionData('claimReward', [incentiveKey.rewardToken.address, recipient, toHex(amount)]),
+    )
+    return calldatas
   }
   /**
    *
@@ -2996,96 +4065,108 @@ var Staker = /*#__PURE__*/function () {
    * @param options ClaimOptions to specify tokenId, recipient, and amount wanting to collect.
    * Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once.
    * @returns
-   */;
+   */
   Staker.collectRewards = function collectRewards(incentiveKeys, options) {
-    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
-    var calldatas = [];
+    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys]
+    var calldatas = []
     for (var i = 0; i < incentiveKeys.length; i++) {
       // the unique program tokenId is staked in
-      var incentiveKey = incentiveKeys[i];
+      var incentiveKey = incentiveKeys[i]
       // unstakes and claims for the unique program
-      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options));
+      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options))
       // re-stakes the position for the unique program
-      calldatas.push(Staker.INTERFACE.encodeFunctionData('stakeToken', [this._encodeIncentiveKey(incentiveKey), toHex(options.tokenId)]));
+      calldatas.push(
+        Staker.INTERFACE.encodeFunctionData('stakeToken', [
+          this._encodeIncentiveKey(incentiveKey),
+          toHex(options.tokenId),
+        ]),
+      )
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   /**
    *
    * @param incentiveKeys A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in.
    * @param withdrawOptions Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`.
    * @returns Calldata for unstaking, claiming, and withdrawing.
-   */;
+   */
   Staker.withdrawToken = function withdrawToken(incentiveKeys, withdrawOptions) {
-    var calldatas = [];
-    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
+    var calldatas = []
+    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys]
     var claimOptions = {
       tokenId: withdrawOptions.tokenId,
       recipient: withdrawOptions.recipient,
-      amount: withdrawOptions.amount
-    };
+      amount: withdrawOptions.amount,
+    }
     for (var i = 0; i < incentiveKeys.length; i++) {
-      var incentiveKey = incentiveKeys[i];
-      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, claimOptions));
+      var incentiveKey = incentiveKeys[i]
+      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, claimOptions))
     }
-    var owner = validateAndParseAddress(withdrawOptions.owner);
-    calldatas.push(Staker.INTERFACE.encodeFunctionData('withdrawToken', [toHex(withdrawOptions.tokenId), owner, withdrawOptions.data ? withdrawOptions.data : toHex(0)]));
+    var owner = validateAndParseAddress(withdrawOptions.owner)
+    calldatas.push(
+      Staker.INTERFACE.encodeFunctionData('withdrawToken', [
+        toHex(withdrawOptions.tokenId),
+        owner,
+        withdrawOptions.data ? withdrawOptions.data : toHex(0),
+      ]),
+    )
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(0)
-    };
+      value: toHex(0),
+    }
   }
   /**
    *
    * @param incentiveKeys A single IncentiveKey or array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom`
    * @returns An IncentiveKey as a string
-   */;
+   */
   Staker.encodeDeposit = function encodeDeposit(incentiveKeys) {
-    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
-    var data;
+    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys]
+    var data
     if (incentiveKeys.length > 1) {
-      var keys = [];
+      var keys = []
       for (var i = 0; i < incentiveKeys.length; i++) {
-        var incentiveKey = incentiveKeys[i];
-        keys.push(this._encodeIncentiveKey(incentiveKey));
+        var incentiveKey = incentiveKeys[i]
+        keys.push(this._encodeIncentiveKey(incentiveKey))
       }
-      data = defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI + "[]"], [keys]);
+      data = defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI + '[]'], [keys])
     } else {
-      data = defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(incentiveKeys[0])]);
+      data = defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(incentiveKeys[0])])
     }
-    return data;
+    return data
   }
   /**
    *
    * @param incentiveKey An `IncentiveKey` which represents a unique staking program.
    * @returns An encoded IncentiveKey to be read by ethers
-   */;
+   */
   Staker._encodeIncentiveKey = function _encodeIncentiveKey(incentiveKey) {
     var _incentiveKey$pool = incentiveKey.pool,
       token0 = _incentiveKey$pool.token0,
       token1 = _incentiveKey$pool.token1,
-      fee = _incentiveKey$pool.fee;
-    var refundee = validateAndParseAddress(incentiveKey.refundee);
+      fee = _incentiveKey$pool.fee
+    var refundee = validateAndParseAddress(incentiveKey.refundee)
     return {
       rewardToken: incentiveKey.rewardToken.address,
       pool: Pool.getAddress(token0, token1, fee),
       startTime: toHex(incentiveKey.startTime),
       endTime: toHex(incentiveKey.endTime),
-      refundee: refundee
-    };
-  };
-  return Staker;
-}();
-Staker.INTERFACE = /*#__PURE__*/new Interface(IUniswapV3Staker.abi);
-Staker.INCENTIVE_KEY_ABI = 'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)';
+      refundee: refundee,
+    }
+  }
+  return Staker
+})()
+Staker.INTERFACE = /*#__PURE__*/ new Interface(IUniswapV3Staker.abi)
+Staker.INCENTIVE_KEY_ABI =
+  'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)'
 
 /**
  * Represents the Uniswap V3 SwapRouter, and has static methods for helping execute trades.
  */
-var SwapRouter = /*#__PURE__*/function () {
+var SwapRouter = /*#__PURE__*/ (function () {
   /**
    * Cannot be constructed.
    */
@@ -3097,54 +4178,68 @@ var SwapRouter = /*#__PURE__*/function () {
    */
   SwapRouter.swapCallParameters = function swapCallParameters(trades, options) {
     if (!Array.isArray(trades)) {
-      trades = [trades];
+      trades = [trades]
     }
-    var sampleTrade = trades[0];
-    var tokenIn = sampleTrade.inputAmount.currency.wrapped;
-    var tokenOut = sampleTrade.outputAmount.currency.wrapped;
+    var sampleTrade = trades[0]
+    var tokenIn = sampleTrade.inputAmount.currency.wrapped
+    var tokenOut = sampleTrade.outputAmount.currency.wrapped
     // All trades should have the same starting and ending token.
     !trades.every(function (trade) {
-      return trade.inputAmount.currency.wrapped.equals(tokenIn);
-    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN_IN_DIFF') : invariant(false) : void 0;
+      return trade.inputAmount.currency.wrapped.equals(tokenIn)
+    })
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TOKEN_IN_DIFF')
+        : invariant(false)
+      : void 0
     !trades.every(function (trade) {
-      return trade.outputAmount.currency.wrapped.equals(tokenOut);
-    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN_OUT_DIFF') : invariant(false) : void 0;
-    var calldatas = [];
-    var ZERO_IN = CurrencyAmount.fromRawAmount(trades[0].inputAmount.currency, 0);
-    var ZERO_OUT = CurrencyAmount.fromRawAmount(trades[0].outputAmount.currency, 0);
+      return trade.outputAmount.currency.wrapped.equals(tokenOut)
+    })
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'TOKEN_OUT_DIFF')
+        : invariant(false)
+      : void 0
+    var calldatas = []
+    var ZERO_IN = CurrencyAmount.fromRawAmount(trades[0].inputAmount.currency, 0)
+    var ZERO_OUT = CurrencyAmount.fromRawAmount(trades[0].outputAmount.currency, 0)
     var totalAmountOut = trades.reduce(function (sum, trade) {
-      return sum.add(trade.minimumAmountOut(options.slippageTolerance));
-    }, ZERO_OUT);
+      return sum.add(trade.minimumAmountOut(options.slippageTolerance))
+    }, ZERO_OUT)
     // flag for whether a refund needs to happen
-    var mustRefund = sampleTrade.inputAmount.currency.isNative && sampleTrade.tradeType === TradeType.EXACT_OUTPUT;
-    var inputIsNative = sampleTrade.inputAmount.currency.isNative;
+    var mustRefund = sampleTrade.inputAmount.currency.isNative && sampleTrade.tradeType === TradeType.EXACT_OUTPUT
+    var inputIsNative = sampleTrade.inputAmount.currency.isNative
     // flags for whether funds should be send first to the router
-    var outputIsNative = sampleTrade.outputAmount.currency.isNative;
-    var routerMustCustody = outputIsNative || !!options.fee;
-    var totalValue = inputIsNative ? trades.reduce(function (sum, trade) {
-      return sum.add(trade.maximumAmountIn(options.slippageTolerance));
-    }, ZERO_IN) : ZERO_IN;
+    var outputIsNative = sampleTrade.outputAmount.currency.isNative
+    var routerMustCustody = outputIsNative || !!options.fee
+    var totalValue = inputIsNative
+      ? trades.reduce(function (sum, trade) {
+          return sum.add(trade.maximumAmountIn(options.slippageTolerance))
+        }, ZERO_IN)
+      : ZERO_IN
     // encode permit if necessary
     if (options.inputTokenPermit) {
-      !sampleTrade.inputAmount.currency.isToken ? process.env.NODE_ENV !== "production" ? invariant(false, 'NON_TOKEN_PERMIT') : invariant(false) : void 0;
-      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));
-    }
-    var recipient = validateAndParseAddress(options.recipient);
-    var deadline = toHex(options.deadline);
-    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done;) {
-      var trade = _step.value;
-      for (var _iterator2 = _createForOfIteratorHelperLoose(trade.swaps), _step2; !(_step2 = _iterator2()).done;) {
+      !sampleTrade.inputAmount.currency.isToken
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'NON_TOKEN_PERMIT')
+          : invariant(false)
+        : void 0
+      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))
+    }
+    var recipient = validateAndParseAddress(options.recipient)
+    var deadline = toHex(options.deadline)
+    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done; ) {
+      var trade = _step.value
+      for (var _iterator2 = _createForOfIteratorHelperLoose(trade.swaps), _step2; !(_step2 = _iterator2()).done; ) {
         var _step2$value = _step2.value,
           route = _step2$value.route,
           inputAmount = _step2$value.inputAmount,
-          outputAmount = _step2$value.outputAmount;
-        var amountIn = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);
-        var amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient);
+          outputAmount = _step2$value.outputAmount
+        var amountIn = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)
+        var amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)
         // flag for whether the trade is single hop or not
-        var singleHop = route.pools.length === 1;
+        var singleHop = route.pools.length === 1
         if (singleHop) {
           if (trade.tradeType === TradeType.EXACT_INPUT) {
-            var _options$sqrtPriceLim;
+            var _options$sqrtPriceLim
             var exactInputSingleParams = {
               tokenIn: route.tokenPath[0].address,
               tokenOut: route.tokenPath[1].address,
@@ -3153,11 +4248,13 @@ var SwapRouter = /*#__PURE__*/function () {
               deadline: deadline,
               amountIn: amountIn,
               amountOutMinimum: amountOut,
-              sqrtPriceLimitX96: toHex((_options$sqrtPriceLim = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]));
+              sqrtPriceLimitX96: toHex(
+                (_options$sqrtPriceLim = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0,
+              ),
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))
           } else {
-            var _options$sqrtPriceLim2;
+            var _options$sqrtPriceLim2
             var exactOutputSingleParams = {
               tokenIn: route.tokenPath[0].address,
               tokenOut: route.tokenPath[1].address,
@@ -3166,31 +4263,37 @@ var SwapRouter = /*#__PURE__*/function () {
               deadline: deadline,
               amountOut: amountOut,
               amountInMaximum: amountIn,
-              sqrtPriceLimitX96: toHex((_options$sqrtPriceLim2 = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim2 : 0)
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]));
+              sqrtPriceLimitX96: toHex(
+                (_options$sqrtPriceLim2 = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim2 : 0,
+              ),
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))
           }
         } else {
-          !(options.sqrtPriceLimitX96 === undefined) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MULTIHOP_PRICE_LIMIT') : invariant(false) : void 0;
-          var path = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT);
+          !(options.sqrtPriceLimitX96 === undefined)
+            ? process.env.NODE_ENV !== 'production'
+              ? invariant(false, 'MULTIHOP_PRICE_LIMIT')
+              : invariant(false)
+            : void 0
+          var path = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)
           if (trade.tradeType === TradeType.EXACT_INPUT) {
             var exactInputParams = {
               path: path,
               recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
               deadline: deadline,
               amountIn: amountIn,
-              amountOutMinimum: amountOut
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]));
+              amountOutMinimum: amountOut,
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))
           } else {
             var exactOutputParams = {
               path: path,
               recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
               deadline: deadline,
               amountOut: amountOut,
-              amountInMaximum: amountIn
-            };
-            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]));
+              amountInMaximum: amountIn,
+            }
+            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))
           }
         }
       }
@@ -3199,26 +4302,75 @@ var SwapRouter = /*#__PURE__*/function () {
     if (routerMustCustody) {
       if (!!options.fee) {
         if (outputIsNative) {
-          calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient, options.fee));
+          calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient, options.fee))
         } else {
-          calldatas.push(Payments.encodeSweepToken(sampleTrade.outputAmount.currency.wrapped, totalAmountOut.quotient, recipient, options.fee));
+          calldatas.push(
+            Payments.encodeSweepToken(
+              sampleTrade.outputAmount.currency.wrapped,
+              totalAmountOut.quotient,
+              recipient,
+              options.fee,
+            ),
+          )
         }
       } else {
-        calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient));
+        calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient))
       }
     }
     // refund
     if (mustRefund) {
-      calldatas.push(Payments.encodeRefundETH());
+      calldatas.push(Payments.encodeRefundETH())
     }
     return {
       calldata: Multicall.encodeMulticall(calldatas),
-      value: toHex(totalValue.quotient)
-    };
-  };
-  return SwapRouter;
-}();
-SwapRouter.INTERFACE = /*#__PURE__*/new Interface(ISwapRouter.abi);
+      value: toHex(totalValue.quotient),
+    }
+  }
+  return SwapRouter
+})()
+SwapRouter.INTERFACE = /*#__PURE__*/ new Interface(ISwapRouter.abi)
 
-export { ADDRESS_ZERO, FACTORY_ADDRESS, FeeAmount, FullMath, LiquidityMath, Multicall, NoTickDataProvider, NonfungiblePositionManager, POOL_INIT_CODE_HASH, Payments, Pool, Position, PositionLibrary, Route, SelfPermit, SqrtPriceMath, Staker, SwapMath, SwapQuoter, SwapRouter, TICK_SPACINGS, Tick, TickLibrary, TickList, TickListDataProvider, TickMath, Trade, computePoolAddress, encodeRouteToPath, encodeSqrtRatioX96, isSorted, maxLiquidityForAmounts, mostSignificantBit, nearestUsableTick, poolInitCodeHash, priceToClosestTick, subIn256, tickToPrice, toHex, tradeComparator, v3Swap };
+export {
+  ADDRESS_ZERO,
+  FACTORY_ADDRESS,
+  FeeAmount,
+  FullMath,
+  LiquidityMath,
+  Multicall,
+  NoTickDataProvider,
+  NonfungiblePositionManager,
+  POOL_INIT_CODE_HASH,
+  Payments,
+  Pool,
+  Position,
+  PositionLibrary,
+  Route,
+  SelfPermit,
+  SqrtPriceMath,
+  Staker,
+  SwapMath,
+  SwapQuoter,
+  SwapRouter,
+  TICK_SPACINGS,
+  Tick,
+  TickLibrary,
+  TickList,
+  TickListDataProvider,
+  TickMath,
+  Trade,
+  computePoolAddress,
+  encodeRouteToPath,
+  encodeSqrtRatioX96,
+  isSorted,
+  maxLiquidityForAmounts,
+  mostSignificantBit,
+  nearestUsableTick,
+  poolInitCodeHash,
+  priceToClosestTick,
+  subIn256,
+  tickToPrice,
+  toHex,
+  tradeComparator,
+  v3Swap,
+}
 //# sourceMappingURL=v3-sdk.esm.js.map
